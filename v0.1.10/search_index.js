var documenterSearchIndex = {"docs":
[{"location":"examples/superradiant-laser/#Superradiant-Laser","page":"Superradiant Laser","title":"Superradiant Laser","text":"","category":"section"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"Using symmetry properties of a system can reduce the number of needed equations dramatically. A common approximation for laser systems to handle sufficiently big atom numbers is to assume that several atoms in the system behave completely identically. This means all the identical atoms have the same averages.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"In this example we describe a so-called superradiant laser, where we assume all atoms to be identical. This model has been described in D. Meiser et al., Phys. Rev. Lett. 102, 163601 (2009): The Hamiltonian of this system is","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"H = - hbar Delta a^dagger a +  hbar sumlimits_j=1^N  g_j (a^dagger sigma^12_j + a sigma^21_j)","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"where Delta = omega_a - omega_c is the detuning between the cavity (omega_c) and the atomic (omega_a) resonance frequency, the atom cavity coupling of the atom j is denoted by g_j. Additionally there are dissipative processes in the system, namely: Atoms are incoherently pumped with the rate R, they decay individually with the rate Gamma and are affected by individual atomic dephasing with the rate nu. Photons leak out of the system with the rate kappa.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"We start by loading the packages.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\nusing OrdinaryDiffEq, SteadyStateDiffEq, ModelingToolkit\nusing Plots","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"To give QuantumCumulants the information that several atoms behave identically we need to create a textttClusterSpace on the desired Hilbert space. This textttClusterSpace additionally needs the order M of the system and a symbolic parameter for the number of identical elements N.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"M = 2 # order\n@cnumbers N Δ g κ Γ R ν\n\n# Hilbertspace\nhc = FockSpace(:cavity)\nha_ = NLevelSpace(:atom,2)\nha = ClusterSpace(ha_, N, M)\nh = hc ⊗ ha","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"Now we can define the operators on the composite Hilbert space including the textttClusterSpace, the workflow is completely the same as for 'normal' Hilbert spaces.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# operators\n@qnumbers a::Destroy(h)\nσ(i,j) = Transition(h, :σ, i, j, 2)\nσ(2,2)","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"What is different, however, is that the transition operator defined on the textttClusterSpace is an array of M transitions defined on internally created sub-Hilbert spaces. The reason for this is the following: Although we assume all atoms to be identical, we still need to keep track of the correlations between different atoms. Since langle sigma^21_1 sigma^12_1 rangle = langle sigma^22_1 rangle is obviously not equal to langle sigma^21_1 sigma^12_2 rangle at least a second atom is needed for a second order description. On the other hand, as all atoms are the same, it must hold that langle sigma^21_1 sigma^12_2 rangle = langle sigma^21_alpha sigma^12_beta rangle for all alpha ne beta, therefore two atoms are sufficient. For higher orders and or bosonic operators the arguments are the same.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"The symbolic calculation rules for these operators acting on a textttClusterSpace are implemented such that e.g. sumlimits_j sigma^22_j can be written as sum(sigma(22)) in the code. For the jump operators the syntax is such that individual atomic dissipation is written as J = σ(ij), whereas collective behaviour is expressed as J = sum(σ(ij)). The Hamiltonian and the dissipative processes for individual atomic behaviour are therefore","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# Hamiltonian\nH = -Δ*a'a + g*(a'*sum(σ(1,2)) + a*sum(σ(2,1)))\n\n# Jump operators & rates\nJ = [a, σ(1,2), σ(2,1), σ(2,2)]\nrates = [κ, Γ, R, ν]\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"First we want to derive the equation for langle a^dagger a rangle and langle sigma_1^22 rangle. textttQuantumCumulants automatically sets the right scaling factors in the equations to account for the number of identical atoms and also replaces redundant averages, e.g. langle sigma_2^22 rangle is replaced by langle sigma_1^22 rangle in the equations, since all atoms behave identically these two averages are the same.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# Derive equations\nops = [a'*a, σ(2,2)[1]]\neqs = meanfield(ops,H,J;rates=rates,order=M)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"beginalign\nfracddt langle a^dagger  arangle  = -10 kappa langle a^dagger  arangle  -10 i N g langle a^dagger  sigma_1^12rangle  + 10 i N g langle a  sigma_1^21rangle  \nfracddt langle sigma_1^22rangle  = R -10 R langle sigma_1^22rangle  + 1 i g langle a^dagger  sigma_1^12rangle  -1 i g langle a  sigma_1^21rangle  -10 Gamma langle sigma_1^22rangle\nendalign","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"To get a closed set of equations we automatically complete the system. Since this system is phase invariant we know that all averages with a phase are zero, therefore we exclude these terms with a filter function.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# custom filter function\nφ(x::Average) = φ(x.arguments[1])\nφ(::Destroy) = -1\nφ(::Create) =1\nφ(x::QTerm) = sum(map(φ, x.args_nc))\nφ(x::Transition) = x.i - x.j\nphase_invariant(x) = iszero(φ(x))\n\n# Complete equations\neqs_c = complete(eqs; filter_func=phase_invariant)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"beginalign\nfracddt langle a^dagger  arangle  = -10 kappa langle a^dagger  arangle  -10 i N g langle a^dagger  sigma_1^12rangle  + 10 i N g langle a  sigma_1^21rangle  \nfracddt langle sigma_1^22rangle  = R -10 R langle sigma_1^22rangle  + 1 i g langle a^dagger  sigma_1^12rangle  -1 i g langle a  sigma_1^21rangle  -10 Gamma langle sigma_1^22rangle  \nfracddt langle a^dagger  sigma_1^12rangle  = -05 R langle a^dagger  sigma_1^12rangle  + 1 i g langle sigma_1^22rangle  -1 i g langle a^dagger  arangle  -05 Gamma langle a^dagger  sigma_1^12rangle  -1 i Delta langle a^dagger  sigma_1^12rangle  -05 kappa langle a^dagger  sigma_1^12rangle  -05 nu langle a^dagger  sigma_1^12rangle  + 2 i g langle sigma_1^22rangle  langle a^dagger  arangle  + 1 i g langle sigma_1^21  sigma_2^12rangle  left( -1 + N right) \nfracddt langle sigma_1^21  sigma_2^12rangle  = -10 R langle sigma_1^21  sigma_2^12rangle  + 1 i g langle a^dagger  sigma_1^12rangle  -1 i g langle a  sigma_1^21rangle  -10 Gamma langle sigma_1^21  sigma_2^12rangle  -10 nu langle sigma_1^21  sigma_2^12rangle  -2 i g langle sigma_1^22rangle  langle a^dagger  sigma_1^12rangle  + 2 i g langle sigma_1^22rangle  langle a  sigma_1^21rangle\nendalign","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"To calculate the dynamics of the system we create a system of ordinary differential equations, which can be used by DifferentialEquations.jl.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"sys = ODESystem(eqs_c)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"Finally we need to define the numerical parameters and the initial state of the system. We will consider 2 cdot 10^5 Strontium atoms which are repumped with a rate of R = 1textHz on the clock transition (Gamma = 1 textmHz). The atom-cavity coupling rate is g = 1textHz, the cavity has a linewidth of kappa = 5textkHz and is detuned from the atomic resonance by Delta = 25textHz.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# Initial state\nu0 = zeros(ComplexF64, length(eqs_c))\n# System parameters\nN_ = 2e5\nΓ_ = 1.0 #Γ=1mHz\nΔ_ = 2500Γ_ #Δ=2.5Hz\ng_ = 1000Γ_ #g=1Hz\nκ_ = 5e6*Γ_ #κ=5kHz\nR_ = 1000Γ_ #R=1Hz\nν_ = 1000Γ_ #ν=1Hz\n\nps = [N, Δ, g, κ, Γ, R, ν]\np0 = [N_, Δ_, g_, κ_, Γ_, R_, ν_]\n\nprob = ODEProblem(sys,u0,(0.0, 1.0/50Γ_), ps.=>p0)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"sol = solve(prob,Tsit5(),maxiters=1e7)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# Plot time evolution\nt = sol.t\nn = real.(sol[a'a])\ns22 = real.(sol[σ(2,2)[1]])\n\n# Plot\np1 = plot(t, n, xlabel=\"tΓ\", ylabel=\"⟨a⁺a⟩\", legend=false)\np2 = plot(t, s22, xlabel=\"tΓ\", ylabel=\"⟨σ22⟩\", legend=false)\nplot(p1, p2, layout=(1,2), size=(700,300))\nsavefig(\"superradiant_laser_time.svg\") # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"(Image: svg)","category":"page"},{"location":"examples/superradiant-laser/#Spectrum","page":"Superradiant Laser","title":"Spectrum","text":"","category":"section"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"We calculate the spectrum here with the Laplace transform of the two-time correlation function. This is implemented with the function textttSpectrum.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"corr = CorrelationFunction(a', a, eqs_c; steady_state=true, filter_func=phase_invariant)\nS = Spectrum(corr, ps)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"The set of equations for the correlation function is given by","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"corr.de\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"beginalign\nfracddtau langle a^dagger  a_0rangle  = -1 i Delta langle a^dagger  a_0rangle  -05 kappa langle a^dagger  a_0rangle  + 10 i N g langle sigma_1^21  a_0rangle  \nfracddtau langle sigma_1^21  a_0rangle  = -05 R langle sigma_1^21  a_0rangle  + 1 i g langle a^dagger  a_0rangle  -05 Gamma langle sigma_1^21  a_0rangle  -05 nu langle sigma_1^21  a_0rangle  -2 i g langle sigma_1^22rangle  langle a^dagger  a_0rangle\nendalign","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"To ensure we are in the steady state we use a steady solver to calculate it. To this end we need to define the textttSteadyStateProblem and specify the desired method. We also need to increase the textttmaxiters and the solver accuracy to handle this numerically involved problem.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"prob_ss = SteadyStateProblem(prob)\nsol_ss = solve(prob_ss, DynamicSS(Tsit5(); abstol=1e-8, reltol=1e-8),\n    reltol=1e-14, abstol=1e-14, maxiters=5e7)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"The spectrum is then calculated with","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"ω = [-10:0.01:10;]Γ_\nspec = S(ω,sol_ss.u,p0)\nspec_n = spec ./ maximum(spec)\nδ = abs(ω[(findmax(spec)[2])])","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"plot(ω, spec_n, xlabel=\"ω/Γ\", legend=false, size=(500,300))\nsavefig(\"superradiant_laser_spec.svg\") # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"(Image: svg)","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"Beside the narrow linewidth we can also see another key feature of the superradiant laser here, namely the very weak cavity pulling. At a detunig of Delta = 2500Gamma there is only a shift of the laser light from the atomic resonance frequency of delta = 1Gamma.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser","title":"Superradiant Laser","text":"note: Note\nThe implementation of the scaling rules are still in an early stage of development and they are quite 'experimental'. So make sure to double check the equations when using them in more complicated systems.","category":"page"},{"location":"examples/single-atom-laser-spectrum/#Spectrum-of-a-single-atom-laser","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"","category":"section"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"In this example, we will compute the spectrum of the single-atom laser, which is also shown in the Tutorial. The Hamitlonian of the system is","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"H = Delta a^dagger a + gleft(a^dagger sigma^ge + asigma^egright)","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"where Delta = omega_mathrmc - omega_mathrma is the detuning between the cavity and the atomic resonance frequency, respectively. The cavity loses photons at a rate kappa, and the atom is subject to spontaneous emission with a rate gamma. Additionally, the atom is incoherently driven with a rate nu, such that it can provide lasing gain to the system. We start, by specifying this model.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\nusing ModelingToolkit, OrdinaryDiffEq\nusing Plots\n\n# Define parameters\n@cnumbers Δ g γ κ ν\n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf ⊗ ha\n\n# Define the fundamental operators\na = Destroy(h,:a)\ns = Transition(h,:σ,:g,:e)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*s + a*s')\n\n# Collapse operators\nJ = [a,s,s']\nrates = [κ,γ,ν]\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"The first equation we want to derive is that for the average photon number langle a^dagger a rangle.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Derive equation for average photon number\neq_n = meanfield(a'*a,H,J;rates=rates,order=2)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"The remaining equations will be computed automatically using the complete function. However, we want to exclude terms such as langle a rangle since these are phase-dependent and therefore 0 in our phase-invariant system. To this end, we provide a custom filter function to complete. This function should return true, if the given average should be included, and false if it should be excluded (just like Julia's native filter function requires). We write a small function phi that computes the phase of an average, such that phi(a) = -1, phi(a^dagger) = 1, and phi(a^dagger a) = phi(a) + phi(a^dagger) = 0. Similarly, we want to have phi(sigma^eg)=1=-phi(sigma^ge), and phi(sigma^ee)=0. An average of an operator x is then said to be phase invariant if phi(x)=0.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Custom filter function -- include only phase-invariant terms\nϕ(x) = 0\nϕ(::Destroy) = -1\nϕ(::Create) = 1\nfunction ϕ(t::Transition)\n    if (t.i==:e && t.j==:g)\n        1\n    elseif (t.i==:g && t.j==:e)\n        -1\n    else\n        0\n    end\nend\nϕ(avg::Average) = ϕ(avg.arguments[1])\nfunction ϕ(t::QuantumCumulants.QMul)\n    p = 0\n    for arg in t.args_nc\n        p += ϕ(arg)\n    end\n    return p\nend\nphase_invariant(x) = iszero(ϕ(x))\n\n# Complete equations\neqs = complete(eq_n;filter_func=phase_invariant)","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"In order to compute the spectrum, we first compute the correlation function g(tau) = langle a^dagger(t_0 + tau) a(t_0)rangle equiv langle a^dagger a_0rangle","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Note that the CorrelationFunction finds the equation for g(tau) and then completes the system of equations by using its own version of the complete function. We can also provide the same custom filter function as before to skip over terms that are not phase-invariant. Similarly, setting the keyword steady_state=true, we tell the function not to derive equations of motion for operators that do not depend on tau, but only on t_0 (if t_0 is in steady state, these values do not change with tau).","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Correlation function\nc = CorrelationFunction(a', a, eqs; steady_state=true, filter_func=phase_invariant)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"langle a^dagger a_0rangle","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"As we can see, there are only two equations necessary to obtain the correlation function:","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"c.de\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"beginalign fracddt langle a^dagger a_0rangle = 10 i g langle sigma^eg a_0rangle + 10 i Delta langle a^dagger a_0rangle -05 kappa langle a^dagger a_0rangle \nfracddt langle sigma^eg a_0rangle = 10 i g langle a^dagger a_0rangle -05 gamma langle sigma^eg a_0rangle -05 nu langle sigma^eg a_0rangle -20 i langle sigma^eerangle g langle a^dagger a_0rangle\nendalign","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"The spectrum can now be computed by solving the above system of equations and then taking the Fourier transform, or by taking the Fourier transform directly, which is done by constructing an instance of the Spectrum type. Here, we will compare both approaches.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"In any case, we need to compute the steady state of the system numerically.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Numerical solution\nps = (Δ, g, γ, κ, ν)\nsys = ODESystem(eqs)\nu0 = zeros(ComplexF64, length(eqs))\np0 = (1.0, 1.5, 0.25, 1, 4)\nprob = ODEProblem(sys,u0,(0.0,10.0),ps.=>p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Now, we can compute the time evolution of the correlation function in a similar way. Since the initial state of this system does not necessarily depend on all steady-state values, we can use the correlation_u0 function which automatically generates the correct initial state vector required. Similarly, we use correlation_p0 which generates the list of parameters including all needed steady-state values.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Time evolution of correlation function\ncsys = ODESystem(c)\nu0_c = correlation_u0(c,sol.u[end])\np0_c = correlation_p0(c,sol.u[end],ps.=>p0)\nprob_c = ODEProblem(csys,u0_c,(0.0,500.0),p0_c)\nsol_c = solve(prob_c,RK4(),save_idxs=1)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Finally, we borrow the FFT function from QuantumOptics.jl and compute the spectrum from the solution. Note that this requires an equidistant list of times, and we therefore interpolate the solution from the differential equation.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Interpolate solution\nτ = range(0.0, sol_c.t[end], length=15001)\ncorr = sol_c.(τ)\n\n# Compute spectrum\nusing QuantumOptics.timecorrelations: correlation2spectrum\nω, s_fft = correlation2spectrum(τ, corr)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Now, in order to compare we also compute the spectrum by constructing it directly from the correlation function and plot the results.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Spectrum\nS = Spectrum(c,ps)\ns_laplace = S(ω,sol.u[end],p0)\nnothing # hide\n\nplot(ω, s_fft, label=\"Spectrum (FFT)\", xlabel=\"ω\")\nplot!(ω, s_laplace, label=\"Spectrum (Laplace)\")\nxlims!(-3,3)\nsavefig(\"laser-spectrum.svg\") # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"(Image: svg)","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"As expected, both methods yield exactly the same spectrum. The difference is just in the method used, with the Laplace transform having a computational advantage.","category":"page"},{"location":"correlation/#Correlation-functions-and-spectra","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Two quantities that are often of interest in a system are two-time correlation functions and spectral densities. Consider, for example, two operators a and b. Their two-time correlation function is given by","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"g(ttau) = langle a(t+tau) b(t)rangle","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"As we can see, we need to take some care here since g depends on two different times. The spectral density corresponding to a and b is given by the Fourier transform,","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"S(omega) = 2textReleftint dtau e^-iomegataug(ttau)right","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"So in any case, we need to treat the two-time correlation function before we can obtain the spectrum.","category":"page"},{"location":"correlation/#Correlation-function","page":"Correlation functions and spectra","title":"Correlation function","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"In order to compute a correlation function, we first evolve a system of equations up to a time t. Then, we can derive another set of equations that describe the correlation function. This new set of equations is then evolved from time t up to a time t+tau. The correlation function is then stored in the first entry of the result. The initial state of the set of equations describing the correlation function will be determined by the state of the original system at time t.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Note, that whenever an instance of a CorrelationFunction is created, a set of equations is derived using a custom version of the complete function. Depending on the size and order of the considered system, this can take some time. An important distinction that can eventually reduce the computation time by quite a bit is whether or not the original system has been evolved up to steady state, i.e. if the system does not change its state after t. This can be controlled with the keyword argument steady_state=true when construction the CorrelationFunction.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"To clarify the usage, consider the simple case of a cavity with resonance frequency omega_mathrmc that initially has a finite number of photons inside which decay over time at a rate kappa. We want to compute the two-time correlation function of the field (first-order degree of coherence) given by","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"g(ttau) = langle a^dagger(t+tau)a(t)rangle","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Given the Hamiltonian H = omega_mathrmca^dagger a and the collapse operator a, it is easy to derive the equation","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"fracddtaua^dagger(t+tau) = (iomega_mathrmc - frackappa2)a^dagger(t+tau)","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Since a(t) is independent of tau we can simply multiply the above equation with a(t) from the right and average to obtain","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"fracddtaulangle a^dagger(t+tau) a(t)rangle = (iomega_mathrmc - frackappa2)langle a^dagger(t+tau) a(t)rangle","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Note that this is generally valid, and will lead to a system of equations that is linear in a(t). The above is the equation of motion for the correlation function g(ttau). In this very simple case we can solve it analytically and find","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"g(ttau) = langle a^dagger(t)a(t)rangle e^(iomega_mathrmc - kappa2)tau","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"This is the essential procedure with which correlation functions can be computed within QuantumCumulants.jl. In code, the above is just:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"using QuantumCumulants # hide\nh = FockSpace(:cavity)\na = Destroy(h,:a)\n@cnumbers ωc κ\nH = ωc*a'*a\nme = meanfield(a'*a,H,[a];rates=[κ])\n\nc = CorrelationFunction(a', a, me)\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"When the CorrelationFunction is constructed, an additional Hilbert space is added internally which represents the system at the time t. In our case, this means that another FockSpace is added. Note that all operators involved in the correlation function are defined on the ProductSpace including this additional Hilbert space.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The equation for g(ttau) is now stored in the first entry of c.de. To solve the above numerically, we need to convert to an ODESystem and solve numerically.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"using ModelingToolkit, OrdinaryDiffEq\n\nsys = ODESystem(me)\nn0 = 20.0 # Initial number of photons in the cavity\nu0 = [n0]\np0 = (1,1)\nprob = ODEProblem(sys,u0,(0.0,2.0),p0) # End time not in steady state\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Numerically computing the correlation function works in the same way. Note, the initial state of the correlation function depends on the final state of the system. However, in general it does not depend on all the final values of the system. The correct values can be picked out automatically using the correlation_u0 function.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"csys = ODESystem(c)\nu0_c = correlation_u0(c, sol.u[end])\nprob_c = ODEProblem(csys,u0_c,(0.0,10.0),p0)\nsol_c = solve(prob_c,RK4(),save_idxs=1)\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Finally, lets check our numerical solution against the analytic one obtained above:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"using Test # hide\ng_analytic(τ) = @. sol.u[end] * exp((im*p0[1]-0.5p0[2])*τ)\n@test isapprox(sol_c.u, g_analytic(sol_c.t), rtol=1e-4)","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Note, that this was a very simple case. Usually the system of equations describing the correlation function is much more complex and depends on multiple other correlation functions (see for example Spectrum of a single atom laser).","category":"page"},{"location":"correlation/#Spectrum","page":"Correlation functions and spectra","title":"Spectrum","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"There are two possible ways two compute the spectrum given a correlation function:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Solving the differential equation needed to obtain g(ttau) and taking the Fourier transform.\nTaking the (symbolic) Laplace transform of the system of equations describing a correlation function.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"On the one hand, the first approach works generally, but is computationally more intense. The second approach, on the other hand, yields a simple linear system of equations which is easy to solve, but only works when the correlation function has been computed starting from the steady state. Both methods can be easily used with QuantumCumulants.jl.","category":"page"},{"location":"correlation/#Numerical-solution-of-g(t,\\tau)","page":"Correlation functions and spectra","title":"Numerical solution of g(ttau)","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"As mentioned above, this approach works generally, regardless of whether the system is in steady state at time t. However, it has some computational drawbacks. Additionally, the spectrum is not always well defined when not in steady state. This approach is the same as the one used in QuantumOptics.jl, and we can borrow the implemented FFT function from there:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"τ = collect(range(0.0, sol_c.t[end], length=101)) # need equidistant list of times for FFT\nusing QuantumOptics.timecorrelations: correlation2spectrum\nω, s = correlation2spectrum(τ, sol_c.(τ))\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The spectrum obtained in this way roughly has a FWHM of κ and is based around the chosen ωc. The fact that the FWHM is not exactly κ illustrates the computation drawback: in order to obtain the correct FWHM we would have to increase the integration time by orders of magnitude. For larger systems, this can be computationally expensive.","category":"page"},{"location":"correlation/#Steady-state:-using-the-Laplace-transform","page":"Correlation functions and spectra","title":"Steady state: using the Laplace transform","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"A useful property of the two-time correlation function is that, if the system is in steady state at time t, then the system of equations is linear, since b(t) can occur at most once in each product. We can therefore write any system of equations describing the correlation function as","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"fracddtau textbfy(tau) = textbfM textbfy(tau) + textbfc","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"where textbfy(tau) is the vector containing the left-hand-side of the correlation function system (g(ttau) equiv y_1(tau)). The matrix textbfM contains coefficients consisting of parameters and steady-state values, and is independent of time, and the vector textbfc includes other constants.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"We define textbfx(s) = mathcalLleft(textbfy(tau)right), i.e. textbfx(s) is the Laplace transform of textbfy(tau) with respect to tau. Applying the Laplace transform to the differential equation above, we obtain","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"(s - textbfM)textbfx(s) = textbfy(0) + fractextbfcs","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The Laplace transform is equivalent to the Fourier transform at the point s=i omega, i.e. the spectrum is given by S(omega) = 2textReleftx_1(iomega)right. Therefore, we can reduce the task to solving the equation","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Atextbfx = b + c","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"where A = iomega - textbfM, b = textbfy(0) and c=textbfc(iomega). In most cases, solving the above matrix equation is much faster than doing an additional time evolution to obtain the correlation function.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"This approach is implemented with the Spectrum type, which performs the Laplace transform and computes the matrix A and the vectors b and c symbolically. Additionally, functions that return all those things in numerical form depending on the steady-state values and given parameters are generated via Symbolics build_function. Usage is as follows:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"c = CorrelationFunction(a', a, me; steady_state=true) # need to specify steady state\nS = Spectrum(c,(ωc,κ))\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The above performs the Laplace transform on a symbolic level (i.e. it derives the matrix A). To actually compute the spectrum, we can do","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"s = S(ω,sol.u[end],p0)\nnothing # hide","category":"page"},{"location":"correlation/#Examples:","page":"Correlation functions and spectra","title":"Examples:","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Mollow Triplet\nSpectrum of a single atom laser","category":"page"},{"location":"examples/mollow/#Mollow-Triplet","page":"Mollow Triplet","title":"Mollow Triplet","text":"","category":"section"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"In the following example, we show how one can compute the resonance spectrum of a single, coherently driven atom. The Hamiltonian describing the system is given by","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"H = -Deltasigma^ee + Omegaleft(sigma^ge + sigma^egright)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"where Delta = omega_ell - omega_a is the detuning between the laser and the atomic resonance frequency and Omega is the Rabi frequency of the laser. The atom is also subject to decay at rate gamma with the damping operator sigma^ge = grangle langle e  projecting it from the excited state erangle  to its ground state grangle.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\nusing ModelingToolkit, OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Obtaining the equations of motion for the system is simple. Note that in this case, we are not actually making any assumptions: in the special case of a single atom (even if it has more than two levels), there exists a simple mapping between the equations of motions for averages and the density operator. In our case, the density operator rho is determined by only two average values, langlesigma^egrangle = rho_eg = rho_ge^*  and langle sigma^eerangle = rho_ee = 1 - rho_gg. In other words, we are solving the master equation component-wise.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"# Hilbert space\nh = NLevelSpace(:atom, (:g,:e))\n\n# Operators\n@cnumbers Δ Ω γ\n@qnumbers σ::Transition(h)\nH = Δ*σ(:e,:e) + Ω*(σ(:g,:e) + σ(:e,:g))\nJ = [σ(:g,:e)]\n\n# Equations\neqs = meanfield([σ(:e,:g),σ(:e,:e)], H, J; rates=[γ])","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"In order to compute the spectrum, we first need to compute the correlation function given by","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"g(tau) = langle sigma^eg(t_0+tau)sigma^ge(t_0)rangle equiv langle sigma^egsigma^ge_0rangle","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"where t_0 is any time after which the original system has reached steady state. Note, that in the second step we simplified the notation by dropping the temporal arguments. The subscript 0 indicates operators given at t_0.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"The correlation function of the system given by eqs can be computed as follows.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"# Correlation Function\nc = CorrelationFunction(σ(:e,:g), σ(:g,:e), eqs; steady_state=true)\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Note that the above actually derives another set of equations, which might take some time. Specifically, it is deriving the equation of motion for g(tau) and automatically completes the system of equation deriving the necessary equations of motion for all average values on which g(tau) depends. Here, the system of equations reads","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"c.de\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"beginalign\nfracddt langle sigma^eg  sigma_0^gerangle  = 10 i langle sigma_0^gerangle  Omega + 10 i Delta langle sigma^eg  sigma_0^gerangle  -20 i Omega langle sigma^ee  sigma_0^gerangle  -05 gamma langle sigma^eg  sigma_0^gerangle  \nfracddt langle sigma^ee  sigma_0^gerangle  = -10 i Omega langle sigma^eg  sigma_0^gerangle  + 10 i Omega langle sigma^ge  sigma_0^gerangle  -10 gamma langle sigma^ee  sigma_0^gerangle  \nfracddt langle sigma^ge  sigma_0^gerangle  = -10 i langle sigma_0^gerangle  Omega -10 i Delta langle sigma^ge  sigma_0^gerangle  + 20 i Omega langle sigma^ee  sigma_0^gerangle  -05 gamma langle sigma^ge  sigma_0^gerangle\nendalign","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"As mentioned above, to compute the time evolution of the system itself, we are effectively solving a master equation. One way to obtain the spectrum would be to solve the system in order to obtain the time evolution of the correlation function, and then take the Fourier transform. However, a computationally more efficient way is to take the Laplace transform of the correlation function directly, which yields a simple linear system of equations. Then we only have to compute a matrix inverse instead of the time evolution to obtain the spectrum.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"In the following, we will use the latter approach:","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"ps = (Δ,Ω,γ)\nS = Spectrum(c,ps)\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"mathcalF(langle σ^eg  σ_0^gerangle )(omega)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Constructing the Spectrum from the correlation function, automatically derives a matrix A and a vector b determining the set of linear equations","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"A(omega)x(omega) = b(omega)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"where the spectrum is then given by the first entry of the solution vector, S(omega)=x_1(omega).","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"To find the spectrum, we first need to compute the time evolution of the system up to steady state.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"sys = ODESystem(eqs)\n\np0 = (0.0,2.0,1.0)\nu0 = zeros(ComplexF64, 2)\nprob = ODEProblem(sys,u0,(0.0,20.0),ps .=> p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"plot(sol, vars=((x,y)->(x,real(y)), 0, 2),xlabel=\"γt\", label=\"Excited state population\")\nsavefig(\"mollow-1.svg\") # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"(Image: svg)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Now, solving the linear system to obtain the spectrum can simply be done by calling the instance at a range of frequencies, and providing the proper steady-state values and numerical parameters.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"ω = range(-6pi,6pi,length=1001)\ns = S(ω,sol.u[end],p0)\nplot(ω,s,xlabel=\"ω - ωℓ\",label=\"Resonance spectrum\")\nsavefig(\"mollow-2.svg\") # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"(Image: svg)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"The resulting spectrum shows a prominent peak at the resonance point (omega=omega_ell=omega_a), but also two more peaks around omega approx pm Omega^2gamma. These two resonances originate from the dressed states. These three peaks are called Mollow Triplet.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-Hilbert-Spaces","page":"API","title":"Hilbert Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HilbertSpace","category":"page"},{"location":"api/#QuantumCumulants.HilbertSpace","page":"API","title":"QuantumCumulants.HilbertSpace","text":"HilbertSpace\n\nAbstract type for representing Hilbert spaces.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"ProductSpace","category":"page"},{"location":"api/#QuantumCumulants.ProductSpace","page":"API","title":"QuantumCumulants.ProductSpace","text":"ProductSpace <: HilbertSpace\n\nStores a composite HilbertSpace consisting of multiple subspaces. Generally created by computing the tensor product ⊗ of subspaces.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"FockSpace","category":"page"},{"location":"api/#QuantumCumulants.FockSpace","page":"API","title":"QuantumCumulants.FockSpace","text":"FockSpace <: HilbertSpace\n\nHilbertSpace defining a Fock space for bosonic operators. See also: Destroy, Create\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"NLevelSpace","category":"page"},{"location":"api/#QuantumCumulants.NLevelSpace","page":"API","title":"QuantumCumulants.NLevelSpace","text":"NLevelSpace <: HilbertSpace\nNLevelSpace(name::Symbol,levels,GS=levels[1])\n\nDefine a HilbertSpace for an object consisting of N discrete energy levels. The given levels must be an integer specifying the number of levels, or an iterable collection of levels. The argument GS specifies which state should be treated as ground state and is rewritten using population conservation during simplification. See also: Transition\n\nExamples:\n\njulia> ha = NLevelSpace(:a,3)\nℋ(a)\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nℋ(a)\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"ClusterSpace","category":"page"},{"location":"api/#QuantumCumulants.ClusterSpace","page":"API","title":"QuantumCumulants.ClusterSpace","text":"ClusterSpace <: HilbertSpace\nClusterSpace(original_space,N,order)\n\nA Hilbert space representing N identical copies of another Hilbert space, with correlations up to a specified order.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"⊗","category":"page"},{"location":"api/#QuantumCumulants.:⊗","page":"API","title":"QuantumCumulants.:⊗","text":"⊗(spaces::HilbertSpace...)\n\nCreate a ProductSpace consisting of multiple subspaces. Unicode \\otimes<tab> alias of tensor\n\nExamples\n\njulia> hf = FockSpace(:f)\nℋ(f)\n\njulia> ha = NLevelSpace(:a,2)\nℋ(a)\n\njulia> h = hf⊗ha\nℋ(f) ⊗ ℋ(a)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"tensor","category":"page"},{"location":"api/#QuantumCumulants.tensor","page":"API","title":"QuantumCumulants.tensor","text":"tensor(spaces::HilbertSpace...)\n\nCreate a ProductSpace consisting of multiple subspaces. See also ⊗.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Operators","page":"API","title":"q-Numbers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"QSym","category":"page"},{"location":"api/#QuantumCumulants.QSym","page":"API","title":"QuantumCumulants.QSym","text":"QSym <: QNumber\n\nAbstract type representing fundamental operator types.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"QTerm","category":"page"},{"location":"api/#QuantumCumulants.QTerm","page":"API","title":"QuantumCumulants.QTerm","text":"QTerm <: QNumber\n\nAbstract type representing noncommutative expressions.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"@qnumbers","category":"page"},{"location":"api/#QuantumCumulants.@qnumbers","page":"API","title":"QuantumCumulants.@qnumbers","text":"@qnumbers\n\nConvenience macro for the construction of operators.\n\nExamples\n\njulia> h = FockSpace(:fock)\nℋ(fock)\n\njulia> @qnumbers a::Destroy(h)\n(a,)\n\njulia> h = FockSpace(:one) ⊗ FockSpace(:two)\nℋ(one) ⊗ ℋ(two)\n\njulia> @qnumbers b::Destroy(h,2)\n(b,)\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"Destroy","category":"page"},{"location":"api/#QuantumCumulants.Destroy","page":"API","title":"QuantumCumulants.Destroy","text":"Destroy <: QSym\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator annihilation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Create","category":"page"},{"location":"api/#QuantumCumulants.Create","page":"API","title":"QuantumCumulants.Create","text":"Create <: QSym\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator creation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Transition","category":"page"},{"location":"api/#QuantumCumulants.Transition","page":"API","title":"QuantumCumulants.Transition","text":"Transition <: QSym\nTransition(h::NLevelSpace,name::Symbol,i,j)\n\nFundamental operator defining a transition from level j to level i on a NLevelSpace. The notation corresponds to Dirac notation, i.e. the above is equivalent to |i⟩⟨j|.\n\nExamples\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nℋ(a)\n\njulia> σ = Transition(ha,:σ,:g,:e)\nσge\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Meanfield","page":"API","title":"Mean field","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"meanfield","category":"page"},{"location":"api/#QuantumCumulants.meanfield","page":"API","title":"QuantumCumulants.meanfield","text":"meanfield(ops::Vector,H::QNumber)\nmeanfield(op::QNumber,H::QNumber)\n\nmeanfield(ops::Vector,H::QNumber,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\nmeanfield(op::QNumber,H::QNumber,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\n\nCompute the set of equations for the operators in ops under the Hamiltonian H and with loss operators contained in J. The resulting equation is equivalent to the Quantum-Langevin equation where noise is neglected.\n\nArguments\n\n*ops::Vector: The operators of which the equations are to be computed. *H::QNumber: The Hamiltonian describing the reversible dynamics of the     system. *J::Vector{<:QNumber}: A vector containing the collapse operators of     the system. A term of the form     sum_i J_i^dagger O J_i - frac12left(J_i^dagger J_i O + OJ_i^dagger J_iright)     is added to the Heisenberg equation.\n\nOptional argumentes\n\n*Jdagger::Vector=adjoint.(J): Vector containing the hermitian conjugates of     the collapse operators. *rates=ones(length(J)): Decay rates corresponding to the collapse operators in J. *multithread=false: Specify whether the derivation of equations for all operators in ops     should be multithreaded using Threads.@threads. *simplify=true: Specify whether the derived equations should be simplified. *order=nothing: Specify to which order a cumulant_expansion is performed.     If nothing, this step is skipped. *mix_choice=maximum: If the provided order is a Vector, mix_choice determines     which order to prefer on terms that act on multiple Hilbert spaces. *iv=SymbolicUtils.Sym{Real}(:t): The independent variable (time parameter) of the system.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"commutator","category":"page"},{"location":"api/#QuantumCumulants.commutator","page":"API","title":"QuantumCumulants.commutator","text":"commutator(a,b)\n\nComputes the commutator a*b - b*a.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"acts_on","category":"page"},{"location":"api/#QuantumCumulants.acts_on","page":"API","title":"QuantumCumulants.acts_on","text":"acts_on(op)\n\nShows on which Hilbert space op acts. For QSym types, this returns an Integer, whereas for a Term it returns a Vector{Int} whose entries specify all subspaces on which the expression acts.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"MeanfieldEquations","category":"page"},{"location":"api/#QuantumCumulants.MeanfieldEquations","page":"API","title":"QuantumCumulants.MeanfieldEquations","text":"MeanfieldEquations <: AbstractMeanfieldEquations\n\nType defining a system of differential equations, where lhs is a vector of derivatives and rhs is a vector of expressions. In addition, it keeps track of the Hamiltonian, the collapse operators and the corresponding decay rates of the system.\n\nFields\n\n*equations: Vector of the differential equations of averages. *operator_equations: Vector of the operator differential equations. *states: Vector containing the averages on the left-hand-side of the equations. *operators: Vector containing the operators on the left-hand-side of the equations. *hamiltonian: Operator defining the system Hamiltonian. *jumps: Vector of operators specifying the decay processes. *rates: Decay rates corresponding to the jumps. *iv: The independent variable (time parameter) of the system. *varmap: Vector of pairs that map the averages to time-dependent variables.     That format is necessary for ModelingToolkit functionality. *order: The order at which the cumulant_expansion has been performed.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Symbolic-numbers","page":"API","title":"Symbolic Numbers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CNumber","category":"page"},{"location":"api/#QuantumCumulants.CNumber","page":"API","title":"QuantumCumulants.CNumber","text":"CNumber <: Number\n\nAbstract type for all symbolic numbers, i.e. Parameter, average.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Parameter","category":"page"},{"location":"api/#QuantumCumulants.Parameter","page":"API","title":"QuantumCumulants.Parameter","text":"Parameter <: CNumber\n\nType used as symbolic type in a SymbolicUtils.Sym variable to represent a parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"cnumbers","category":"page"},{"location":"api/#QuantumCumulants.cnumbers","page":"API","title":"QuantumCumulants.cnumbers","text":"cnumbers(symbols::Symbol...)\ncnumbers(s::String)\n\nCreate symbolic cnumbers.\n\nExpamples\n\njulia> ps = cnumbers(:a, :b)\n(a, b)\n\njulia> cnumbers(\"a b\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"@cnumbers","category":"page"},{"location":"api/#QuantumCumulants.@cnumbers","page":"API","title":"QuantumCumulants.@cnumbers","text":"@cnumbers(ps...)\n\nConvenience macro to quickly define symbolic cnumbers.\n\nExamples\n\njulia> @cnumbers ω κ\n(ω, κ)\n\n\n\n\n\n","category":"macro"},{"location":"api/#API:-Average","page":"API","title":"Average","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"average","category":"page"},{"location":"api/#QuantumCumulants.average","page":"API","title":"QuantumCumulants.average","text":"average(::QNumber)\naverage(::QNumber,order)\n\nCompute the average of an operator. If order is given, the cumulant_expansion up to that order is computed immediately.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"cumulant_expansion","category":"page"},{"location":"api/#QuantumCumulants.cumulant_expansion","page":"API","title":"QuantumCumulants.cumulant_expansion","text":"cumulant_expansion(avg, order::Int)\n\nFor an average of an operator, expand it in terms of moments up to order neglecting their joint cumulant.\n\nSee also: https://en.wikipedia.org/wiki/Cumulant#Joint_cumulants\n\nExamples\n\njulia> avg = average(a*b)\n⟨a*b⟩\n\njulia> cumulant_expansion(avg,1)\n(⟨a⟩*⟨b⟩)\n\njulia> avg = average(a*b*c)\n⟨a*b*c⟩\n\njulia> cumulant_expansion(avg,2)\n((⟨a*b⟩*⟨c⟩)+(⟨a*c⟩*⟨b⟩)+(⟨a⟩*⟨b*c⟩)+(-2*⟨a⟩*⟨b⟩*⟨c⟩))\n\nOptional arguments\n\n*simplify=true: Specify whether the result should be simplified. *kwargs...: Further keyword arguments being passed to simplification.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"cumulant","category":"page"},{"location":"api/#QuantumCumulants.cumulant","page":"API","title":"QuantumCumulants.cumulant","text":"cumulant(x,n=get_order(x);simplify=true,kwargs...)\n\nCompute the nth cumulant of x (either an operator or an average). The output is simplified when simplify=true. Further keyword arguments are passed on to simplification.\n\nExamples\n\njulia> cumulant(a)\n⟨a⟩\n\njulia> cumulant(a*b)\n(⟨a*b⟩+(-1*⟨a⟩*⟨b⟩))\n\njulia> cumulant(a*b,1)\n⟨a*b⟩\n\njulia> cumulant(a*b,3)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_order","category":"page"},{"location":"api/#QuantumCumulants.get_order","page":"API","title":"QuantumCumulants.get_order","text":"get_order(arg)\n\nCompute the order of a given argument. This is the order used to decide whether something should be expanded using a cumulant_expansion method.\n\nExamples\n\njulia> get_order(a)\n1\n\njulia> get_order(a*b)\n2\n\njulia> get_order(1)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-correlation","page":"API","title":"Correlation functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CorrelationFunction","category":"page"},{"location":"api/#QuantumCumulants.CorrelationFunction","page":"API","title":"QuantumCumulants.CorrelationFunction","text":"struct CorrelationFunction\n\nType representing the two-time first-order correlation function of two operators.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Spectrum","category":"page"},{"location":"api/#QuantumCumulants.Spectrum","page":"API","title":"QuantumCumulants.Spectrum","text":"struct Spectrum\n\nType representing the spectrum, i.e. the Fourier transform of a CorrelationFunction in steady state.\n\nTo actually compute the spectrum at a frequency ω, construct the type on top of a correlation function and call it with Spectrum(c)(ω,usteady,p0).\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"correlation_u0","category":"page"},{"location":"api/#QuantumCumulants.correlation_u0","page":"API","title":"QuantumCumulants.correlation_u0","text":"correlation_u0(c::CorrelationFunction, u_end)\n\nFind the vector containing the correct initial values when numerical solving the time evolution for the correlation function.\n\nSee also: CorrelationFunction correlation_p0\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"correlation_p0","category":"page"},{"location":"api/#QuantumCumulants.correlation_p0","page":"API","title":"QuantumCumulants.correlation_p0","text":"correlation_p0(c::CorrelationFunction, u_end, ps=Pair[])\n\nFind all occurring steady-state values and add them to a list of parameters to pass this to the ODEProblem.\n\nSee also: CorrelationFunction correlation_u0\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Utils","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"find_missing","category":"page"},{"location":"api/#QuantumCumulants.find_missing","page":"API","title":"QuantumCumulants.find_missing","text":"find_missing(me::MeanfieldEquations, vs_adj=nothing, get_adjoints=true)\n\nFind all averages on the right-hand-side of in me.equations that are not listed me.states. For a complete system this list is empty.\n\nOptional arguments\n\n*vs_adj: List of the complex conjugates of me.states. If set to nothing     the list is generated internally. *get_adjoints=true: Specify whether a complex conjugate of an average should be     explicitly listed as missing.\n\nsee also: complete, complete!\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"find_operators","category":"page"},{"location":"api/#QuantumCumulants.find_operators","page":"API","title":"QuantumCumulants.find_operators","text":"find_operators(::HilbertSpace, order; names=nothing)\n\nFind all operators that fully define a system up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"complete","category":"page"},{"location":"api/#QuantumCumulants.complete","page":"API","title":"QuantumCumulants.complete","text":"complete(de::MeanfieldEquations)\n\nFrom a set of differential equation of averages, find all averages that are missing and derive the corresponding equations of motion. Uses find_missing and meanfield to do so.\n\nOptional arguments\n\n*order=de.order: The order at which the cumulant_expansion is performed     on the newly derived equations. If nothing, the order is inferred from the     existing equations. *filter_func=nothing: Custom function that specifies whether some averages should     be ignored when completing a system. This works by calling filter!(filter_func, missed)     where missed is the vector resulting from find_missing. Occurrences     of averages for which filter_func returns false are substituted to 0. *kwargs...: Further keyword arguments are passed on to meanfield and     simplification.\n\nsee also: find_missing, meanfield\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"complete!","category":"page"},{"location":"api/#QuantumCumulants.complete!","page":"API","title":"QuantumCumulants.complete!","text":"complete!(de::MeanfieldEquations)\n\nIn-place version of complete\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"unique_ops","category":"page"},{"location":"api/#QuantumCumulants.unique_ops","page":"API","title":"QuantumCumulants.unique_ops","text":"unique_ops(ops)\n\nFor a given list of operators, return only unique ones taking into account their adjoints.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"unique_ops!","category":"page"},{"location":"api/#QuantumCumulants.unique_ops!","page":"API","title":"QuantumCumulants.unique_ops!","text":"unique_ops!(ops)\n\nIn-place version of unique_ops.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"fundamental_operators","category":"page"},{"location":"api/#QuantumCumulants.fundamental_operators","page":"API","title":"QuantumCumulants.fundamental_operators","text":"fundamental_operators(::HilbertSpace)\n\nReturn all fundamental operators for a given Hilbertspace. For example, a FockSpace only has one fundamental operator, Destroy.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"transition_superscript","category":"page"},{"location":"api/#QuantumCumulants.transition_superscript","page":"API","title":"QuantumCumulants.transition_superscript","text":"transition_superscript(::Bool)\n\nSpecify whether the indices in a Transition operator should be printed as superscript. Default is true. If set to false, the indices corresponding to the levels are printed as subscript.\n\n\n\n\n\n","category":"function"},{"location":"examples/optomechanical-cooling/#Optomechanical-Cooling","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"","category":"section"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"In this example, we show how to implement a cooling scheme based on radiation pressure coupling of light to a mechanical oscillator, such as a membrane. The oscillator is placed inside an optical cavity. The cavity is driven by a laser and the resulting radiation pressure of the cavity field effectively couples the photons in the cavity mode to the vibrational phonons of the mechanical oscillator mode. This model is based on the one studied in C. Genes, et. al., Phys. Rev. A 77, 033804 (2008), and the Hamiltonian reads","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"H = -hbarDelta a^dagger a + hbaromega_m b^dagger b + hbar Ga^dagger a left(b + b^daggerright) + hbar E left(a + a^daggerright)","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"where Delta = omega_ell - omega_c is the detuning between the driving laser (omega_ell) and the cavity (omega_c). The amplitude of the laser is denoted by E, the resonance frequency of the mechanical oscillator by omega_m, and the radiation pressure coupling is given by G. Additionally, photons leak out of the cavity at a rate kappa. We start by loading the needed packages and specifying the model.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"using QuantumCumulants\nusing OrdinaryDiffEq, ModelingToolkit\nusing Plots\n\n# Hilbertspace\nhc = FockSpace(:cavity)\nhm = FockSpace(:motion)\nh = hc ⊗ hm\n\n# Operators\n@qnumbers a::Destroy(h,1) b::Destroy(h,2)\n\n# Parameters\n@cnumbers Δ ωm E G κ\n\n# Hamiltonian\nH = -Δ*a'*a + ωm*b'*b + G*a'*a*(b + b') + E*(a + a')\n\n# Jump operators & rates\nJ = [a]\nrates = [κ]\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"We are specifically interested in the average number of photons langle a^dagger a rangle and phonons langle b^dagger b rangle. Thus we first derive the equations for these two averages. We restrict our description to a second order cumulant expansion.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"# Derive equations\nops = [a'*a, b'*b]\neqs = meanfield(ops,H,J;rates=rates,order=2)\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"beginalign\nfracddt langle a^dagger  arangle  = -1 i E langle a^daggerrangle  + 1 i E langle arangle  -10 kappa langle a^dagger  arangle  \nfracddt langle b^dagger  brangle  = -1 i G left( langle a^daggerrangle  langle a  b^daggerrangle  + langle b^daggerrangle  langle a^dagger  arangle  + langle arangle  langle a^dagger  b^daggerrangle  -2 langle a^daggerrangle  langle b^daggerrangle  langle arangle  right) + 1 i G left( langle a^daggerrangle  langle a  brangle  + langle arangle  langle a^dagger  brangle  + langle brangle  langle a^dagger  arangle  -2 langle a^daggerrangle  langle arangle  langle brangle  right)\nendalign","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"To get a closed set of equations we automatically complete the system.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"# Complete equations\neqs_completed = complete(eqs)\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"beginalign\nfracddt langle a^dagger  arangle  = -1 i E langle a^daggerrangle  + 1 i E langle arangle  -10 kappa langle a^dagger  arangle  \nfracddt langle b^dagger  brangle  = -1 i G left( langle a^daggerrangle  langle a  b^daggerrangle  + langle b^daggerrangle  langle a^dagger  arangle  + langle arangle  langle a^dagger  b^daggerrangle  -2 langle a^daggerrangle  langle b^daggerrangle  langle arangle  right) + 1 i G left( langle a^daggerrangle  langle a  brangle  + langle arangle  langle a^dagger  brangle  + langle brangle  langle a^dagger  arangle  -2 langle a^daggerrangle  langle arangle  langle brangle  right) \nfracddt langle a^daggerrangle  = 1 i E + G left( 1 i langle a^dagger  b^daggerrangle  + 1 i langle a^dagger  brangle  right) -1 i Delta langle a^daggerrangle  -05 kappa langle a^daggerrangle  \nfracddt langle a  b^daggerrangle  = G left( -2 i langle b^daggerrangle  langle a  b^daggerrangle  -1 i langle b^daggerrangle  langle a  brangle  -1 i langle arangle  langle b^dagger  b^daggerrangle  -1 i langle arangle  langle b^dagger  brangle  + 2 i langle arangle  langle b^daggerrangle ^2 -1 i langle brangle  langle a  b^daggerrangle  + 2 i langle b^daggerrangle  langle arangle  langle brangle  right) -1 i E langle b^daggerrangle  + 1 i G left( langle a^daggerrangle  langle a  arangle  -2 langle a^daggerrangle  langle arangle ^2 + 2 langle arangle  langle a^dagger  arangle  right) + 1 i Delta langle a  b^daggerrangle  -05 kappa langle a  b^daggerrangle  + 1 i omegam langle a  b^daggerrangle  \nfracddt langle b^daggerrangle  = 1 i G langle a^dagger  arangle  + 1 i omegam langle b^daggerrangle  \nfracddt langle a^dagger  b^daggerrangle  = G left( 1 i langle a^daggerrangle  + 2 i langle a^daggerrangle  langle a^dagger  arangle  + 1 i langle a^daggerrangle  langle b^dagger  b^daggerrangle  + 1 i langle a^daggerrangle  langle b^dagger  brangle  -2 i langle a^daggerrangle  langle b^daggerrangle ^2 + 2 i langle b^daggerrangle  langle a^dagger  b^daggerrangle  + 1 i langle b^daggerrangle  langle a^dagger  brangle  + 1 i langle arangle  langle a^dagger  a^daggerrangle  -2 i langle arangle  langle a^daggerrangle ^2 + 1 i langle brangle  langle a^dagger  b^daggerrangle  -2 i langle a^daggerrangle  langle b^daggerrangle  langle brangle  right) + 1 i E langle b^daggerrangle  -1 i Delta langle a^dagger  b^daggerrangle  -05 kappa langle a^dagger  b^daggerrangle  + 1 i omegam langle a^dagger  b^daggerrangle  \nfracddt langle b^dagger  b^daggerrangle  = 2 i G left( langle a^daggerrangle  langle a  b^daggerrangle  + langle b^daggerrangle  langle a^dagger  arangle  + langle arangle  langle a^dagger  b^daggerrangle  -2 langle a^daggerrangle  langle b^daggerrangle  langle arangle  right) + 2 i omegam langle b^dagger  b^daggerrangle  \nfracddt langle a  arangle  = G left( -2 i langle b^daggerrangle  langle a  arangle  + 4 i langle b^daggerrangle  langle arangle ^2 -4 i langle arangle  langle a  b^daggerrangle  -4 i langle arangle  langle a  brangle  -2 i langle brangle  langle a  arangle  + 4 i langle brangle  langle arangle ^2 right) -2 i E langle arangle  + 2 i Delta langle a  arangle  -10 kappa langle a  arangle\nendalign","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"To calculate the dynamics we create a system of ordinary differential equations, which can be used by DifferentialEquations.jl.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"sys = ODESystem(eqs_completed)\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"Finally we need to define the numerical parameters and the initial state of the system. We will consider the membrane at room temperature. Its vibrational mode is in a thermal state with an average number of phonons that can be estimated from k_B T = n_mathrmvibhbar omega_m. If the resonator has a resonance frequency of omega_m = 10mathrmMHz, then the number of phonons at room temperature (Tapprox 300K) is approximately n_mathrmvib approx 4times 10^6.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"# Initial state\nu0 = zeros(ComplexF64, length(eqs_completed))\nu0[2] = 4e6 # Initial number of phonons\n# System parameters\np0 = (Δ=>-10, ωm=>1, E=>200, G=>0.0125, κ=>20)\nprob = ODEProblem(sys,u0,(0.0,60000),p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"# Plot results\nt = real.(sol.t)\nphonons = real.(sol[b'b])\nT = 7.5e-5*phonons\nphotons = real.(sol[a'a])\n\np1 = plot(t, T, ylabel=\"T in K\", legend=false)\np2 = plot(t, photons, xlabel=\"t⋅ωm\", ylabel=\"⟨a⁺a⟩\", legend=false)\nplot(p1, p2, layout=(2,1), size=(650,400))\nsavefig(\"opto_cooling.svg\") # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"(Image: svg)","category":"page"},{"location":"theory/#theory","page":"Theoretical background","title":"Theoretical background","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"In this section, we will describe the fundamental theoretical concepts used within QuantumCumulants.jl.","category":"page"},{"location":"theory/#The-Quantum-Langevin-equation","page":"Theoretical background","title":"The Quantum Langevin equation","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"In an open quantum system, the equation of motion of an operator mathcalO is given by the Quantum Langevin equation. Let a system be described by the Hamiltonian H, and subject to a number of decay channels with the rates gamma_n and corresponding damping operators c_n. The equation for mathcalO is then given by","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"dotmathcalO = fracihbarHmathcalO + sum_n fracgamma_n2left(2c_n^dagger mathcalOc_n - c_n^dagger c_n mathcalO - mathcalOc_n^dagger c_nright) + textnoise","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Note that we did not specify the noise term, since under the assumption of white noise it does not contribute to averages. We can therefore neglect it in the following. The above equation is an operator equation, i.e. solving it directly has the same numerical complexity as solving a stochastic master equation. However, averaging over the above we obtain a c-number equation, which, in principle, is easy to solve. This is the basic idea in QuantumCumulants.jl: derive equations of motions of operators, and then convert them to easily solvable c-number differential equations. However, as we will see, there is another crucial step required, namely the cumulant expansion.","category":"page"},{"location":"theory/#A-brief-example","page":"Theoretical background","title":"A brief example","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"To illustrate this, let us consider a simple example, the Jaynes-Cummings model. This model describes a two-level atom that is coupled to an optical resonator. The Hamiltonian reads","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"H_mathrmJC = hbarDelta a^dagger a + hbar gleft(a^dagger sigma^ge + asigma^egright)","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"where Delta = omega_mathrmc - omega_mathrma is the detuning between the cavity resonance frequency omega_mathrmc and the atomic transition frequency omega_mathrma. The frequency g describes the strength of the dipole-coupling between the atom and the cavity. The operators a and a^dagger are the photonic annihilation and creation operators of the cavity mode. The atom has a ground state grangle and an excited state erangle, and its dynamics are described by the projection operators sigma^ij = iranglelangle j, where ij inge. For simplicity, we will here assume that the system is closed, i.e. it is not subject to decay, such that the operator dynamics are described by the Heisenberg equation (i.e. only the first part of the Quantum Langevin equation).","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Now, say we want to compute the field dynamics, i.e. we want to derive the equation for dota. Using the fundamental relations","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"aa^dagger = 1 quad sigma^ijsigma^kl = delta_jksigma^il","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"we derive","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\ndota = iDelta a - ig sigma^ge\n\ndotsigma^ge = ig asigma^ee\n\ndotsigma^ee = igleft(a^daggersigma^ge - asigma^egright)\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Since dota couples to sigma^ge, and dotsigma^ge to sigma^ee, we needed to derive a total of three equations to arrive at a complete set. In order to make them easy to handle, we average over the above system of equations to obtain c-number equations. We find","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\nlangledotarangle = iDelta langle arangle - ig langlesigma^gerangle\n\nlangledotsigma^gerangle = ig langle asigma^eerangle\n\nlangle dotsigma^eerangle = -2gtextImleftlangle a^daggersigma^gerangleright\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"The above system can, however, not be solved since we encounter terms such as langle asigma^eerangle, meaning the set of equations is incomplete, since in general langle asigma^eerangle neq langle aranglelanglesigma^eerangle. A naive approach would be to derive the equations for all missing average values. Unfortunately, these equations will couple to averages of ever longer operator products. A complete set of equations can therefore not be derived, since it would consist of infinitely many equations.","category":"page"},{"location":"theory/#Cumulant-expansion","page":"Theoretical background","title":"Cumulant expansion","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"To obtain a closed set of c-number equations, we truncate the in principle infinite set of equations at a certain order. By order, we essentially mean the length of an operator product, e.g. langle a rangle is of order 1, langle a^dagger a rangle and langle a^dagger sigma^gerangle are of the order 2. The order of a system determines its size and the accuracy of the underlying approximation. It is therefore an essential concept in QuantumCumulants.jl.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"The way in which we truncate a system of equations is called the generalized cumulant expansion (see also R. Kubo, Generalized Cumulant Expansion Method). The joint cumulant, which we denote by langlecdotrangle_c of a product of operators X_1 X_2  X_n of order n is given by","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"langle X_1 X_2  X_n rangle_c = sum_p in P(mathcalI) left(p - 1right) (-1)^p-1 prod_B in p langle prod_iin B X_irangle","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"In the above, mathcalI=12n, P(mathcalI) is the set of all partitions of mathcalI, p denotes the length of the partition p, and B runs over the blocks of each partition. For example, in the case of n=3 we find","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\nlangle X_1X_2X_3 rangle_c = langle X_1X_2X_3rangle  -langle X_1X_2ranglelangle X_3rangle - langle X_1X_3ranglelangle X_2rangle\n\n- langle X_1ranglelangle X_2X_3rangle + 2langle X_1ranglelangle X_2ranglelangle X_3rangle\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Note that the joint cumulant of order n is proportional to averages of order leq n. Furthermore, the average of order n occurs precisely once on the right-hand-side.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"The joint cumulant can be thought of as a general measure for the correlation between operators. According to Theorem I from R. Kubo, Generalized Cumulant Expansion Method, the joint cumulant is zero iff any of the operators is statistically independent of the others. The key assumption we are making is to essentially invert this statement: instead of computing the joint cumulant of a given order to see if it is zero, we assume that it is. Since the average value of the same order occurs only once in the definition of the joint cumulant, we may invert the relation to express the average in terms of lower-order terms; i.e., if we assume langle X_1 X_2  X_nrangle_c = 0, we can write","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"langle X_1X_2X_n rangle = sum_p in P(mathcalI)backslash mathcalI left(p - 1right) (-1)^p prod_B in p langle prod_iin B X_irangle","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"where now P(mathcalI)backslashmathcalI is the set of all partitions of mathcalI that does not contain mathcalI itself. In the example of n=3, we have","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"langle X_1X_2X_3rangle   = langle X_1X_2ranglelangle X_3rangle + langle X_1X_3ranglelangle X_2rangle + langle X_1ranglelangle X_2X_3rangle - 2langle X_1ranglelangle X_2ranglelangle X_3rangle","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"In other words, by neglecting the cumulant of order n we can express all averages of order n in terms of averages of order n-1 and below. By applying this expansion recursively, we can reduce the order of any term to one as low as we choose.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Returning to the example of the Jaynes-Cummings Hamiltonian, we could use the cumulant expansion to express all the terms of order 2 in first order only. This is also called the mean-field approach which neglects all quantum correlations of a system. For the Jaynes-Cummings model, we would then have","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\nlangledotarangle = iDelta langle arangle - ig langlesigma^gerangle\n\nlangledotsigma^gerangle = ig langle aranglelanglesigma^eerangle\n\nlangle dotsigma^eerangle = -2gtextImleftlangle a^daggerranglelanglesigma^gerangleright\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Now this system of equations forms a closed set, and can readily be implemented and solved numerically. Of course, solving the Jaynes-Cummings model in mean field is not very interesting. We could make it more interesting by doing a second-order cumulant expansion. However, this would involve deriving the equations for all the second-order averages, which is quite tedious. So instead, let's just be lazy and use QuantumCumulants.jl to do it,","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\n\n# Symbolic parameters\n@cnumbers Δ g\n\n# Hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf⊗ha\n\n# Operators\n@qnumbers a::Destroy(h) σ::Transition(h)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*σ(:g,:e) + a*σ(:e,:g))\n\n# List of first and second-order operators\nops = find_operators(h,2)\n\n# Derive equations\nmeanfield(ops,H;order=2) # expand to second order\nnothing # hide","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\nfracddt langle arangle = -10 i langle arangle Delta -10 i langle sigma^gerangle g\n\nfracddt langle sigma^gerangle = -10 i langle arangle g + 20 i g langle a sigma^eerangle\n\nfracddt langle sigma^eerangle = 10 i g langle a^dagger sigma^gerangle -10 i g langle a sigma^egrangle\n\nfracddt langle a sigma^gerangle = 20 i left( langle sigma^eerangle langle a arangle + 2 langle arangle langle a sigma^eerangle -2 langle sigma^eerangle langle arangle ^2 right) g -10 i g langle a arangle -10 i Delta langle a sigma^gerangle\n\nfracddt langle a sigma^eerangle = -10 i left( langle sigma^egrangle langle a arangle + 2 langle arangle langle a sigma^egrangle -2 langle sigma^egrangle langle arangle ^2 right) g + 10 i left( langle a^daggerrangle langle a sigma^gerangle + langle arangle langle a^dagger sigma^gerangle + langle sigma^gerangle langle a^dagger arangle -2 langle a^daggerrangle langle arangle langle sigma^gerangle right) g -10 i Delta langle a sigma^eerangle\n\nfracddt langle a^dagger arangle = -10 i g langle a^dagger sigma^gerangle + 10 i g langle a sigma^egrangle\n\nfracddt langle a sigma^egrangle = -10 i langle sigma^eerangle g -20 i left( langle a^daggerrangle langle a sigma^eerangle + langle arangle langle a^dagger sigma^eerangle + langle sigma^eerangle langle a^dagger arangle -2 langle a^daggerrangle langle arangle langle sigma^eerangle right) g + 10 i g langle a^dagger arangle -10 i Delta langle a sigma^egrangle\n\nfracddt langle a arangle = -20 i g langle a sigma^gerangle -20 i Delta langle a arangle\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Note, that QuantumCumulants.jl automatizes the derivation of equations and the cumulant expansion. Furthermore, the final step of numerical implementation is handled by converting to the ModelingToolkit.jl framework.","category":"page"},{"location":"theory/#References","page":"Theoretical background","title":"References","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"R. Kubo. \"Generalized cumulant expansion method.\" Journal of the Physical Society of Japan 17.7 (1962): 1100-1120. URL: https://www.jstage.jst.go.jp/article/jpsj1946/17/7/1771100/_article/-char/ja/","category":"page"},{"location":"examples/many-atom-laser/#Many-atom-laser","page":"Many-atom laser","title":"Many-atom laser","text":"","category":"section"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"This example describes a second order laser system consisting of N three-level atoms coupled to a single mode cavity. An auxiliary state 3rangle, which quickly decays into the upper lasing state 2rangle, is coherently pumped to achieve population inversion on the lasing transition 1rangle leftrightarrow 2rangle. The Hamiltonian of this system is given by","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"H = -Delta_c a^dagger a  - sum_i=1^N left Delta_3^i sigma_i^33  + g_i (a^dagger sigma_i^12 + asigma_i^21) + Omega_i (sigma_i^31 + sigma_i^13) right","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Including dissipative processes as, e.g. the atomic decay or photon losses through the cavity mirrors, makes it an open quantum system. In the Schrödinger picture we would compute the dynamics of such open quantum systems with a density matrix rho according to a master equation (see e.g. https://docs.qojulia.org/),","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"fracddt rho = - fracihbar left H rho right + mathcalLrho","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"with mathcalLrho = fracgamma2 (2 J rho J^dagger - J^dagger J rho - rho J^dagger J) the Liouvillian superoperator in standard Lindblad form for a dissipative process with jump operator J and rate R.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"With QuantumCumulants.jl we describe the system dynamics with averages, which are deduced from the operator equations of motion in the Heisenberg picture. In the Heisenberg picture open systems are described by the quantum Langevin equation. Assuming white noise, we can omit the stochastic terms of the quantum Langevin equation when computing averages. Thus we get the following equation for the time evolution of a system operator average langle O rangle (if O is not explicitly time dependent):","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"fracddt langle O rangle = fracihbar left H O right + barmathcalLO","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"The superoperator barmathcalLO is similar to the Lindblad term in the Schrödinger picture, except that J and J^dagger are swapped in the first term, i.e. barmathcalLO = fracgamma2 (2 J^dagger O J - J^dagger J O - O J^dagger J), for a dissipative process with jump operator J and rate R.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"For our system we have four different dissipative processes with the jump operators a, sigma^12_i, sigma^13_i and sigma^23_i, and the corresponding decay rates kappa, Gamma^i_12, Gamma^i_13 and Gamma^i_23, respectively.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"We start by loading the needed packages.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"using QuantumCumulants\nusing ModelingToolkit, OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Then we define the symbolic parameters of the system, the Hilbertspace and the necessary operators. We define an atomic transition operator function sigma(ijk) for the transition from j rangle to i rangle of atom k. Since we only have one FockSpace we do not need to specify the Hilbertspace on which the Destroy operator acts. For the different atomic transitions, however, we need to specify this, since there is more than one NLevelSpace. This information is stored in the .aon field of each operator.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# Parameters\nN = 2 #number of atoms\nκ, g, Γ23, Γ13, Γ12, Ω, Δc, Δ3 = cnumbers(\"κ g Γ_{23} Γ_{13} Γ_{12} Ω Δ_c Δ_3\")\n\n# Hilbertspace\nhf = FockSpace(:cavity)\nha = ⊗([NLevelSpace(Symbol(:atom,i),3) for i=1:N]...)\nh = hf ⊗ ha\n\n# Operators\na = Destroy(h,:a)\nσ(i,j,k) = Transition(h,Symbol(\"σ_{$k}\"),i,j,k+1)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Now we create the Hamiltonian and the jumps with the corresponding rates of our laser system. We assume here that all atoms are identical.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# Hamiltonian\nH = -Δc*a'a + sum(g*(a'*σ(1,2,i) + a*σ(2,1,i)) for i=1:N) + sum(Ω*(σ(3,1,i) + σ(1,3,i)) for i=1:N) - sum(Δ3*σ(3,3,i) for i=1:N)\n\n# Jumps\nJ = [a;[σ(1,2,i) for i=1:N];[σ(1,3,i) for i=1:N];[σ(2,3,i) for i=1:N]]\n\n# Rates\nrates = [κ;[Γ12 for i=1:N];[Γ13 for i=1:N];[Γ23 for i=1:N]]\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Later we will complete the system automatically, which has the disadvantage that the equations are not ordered. Therefore we define a list of interesting operators, which we want to use later. Note that at least one operator(-product) is needed. We derive the equations for these operators, average them, and automatically complete the system of equations.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# list of operators\nops = [a'a, σ(2,2,1), σ(3,3,1)]\n\neqs = meanfield(ops,H,J; rates=rates)\neqs_expanded = cumulant_expansion(eqs,2) #second order average\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"beginalign\nfracddt langle a^dagger  arangle  = -10 i g left( langle a^dagger  sigma_1^12rangle  + langle a^dagger  sigma_2^12rangle  right) + 10 i g left( langle a  sigma_1^21rangle  + langle a  sigma_2^21rangle  right) -10 kappa langle a^dagger  arangle  \nfracddt langle sigma_1^22rangle  = langle sigma_1^33rangle  Gamma_23 -10 langle sigma_1^22rangle  Gamma_12 + 10 i g langle a^dagger  sigma_1^12rangle  -10 i g langle a  sigma_1^21rangle  \nfracddt langle sigma_1^33rangle  = -10 i langle sigma_1^31rangle  Omega + 10 i langle sigma_1^13rangle  Omega -10 langle sigma_1^33rangle  left( Gamma_13 + Gamma_23 right)\nendalign","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"me_comp = complete(eqs_expanded) #automatically complete the system\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"To calculate the time evolution we create a Julia function which can be used by DifferentialEquations.jl to solve the set of ordinary differential equations.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# Build an ODESystem out of the MeanfieldEquations\nsys = ODESystem(me_comp)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Finally we compute the time evolution after defining an initial state and numerical values for the parameters.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# initial state\nu0 = zeros(ComplexF64, length(me_comp))\n\nΓ12n = 1.0\nΓ23n = 20Γ12n\nΓ13n = 2Γ12n\nΩn = 5Γ13n\ngn = 2Γ12n\nΔcn = 0.0\nΔ3n = 0.0\nκn = 0.5Γ12n\n\n# list of parameters\nps = (g, Γ23, Γ13, Γ12, Ω, Δc, Δ3, κ)\np0 = ps .=> (gn, Γ23n, Γ13n, Γ12n, Ωn, Δcn, Δ3n, κn)\ntend = 10.0/κn\n\nprob = ODEProblem(sys,u0,(0.0,tend),p0)\nsol = solve(prob, Tsit5(), reltol=1e-8, abstol=1e-8)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"We plot the average photon number and the population inversion of the lasing transition.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"n_t = real.(sol[average(a'*a)])\nσ22m11_t = real.(2*sol[σ(2,2,1)] .+ sol[σ(3,3,1)] .-1 ) #σ11 + σ22 + σ33 = 𝟙\n\n# Plot\np1 = plot(sol.t, n_t, xlabel=\"tΓ₁₂\", ylabel=\"⟨a⁺a⟩\", legend = false)\np2 = plot(sol.t, σ22m11_t, xlabel=\"tΓ₁₂\", ylabel=\"⟨σ22⟩ - ⟨σ11⟩\", legend = false)\nplot(p1, p2, layout=(1,2), size=(800,300))\nsavefig(\"3-level-laser.svg\") # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"(Image: )","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumCumulants.jl offers a practical approach to the application of the generalized cumulant expansion method in Quantum Optics: operators are often represented by matrices on a Hilbert space, where a suitable basis has been chosen. These matrices can quickly become so large that they can no longer be stored. On a more abstract level, however, operators form a noncommutative alebgra that follows fundamental commutation relations. This is where QuantumCumulants.jl comes in. The basic working principle boils down to the following steps:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The model (Hamiltonian) is specified.\nEquations of motion for average values are derived. This is done by using the fundamental commutation relations of operators. The resulting equations are stored as symbolic equations using the Symbolics.jl framework, which is also used for any additional simplification and rewriting.\nThen follows the key step: the equations of motion the averages are truncated at a specified order neglecting higher-order quantum correlations using the generalized cumulant expansion method. This results in a closed set of c-number ordinary differential equations.\nFinally, the symbolic system of equations can be turned into an ODESystem of the ModelingToolkit.jl framework which bridges the gap from symbolics to numerics. This makes it straightforward to obtain a solution of the time dynamics of a system within the  DifferentialEquations.jl ecosystem.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumCumulants.jl is a registered Julia package and can be installed using the package manager:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"|pkg> add QuantumCumulants","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For a full list of functions, check out the API.","category":"page"},{"location":"implementation/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Let's take a closer look at each step involved from defining a system to arriving at a numerical solution of the underlying time dynamics.","category":"page"},{"location":"implementation/#Hilbert-spaces","page":"Implementation","title":"Hilbert spaces","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The first step in treating a system with QuantumCumulants.jl is to specify the Hilbert space on which the system is defined. There are two types of Hilbert spaces implemented, namely FockSpace and NLevelSpace. The first describes systems whose operators follow the fundamental bosonic commutation relations (such as the quantum harmonic oscillator), whereas the latter describes systems consisting of a finite number of energy levels with an arbitrary energy difference in between (such as atoms).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"A FockSpace simply needs a name in order to be defined:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nhf = FockSpace(:fock1)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"NLevelSpace requires a name as well as labels for the energy levels. For example","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_atom = NLevelSpace(:atom, (:g,:e))\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"defines an NLevelSpace with the name :atom and the two levels labeled by :g and :e, respectively. Note that the levels can be labeled by (almost) anything. For example, NLevelSpace(:two_level, (1,2)) would define a Hilbert space describing a system with the two discrete energy levels labeled by 1 and 2. Specifically for numbers, there is also the short-hand method to write NLevelSpace(:five_level, 5) which creates a system with levels 1:5. Note that by default the first level in the list of all levels is designated as the ground state. This can be changed by specifying the ground state explicitly as a third argument to NLevelSpace, e.g. NLevelSpace(:four_level, 4, 2) would designate the state 2 as the ground state. The ground state projector will be eliminated during simplification (see below).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Composite systems are generally described by a ProductSpace, i.e. a Hilbert space that consists of multiple subspaces. Each subspace is either a FockSpace or an NLevelSpace. They can be created using the tensor function or the unicode symbol ⊗ [\\otimes]. For example","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_prod1 = tensor(hf, h_atom)\nh_prod2 = tensor(h_prod1, NLevelSpace(:three_level, 3))\nh_prod3 = tensor(hf, h_atom, NLevelSpace(:three_level, 3)) # == h_prod2\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"creates two product spaces. The first, h_prod1, consists of the previously defined FockSpace(:fock1) and NLevelSpace(:atom, (:g,:e)). The second one, h_prod2, adds in another NLevelSpace(:three_level, 3). In principle arbitrarily many systems can be combined this way.","category":"page"},{"location":"implementation/#Operators-(a.k.a.-*q*-numbers)","page":"Implementation","title":"Operators (a.k.a. q-numbers)","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Once the Hilbert space of the system has been defined, we can proceed by defining operators, or q-numbers, on them. They are the fundamental building blocks of symbolic expressions in QuantumCumulants.jl. Again, there are essentially two kinds of operators implemented: the quantum harmonic destruction operator Destroy which acts on a FockSpace, as well as a Transition operator which describes a transition between any two levels on an NLevelSpace. These operators can only be defined on the corresponding Hilbert spaces. Note that there is no intrinsic reason that prevents us from implementing more types of operators (see below), there was simply no need to do that so far.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Here are a few examples:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nhf = FockSpace(:fock)\na = Destroy(hf, :a)\n\nh_atom = NLevelSpace(:atom,(:g,:e))\nσge = Transition(h_atom, :σ, :g, :e)\nσ = Transition(h_atom, :σ)\n@assert isequal(σge, σ(:g,:e)) # true\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"As you can see, the destruction operator Destroy is created on a FockSpace and given a name. The transition operator, however, additionally requires you to specify the levels between which it describes the transition. Defining a transition without levels specified creates a callable instance which needs to be called with valid level labels before one can actually use it in any algebraic expressions. Note that in Bra-Ket notation, the transition operator Transition(h, i, j) is simply irangle langle j. Also, the bosonic creation operator is simply given by the adjoint of Destroy.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"These fundamental operators are all of subtypes of QSym, and constitute the basic symbolic building blocks for the noncommutative algebra used in QuantumCumulants.jl. They can be combined using standard algebraic functions.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"ex_fock = 0.1*a'*a\nex_trans = im*(σ(:g,:e) - σ(:e,:g))\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that only operators that are defined on the same Hilbert space can be algebraically combined. The resulting expressions are stored as QTerm types.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"In composite systems, we also need to specify on which subsystem the respective operator acts. This information is important as operators acting on different subsystems commute with one another, but operators acting on the same one do not. When multiplying together operators in a composite systems, they are automatically ordered according to the order of Hilbert spaces. It's specified by an additional argument when creating operators.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2)\na = Destroy(h_prod,:a,1)\nb = Destroy(h_prod,:b,2)\na*b # a*b\nb*a # a*b\na'*b*a # a'*a*b\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"If a subspace occurs only once in a ProductSpace, the choice on which an operator acts is unique and can therefore be omitted on construction.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2) ⊗ NLevelSpace(:atom,(:g,:e))\nσ = Transition(h_prod, :σ) # no need to specify acts_on\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For convenience, there is also a macro that can be used to construct operators:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h = FockSpace(:fock) ⊗ NLevelSpace(:two_level, 2)\n@qnumbers a::Destroy(h) σ::Transition(h)\nex = a'*σ(1,2) + a*σ(2,1)\nnothing # hide","category":"page"},{"location":"implementation/#Symbolic-parameters-(a.k.a.-*c*-numbers)","page":"Implementation","title":"Symbolic parameters (a.k.a. c-numbers)","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Commutative numbers (c-numbers) are represented by SymbolicUtils.Sym from the SymbolicUtils.jl package and a custom subtype to Number called CNumber. They are generally assumed to be complex numbers and can be defined with the cnumbers function or the corresponding macro @cnumbers. You can use them together with q-numbers to build symbolic expressions describing the Hamiltonian, e.g.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nh = FockSpace(:fock)\n@cnumbers ω η\n@qnumbers a::Destroy(h)\nH = ω*a'*a + η*(a + a')\nnothing # hide","category":"page"},{"location":"implementation/#Operator-expressions-and-commutation-relations","page":"Implementation","title":"Operator expressions and commutation relations","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The equations of motion of q-numbers are determined by evaluating commutators. This can be done by using fundamental commutation relations, which are immediately applied whenever operators are combined in an algebraic expression.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For the quantum harmonic oscillator destruction operator a, we have the canonical commutator","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"aa^dagger = 1","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Within the framework, we choose normal ordering, which surmounts to the rewriting rule","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"a a^dagger Rightarrow a^dagger a +1","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For transition operators sigma^ij denoting a transition from level j to level i, on the other hand, we have a rule for products,","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"sigma^ijsigma^kl Rightarrow delta_jksigma^il","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"which is implemented as rewriting rule just so. Additionally, we use the fact that in a system with levels 1n","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"sum_j=1^n sigma^jj = 1","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"in order to eliminate the projector on the ground state. This reduces the amount of equations required for each NLevelSpace by 1. Note that, as mentioned before, the ground state is by default chosen to be the first (but this can be changed). Hence, the default rewriting rule to eliminate the ground-state projector is","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"sigma^11 Rightarrow 1 - sum_j=2^n sigma^jj","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Any expression involving operators is stored as a QTerm type. The expression trees are structured such that the application of commutation relations can be done efficiently. There are two concrete subtypes of QTerm, namely QMul representing a multiplication and QAdd representing an addition. Methods of multiplication and addition are implemented such that QSym < QMul < QAdd, i.e. a multiplication can only consist of numbers and fundamental operators (it cannot contain another multiplication or addition) and QAdd is always at the highest level possibly containing numbers, QSyms and QMuls (but no other QAdds). This makes it easy and efficient to recurse through the expression tree and find pairs of operators that should be rewritten according to some commutation relation.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that only simplification using commutation relations is implemented directly in QuantumCumulants.jl. For any other simplification routines, operators are averaged (without applying a cumulant expansion) which makes them numbers. Those numbers are stored as expressions in SymbolicUtils.jl and simplified according to standard simplification rules. Afterwards, they can be converted back into QTerm expressions.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Here's a short example:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nh = FockSpace(:fock)\n@qnumbers a::Destroy(h)\na*a' # returns a'*a + 1\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"In order to derive equations of motion, you need to specify a Hamiltonian and the operator (or a list of operators) of which you want to derive the Heisenberg equations and pass them to meanfield, which stores both the operator as well as the average equations. In the end, we only want to work with averages.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\n@cnumbers ω η\nH = ω*a'*a + η*(a + a') # Driven cavity Hamiltonian\nme = meanfield([a, a'*a], H)","category":"page"},{"location":"implementation/#Cumulant-expansion","page":"Implementation","title":"Cumulant expansion","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Averaging (using average) and the cumulant_expansion are essential to convert the system of q-number equations to c-number equations. Averaging alone converts any operator product to a c-number, yet you will not arrive at a closed set of equations without truncating at a specific order. An average is stored as a symbolic expression. Specifically, the average of an operator op is internally represented by SymbolicUtils.Term{AvgSym}(sym_average, [op]).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The order of an average is given by the number of constituents in the product. For example","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nh = FockSpace(:fock)\n@qnumbers a::Destroy(h)\n\navg1 = average(a)\nget_order(avg1) # 1\n\navg2 = average(a'*a)\nget_order(avg2) # 2\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The cumulant expansion can then be used to express any average by averages up to a specified order (see also the theory section):","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"cumulant_expansion(avg2, 1)\naverage(a'*a, 1) # short-hand for cumulant_expansion(average(a'*a), 1)\nnothing #hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"When deriving the equations of motion using the meanfield function, the cumulant_expansion is immediately applied if you specify an order, e.g meafield(ops,H;order=2). Before you can actually solve the system of equations, you need to ensure that it is complete, i.e. there are no averages missing. This can be checked with find_missing. Alternatively, you can automatically complete a system of equations using the complete function which will internally use find_missing to look for missing averages and derive equations for those.","category":"page"},{"location":"implementation/#Numerical-solution","page":"Implementation","title":"Numerical solution","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Finally, in order to actually solve a system of equations, we need to convert a set of equations to an ODESystem, which represents a symbolic set of ordinary differential equations. ODESystems are part of the ModelingToolkit.jl framework, which allows for generating fast numerical functions that can be directly used in the OrdinaryDiffEq.jl package. On top of that, ModelingToolkit.jl also offers a variety of additional functionality, such as the symbolic computation of Jacobians for better stability and performance.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"To obtain an ODESystem from MeanfieldEquations, you simply need to call the constructor:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using ModelingToolkit\nsys = ODESystem(me)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Finally, to obtain a numerical solution we can construct an ODEProblem and solve it.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using OrdinaryDiffEq\np0 = (ω => 1.0, η => 0.1)\nu0 = zeros(ComplexF64, length(me))\nprob = ODEProblem(sys,u0,(0.0,1.0),p0)\nsol = solve(prob, RK4())\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Now, the state of the system at each time-step is stored in sol.u. To access one specific solution, you can simply type e.g. sol[average(a)] to obtain the time evolution of the expectation value langle a rangle.","category":"page"},{"location":"implementation/#interface","page":"Implementation","title":"The q-number interface","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"While there are currently only two different Hilbert spaces and two different types of fundamental operators implemented, their implementations are somewhat generic. This means that one can implement custom operator types along with some commutation relations for rewriting. The requirements for that are:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Custom operator types need to be subtypes of QSym.\nBase.:*(::Operator1, ::Operator2): A multiplication method that rewrites according to a commutation relation has to be implemented.\nQuantumCumulants.ismergeable(::Operator1, ::Operator2) = true is required so pairs of Operator1 and Operator2 are detected in longer expressions and rewritten according to their commutation relation.\nOptional: custom Hilbert space type matching the new operators.","category":"page"},{"location":"implementation/#Example:-Harmonic-oscillator-quadratures","page":"Implementation","title":"Example: Harmonic oscillator quadratures","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"To illustrate, say we would like to implement the quantum harmonic oscillator in terms of the position operator x and the momentum operator p rather than the ladder operators. They fulfill the commutation relation","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"xp = i","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"and we will use it to rewrite occurrences of xp Rightarrow px + i. For simplicity, we will define them on a FockSpace instead of defining a custom Hilbert space as well.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\n\nstruct Position <: QSym\n    hilbert\n    name\n    aon\nend\n\nstruct Momentum <: QSym\n    hilbert\n    name\n    aon\nend","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that any subtype to QSym needs to have the three fields shown above. More fields could be added, but the three shown here are always required. Now, for the methods we simply need:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"QuantumCumulants.ismergeable(::Position,::Momentum) = true\nBase.:*(x::Position,p::Momentum) = im + p*x","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"And that's it. We can now use our new operator types in expressions and derive equations of motion for them.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h = FockSpace(:oscillator)\nx = Position(h,:x,1)\np = Momentum(h,:p,1)\n\n@cnumbers ω m\nH = p^2/(2m) + 0.5m*ω^2*x^2\n\neqs = meanfield([x,p],H)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The basic usage is probably best illustrated with a brief example. In the following, we solve a simple model for a single-atom laser.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We start by loading the package, defining some symbolic parameters and the photonic annihilation operator a as well as the atomic transition operator σ, which denotes a transition from level j to level i as σ(i,j). This allows us to quickly write down the Hamiltonian and the collapse operators of the system with their corresponding decay rates.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\n\n# Define parameters\n@cnumbers Δ g γ κ ν\n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf ⊗ ha\n\n# Define the fundamental operators\n@qnumbers a::Destroy(h) σ::Transition(h)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*σ(:g,:e) + a*σ(:e,:g))\n\n# Collapse operators\nJ = [a,σ(:g,:e),σ(:e,:g)]\nrates = [κ,γ,ν]\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, we define a list of operators of which we want to compute the mean-field equations. We will only consider products of two operators. This is because later we will compute the dynamics of the system up to second order.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Derive a set of equations\nops = [a'*a,σ(:e,:e),a'*σ(:g,:e)]\neqs = meanfield(ops,H,J;rates=rates)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To obtain a closed set of equations, we expand higher-order products to second order.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Expand the above equations to second order\neqs_expanded = cumulant_expansion(eqs,2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first-order contributions are always zero and can therefore be neglected. You can try adding a and σ(:g,:e) to the list of operators ops in order to see that yourself. Or, even more conveniently, you can use complete(eqs_expanded), which will automatically find all missing averages and compute the corresponding equations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, though, we will proceed by finding the missing averages, and neglecting them as zero using the substitute and simplify function from Symbolics.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Find the missing averages\nmissed = find_missing(eqs_expanded)\n\n# Substitute them as zero\nsubs = Dict(missed .=> 0)\nusing Symbolics\neqs_nophase = simplify(substitute(eqs_expanded, subs))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we can convert the MeanfieldEquations to an ODESystem as defined in ModelingToolkit which can be solved numerically with OrdinaryDiffEq.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate an ODESystem\nusing ModelingToolkit\nsys = ODESystem(eqs_nophase)\n\n# Solve the system using the OrdinaryDiffEq package\nusing OrdinaryDiffEq\nu0 = zeros(ComplexF64,length(ops))\np = (Δ, g, γ, κ, ν)\np0 = p .=> (0, 1.5, 0.25, 1, 4)\nprob = ODEProblem(sys,u0,(0.0,10.0),p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Just as with variables in ModelingToolkit, the solution of the respective averages can be accessed with a getindex method. In the following we extract and plot the photon number and the atomic excited state population by indexing the solution:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nn = real.(sol[a'*a])\npe = real.(sol[σ(:e,:e)])\nplot(sol.t, n, label=\"Photon number\", xlabel=\"t\")\nplot!(sol.t, pe, label=\"Excited state population\")\nsavefig(\"tutorial.svg\") # hide\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Photon number and excited state population)","category":"page"}]
}
