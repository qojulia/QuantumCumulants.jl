<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Implementation · QuantumCumulants.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QuantumCumulants.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../theory/">Theoretical background</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../correlation/">Correlation functions and spectra</a></li><li><a class="tocitem" href="../symbolic_sums/">Symbolic Sums and Indices</a></li><li class="is-active"><a class="tocitem" href>Implementation</a><ul class="internal"><li><a class="tocitem" href="#Hilbert-spaces"><span>Hilbert spaces</span></a></li><li><a class="tocitem" href="#Operators-(a.k.a.-*q*-numbers)"><span>Operators (a.k.a. <em>q</em>-numbers)</span></a></li><li><a class="tocitem" href="#Symbolic-parameters-(a.k.a.-*c*-numbers)"><span>Symbolic parameters (a.k.a. <em>c</em>-numbers)</span></a></li><li><a class="tocitem" href="#Operator-expressions-and-commutation-relations"><span>Operator expressions and commutation relations</span></a></li><li><a class="tocitem" href="#Cumulant-expansion"><span>Cumulant expansion</span></a></li><li><a class="tocitem" href="#Numerical-solution"><span>Numerical solution</span></a></li><li><a class="tocitem" href="#interface"><span>The <em>q</em>-number interface</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/single-atom-laser-spectrum/">Spectrum of a single-atom laser</a></li><li><a class="tocitem" href="../examples/mollow/">Mollow Triplet</a></li><li><a class="tocitem" href="../examples/many-atom-laser/">Many-atom laser</a></li><li><a class="tocitem" href="../examples/optomechanical-cooling/">Optomechanical Cooling</a></li><li><a class="tocitem" href="../examples/excitation-transport-chain/">Noisy excitation transport</a></li><li><a class="tocitem" href="../examples/ramsey_spectroscopy/">Ramsey Spectroscopy</a></li><li><a class="tocitem" href="../examples/superradiant_laser_indexed/">Superradiant Laser</a></li><li><a class="tocitem" href="../examples/cavity_antiresonance_indexed/">Cavity Antiresonance</a></li><li><a class="tocitem" href="../examples/filter-cavity_indexed/">Laser with Filter Cavities</a></li><li><a class="tocitem" href="../examples/superradiant-laser/">Superradiant Laser (outdated)</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Implementation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Implementation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qojulia/QuantumCumulants.jl/blob/master/docs/src/implementation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Implementation"><a class="docs-heading-anchor" href="#Implementation">Implementation</a><a id="Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation" title="Permalink"></a></h1><p>Let&#39;s take a closer look at each step involved from defining a system to arriving at a numerical solution of the underlying time dynamics.</p><h2 id="Hilbert-spaces"><a class="docs-heading-anchor" href="#Hilbert-spaces">Hilbert spaces</a><a id="Hilbert-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Hilbert-spaces" title="Permalink"></a></h2><p>The first step in treating a system with <strong>QuantumCumulants.jl</strong> is to specify the Hilbert space on which the system is defined. There are two types of Hilbert spaces implemented, namely <a href="../api/#QuantumCumulants.FockSpace"><code>FockSpace</code></a> and <a href="../api/#QuantumCumulants.NLevelSpace"><code>NLevelSpace</code></a>. The first describes systems whose operators follow the fundamental bosonic commutation relations (such as the quantum harmonic oscillator), whereas the latter describes systems consisting of a finite number of energy levels with an arbitrary energy difference in between (such as atoms).</p><p>A <a href="../api/#QuantumCumulants.FockSpace"><code>FockSpace</code></a> simply needs a name in order to be defined:</p><pre><code class="language-julia">hf = FockSpace(:fock1)</code></pre><p><a href="../api/#QuantumCumulants.NLevelSpace"><code>NLevelSpace</code></a> requires a name as well as labels for the energy levels. For example</p><pre><code class="language-julia">h_atom = NLevelSpace(:atom, (:g,:e))</code></pre><p>defines an <a href="../api/#QuantumCumulants.NLevelSpace"><code>NLevelSpace</code></a> with the name <code>:atom</code> and the two levels labeled by <code>:g</code> and <code>:e</code>, respectively. Note that the levels can be labeled by (almost) anything. For example, <code>NLevelSpace(:two_level, (1,2))</code> would define a Hilbert space describing a system with the two discrete energy levels labeled by <code>1</code> and <code>2</code>. Specifically for numbers, there is also the short-hand method to write <code>NLevelSpace(:five_level, 5)</code> which creates a system with levels <code>1:5</code>. Note that by default the first level in the list of all levels is designated as the ground state. This can be changed by specifying the ground state explicitly as a third argument to <a href="../api/#QuantumCumulants.NLevelSpace"><code>NLevelSpace</code></a>, e.g. <code>NLevelSpace(:four_level, 4, 2)</code> would designate the state <code>2</code> as the ground state. The ground state projector will be eliminated during simplification (see below).</p><p>Composite systems are generally described by a <a href="../api/#QuantumCumulants.ProductSpace"><code>ProductSpace</code></a>, i.e. a Hilbert space that consists of multiple subspaces. Each subspace is either a <a href="../api/#QuantumCumulants.FockSpace"><code>FockSpace</code></a> or an <a href="../api/#QuantumCumulants.NLevelSpace"><code>NLevelSpace</code></a>. They can be created using the <a href="../api/#QuantumInterface.tensor"><code>tensor</code></a> function or the unicode symbol <a href="../api/#QuantumInterface.:⊗"><code>⊗</code></a> [\otimes]. For example</p><pre><code class="language-julia">h_prod1 = tensor(hf, h_atom)
h_prod2 = tensor(h_prod1, NLevelSpace(:three_level, 3))
h_prod3 = tensor(hf, h_atom, NLevelSpace(:three_level, 3)) # == h_prod2</code></pre><p>creates two product spaces. The first, <code>h_prod1</code>, consists of the previously defined <code>FockSpace(:fock1)</code> and <code>NLevelSpace(:atom, (:g,:e))</code>. The second one, <code>h_prod2</code>, adds in another <code>NLevelSpace(:three_level, 3)</code>. In principle arbitrarily many systems can be combined this way.</p><h2 id="Operators-(a.k.a.-*q*-numbers)"><a class="docs-heading-anchor" href="#Operators-(a.k.a.-*q*-numbers)">Operators (a.k.a. <em>q</em>-numbers)</a><a id="Operators-(a.k.a.-*q*-numbers)-1"></a><a class="docs-heading-anchor-permalink" href="#Operators-(a.k.a.-*q*-numbers)" title="Permalink"></a></h2><p>Once the Hilbert space of the system has been defined, we can proceed by defining operators, or <em>q</em>-numbers, on them. They are the fundamental building blocks of symbolic expressions in <strong>QuantumCumulants.jl</strong>. Again, there are essentially two kinds of operators implemented: the quantum harmonic destruction operator <a href="../api/#QuantumCumulants.Destroy"><code>Destroy</code></a> which acts on a <a href="../api/#QuantumCumulants.FockSpace"><code>FockSpace</code></a>, as well as a <a href="../api/#QuantumCumulants.Transition"><code>Transition</code></a> operator which describes a transition between any two levels on an <a href="../api/#QuantumCumulants.NLevelSpace"><code>NLevelSpace</code></a>. These operators can only be defined on the corresponding Hilbert spaces. Note that there is no intrinsic reason that prevents us from implementing more types of operators (<a href="#interface">see below</a>), there was simply no need to do that so far.</p><p>Here are a few examples:</p><pre><code class="language-julia">hf = FockSpace(:fock)
a = Destroy(hf, :a)

h_atom = NLevelSpace(:atom,(:g,:e))
σge = Transition(h_atom, :σ, :g, :e)
σ = Transition(h_atom, :σ)
@assert isequal(σge, σ(:g,:e)) # true</code></pre><p>As you can see, the destruction operator <a href="../api/#QuantumCumulants.Destroy"><code>Destroy</code></a> is created on a <a href="../api/#QuantumCumulants.FockSpace"><code>FockSpace</code></a> and given a name. The transition operator, however, additionally requires you to specify the levels between which it describes the transition. Defining a transition without levels specified creates a callable instance which needs to be called with valid level labels before one can actually use it in any algebraic expressions. Note that in Bra-Ket notation, the transition operator <code>Transition(h, i, j)</code> is simply <span>$|i\rangle \langle j|$</span>. Also, the bosonic creation operator is simply given by the <code>adjoint</code> of <a href="../api/#QuantumCumulants.Destroy"><code>Destroy</code></a>.</p><p>These fundamental operators are all of subtypes of <a href="../api/#QuantumCumulants.QSym"><code>QSym</code></a>, and constitute the basic symbolic building blocks for the noncommutative algebra used in <strong>QuantumCumulants.jl</strong>. They can be combined using standard algebraic functions.</p><pre><code class="language-julia">ex_fock = 0.1*a&#39;*a
ex_trans = im*(σ(:g,:e) - σ(:e,:g))</code></pre><p>Note that only operators that are defined on the same Hilbert space can be algebraically combined. The resulting expressions are stored as <a href="../api/#QuantumCumulants.QTerm"><code>QTerm</code></a> types.</p><p>In composite systems, we also need to specify on which subsystem the respective operator acts. This information is important as operators acting on different subsystems commute with one another, but operators acting on the same one do not. When multiplying together operators in a composite systems, they are automatically ordered according to the order of Hilbert spaces. It&#39;s specified by an additional argument when creating operators.</p><pre><code class="language-julia">h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2)
a = Destroy(h_prod,:a,1)
b = Destroy(h_prod,:b,2)
a*b # a*b
b*a # a*b
a&#39;*b*a # a&#39;*a*b</code></pre><p>If a subspace occurs only once in a <a href="../api/#QuantumCumulants.ProductSpace"><code>ProductSpace</code></a>, the choice on which an operator acts is unique and can therefore be omitted on construction.</p><pre><code class="language-julia">h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2) ⊗ NLevelSpace(:atom,(:g,:e))
σ = Transition(h_prod, :σ) # no need to specify acts_on</code></pre><p>For convenience, there is also a macro that can be used to construct operators:</p><pre><code class="language-julia">h = FockSpace(:fock) ⊗ NLevelSpace(:two_level, 2)
@qnumbers a::Destroy(h) σ::Transition(h)
ex = a&#39;*σ(1,2) + a*σ(2,1)</code></pre><h2 id="Symbolic-parameters-(a.k.a.-*c*-numbers)"><a class="docs-heading-anchor" href="#Symbolic-parameters-(a.k.a.-*c*-numbers)">Symbolic parameters (a.k.a. <em>c</em>-numbers)</a><a id="Symbolic-parameters-(a.k.a.-*c*-numbers)-1"></a><a class="docs-heading-anchor-permalink" href="#Symbolic-parameters-(a.k.a.-*c*-numbers)" title="Permalink"></a></h2><p>Commutative numbers (<em>c</em>-numbers) are represented by <code>SymbolicUtils.Sym</code> from the <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl"><strong>SymbolicUtils.jl</strong></a> package and a custom subtype to <code>Number</code> called <a href="../api/#QuantumCumulants.CNumber"><code>CNumber</code></a>. They are generally assumed to be complex numbers and can be defined with the <a href="../api/#QuantumCumulants.cnumbers"><code>cnumbers</code></a> function or the corresponding macro <a href="../api/#QuantumCumulants.@cnumbers"><code>@cnumbers</code></a>. You can use them together with <em>q</em>-numbers to build symbolic expressions describing the Hamiltonian, e.g.</p><pre><code class="language-julia">h = FockSpace(:fock)
@cnumbers ω η
@qnumbers a::Destroy(h)
H = ω*a&#39;*a + η*(a + a&#39;)</code></pre><h2 id="Operator-expressions-and-commutation-relations"><a class="docs-heading-anchor" href="#Operator-expressions-and-commutation-relations">Operator expressions and commutation relations</a><a id="Operator-expressions-and-commutation-relations-1"></a><a class="docs-heading-anchor-permalink" href="#Operator-expressions-and-commutation-relations" title="Permalink"></a></h2><p>The equations of motion of <em>q</em>-numbers are determined by evaluating commutators. This can be done by using fundamental commutation relations, which are immediately applied whenever operators are combined in an algebraic expression.</p><p>For the quantum harmonic oscillator destruction operator <span>$a$</span>, we have the canonical commutator</p><p class="math-container">\[[a,a^\dagger] = 1.\]</p><p>Within the framework, we choose normal ordering, which surmounts to the rewriting rule</p><p class="math-container">\[a a^\dagger ~\Rightarrow~ a^\dagger a +1.\]</p><p>For transition operators <span>$\sigma^{ij}$</span> denoting a transition from level <span>$j$</span> to level <span>$i$</span>, on the other hand, we have a rule for products,</p><p class="math-container">\[\sigma^{ij}\sigma^{kl} ~\Rightarrow~ \delta_{jk}\sigma^{il},\]</p><p>which is implemented as rewriting rule just so. Additionally, we use the fact that in a system with levels <span>$\{1,...,n\}$</span></p><p class="math-container">\[\sum_{j=1}^n \sigma^{jj} = 1\]</p><p>in order to eliminate the projector on the ground state. This reduces the amount of equations required for each <a href="../api/#QuantumCumulants.NLevelSpace"><code>NLevelSpace</code></a> by 1. Note that, as mentioned before, the ground state is by default chosen to be the first (but this can be changed). Hence, the default rewriting rule to eliminate the ground-state projector is</p><p class="math-container">\[\sigma^{11} ~\Rightarrow~ 1 - \sum_{j=2}^n \sigma^{jj}.\]</p><p>Any expression involving operators is stored as a <a href="../api/#QuantumCumulants.QTerm"><code>QTerm</code></a> type. The expression trees are structured such that the application of commutation relations can be done efficiently. There are two concrete subtypes of <a href="../api/#QuantumCumulants.QTerm"><code>QTerm</code></a>, namely <code>QMul</code> representing a multiplication and <code>QAdd</code> representing an addition. Methods of multiplication and addition are implemented such that <code>QSym &lt; QMul &lt; QAdd</code>, i.e. a multiplication can only consist of numbers and fundamental operators (it cannot contain another multiplication or addition) and <code>QAdd</code> is always at the highest level possibly containing numbers, <code>QSym</code>s and <code>QMul</code>s (but no other <code>QAdd</code>s). This makes it easy and efficient to recurse through the expression tree and find pairs of operators that should be rewritten according to some commutation relation.</p><p>Note that only simplification using commutation relations is implemented directly in <strong>QuantumCumulants.jl</strong>. For any other simplification routines, operators are averaged (without applying a cumulant expansion) which makes them numbers. Those numbers are stored as expressions in <a href="https://github.com/JuliaSymbolics/SymbolicUtils.jl"><strong>SymbolicUtils.jl</strong></a> and simplified according to standard simplification rules. Afterwards, they can be converted back into <a href="../api/#QuantumCumulants.QTerm"><code>QTerm</code></a> expressions.</p><p>Here&#39;s a short example:</p><pre><code class="language-julia">h = FockSpace(:fock)
@qnumbers a::Destroy(h)
a*a&#39; # returns a&#39;*a + 1</code></pre><p>In order to derive equations of motion, you need to specify a Hamiltonian and the operator (or a list of operators) of which you want to derive the Heisenberg equations and pass them to <a href="../api/#QuantumCumulants.meanfield"><code>meanfield</code></a>, which stores both the operator as well as the average equations. In the end, we only want to work with averages.</p><pre><code class="language-julia">@cnumbers ω η
H = ω*a&#39;*a + η*(a + a&#39;) # Driven cavity Hamiltonian
me = meanfield([a, a&#39;*a], H)</code></pre><p>\begin{align} \frac{d}{dt} \langle a\rangle  =&amp; -1 i \eta -1 i \omega \langle a\rangle  \\
\frac{d}{dt} \langle a^\dagger  a\rangle  =&amp; -1 i \eta \langle a^\dagger\rangle  + 1 i \eta \langle a\rangle  \end{align}</p><h2 id="Cumulant-expansion"><a class="docs-heading-anchor" href="#Cumulant-expansion">Cumulant expansion</a><a id="Cumulant-expansion-1"></a><a class="docs-heading-anchor-permalink" href="#Cumulant-expansion" title="Permalink"></a></h2><p>Averaging (using <a href="../api/#QuantumCumulants.average"><code>average</code></a>) and the <a href="../api/#QuantumCumulants.cumulant_expansion"><code>cumulant_expansion</code></a> are essential to convert the system of <em>q</em>-number equations to <em>c</em>-number equations. Averaging alone converts any operator product to a <em>c</em>-number, yet you will not arrive at a closed set of equations without truncating at a specific order. An average is stored as a symbolic expression. Specifically, the average of an operator <code>op</code> is internally represented by <code>SymbolicUtils.Term{AvgSym}(sym_average, [op])</code>.</p><p>The order of an average is given by the number of constituents in the product. For example</p><pre><code class="language-julia">h = FockSpace(:fock)
@qnumbers a::Destroy(h)

avg1 = average(a)
get_order(avg1) # 1

avg2 = average(a&#39;*a)
get_order(avg2) # 2</code></pre><p>The cumulant expansion can then be used to express any average by averages up to a specified order (see also the <a href="../theory/#theory">theory section</a>):</p><pre><code class="language-julia">cumulant_expansion(avg2, 1)
average(a&#39;*a, 1) # short-hand for cumulant_expansion(average(a&#39;*a), 1)</code></pre><p>When deriving the equations of motion using the <a href="../api/#QuantumCumulants.meanfield"><code>meanfield</code></a> function, the <a href="../api/#QuantumCumulants.cumulant_expansion"><code>cumulant_expansion</code></a> is immediately applied if you specify an order, e.g <code>meafield(ops,H;order=2)</code>. Before you can actually solve the system of equations, you need to ensure that it is complete, i.e. there are no averages missing. This can be checked with <a href="../api/#QuantumCumulants.find_missing"><code>find_missing</code></a>. Alternatively, you can automatically complete a system of equations using the <a href="../api/#ModelingToolkit.complete"><code>complete</code></a> function which will internally use <a href="../api/#QuantumCumulants.find_missing"><code>find_missing</code></a> to look for missing averages and derive equations for those.</p><h2 id="Numerical-solution"><a class="docs-heading-anchor" href="#Numerical-solution">Numerical solution</a><a id="Numerical-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-solution" title="Permalink"></a></h2><p>Finally, in order to actually solve a system of equations, we need to convert a set of equations to an <a href="https://mtk.sciml.ai/dev/systems/ODESystem/"><code>ODESystem</code></a>, which represents a symbolic set of ordinary differential equations. <code>ODESystem</code>s are part of the <a href="https://github.com/SciML/ModelingToolkit.jl"><strong>ModelingToolkit.jl</strong></a> framework, which allows for generating fast numerical functions that can be directly used in the <a href="https://github.com/SciML/OrdinaryDiffEq.jl"><strong>OrdinaryDiffEq.jl</strong></a> package. On top of that, <a href="https://github.com/SciML/ModelingToolkit.jl"><strong>ModelingToolkit.jl</strong></a> also offers a variety of additional functionality, such as the symbolic computation of Jacobians for better stability and performance.</p><p>To obtain an <code>ODESystem</code> from <a href="../api/#QuantumCumulants.MeanfieldEquations"><code>MeanfieldEquations</code></a>, you simply need to call the constructor:</p><pre><code class="language-julia">using ModelingToolkit
@named sys = ODESystem(me)</code></pre><p>Finally, to obtain a numerical solution we can construct an <code>ODEProblem</code> and solve it.</p><pre><code class="language-julia">using OrdinaryDiffEq
p0 = (ω =&gt; 1.0, η =&gt; 0.1)
u0 = zeros(ComplexF64, length(me))
prob = ODEProblem(sys,u0,(0.0,1.0),p0)
sol = solve(prob, RK4())</code></pre><p>Now, the state of the system at each time-step is stored in <code>sol.u</code>. To access one specific solution, you can simply type e.g. <code>sol[average(a)]</code> to obtain the time evolution of the expectation value <span>$\langle a \rangle$</span>.</p><h2 id="interface"><a class="docs-heading-anchor" href="#interface">The <em>q</em>-number interface</a><a id="interface-1"></a><a class="docs-heading-anchor-permalink" href="#interface" title="Permalink"></a></h2><p>While there are currently only two different Hilbert spaces and two different types of fundamental operators implemented, their implementations are somewhat generic. This means that one can implement custom operator types along with some commutation relations for rewriting. The requirements for that are:</p><ul><li>Custom operator types need to be subtypes of <a href="../api/#QuantumCumulants.QSym"><code>QSym</code></a>.</li><li><code>Base.:*(::Operator1, ::Operator2)</code>: A multiplication method that rewrites according to a commutation relation has to be implemented.</li><li><code>QuantumCumulants.ismergeable(::Operator1, ::Operator2) = true</code> is required so pairs of <code>Operator1</code> and <code>Operator2</code> are detected in longer expressions and rewritten according to their commutation relation.</li><li>Optional: custom Hilbert space type matching the new operators.</li></ul><h4 id="Example:-Harmonic-oscillator-quadratures"><a class="docs-heading-anchor" href="#Example:-Harmonic-oscillator-quadratures">Example: Harmonic oscillator quadratures</a><a id="Example:-Harmonic-oscillator-quadratures-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Harmonic-oscillator-quadratures" title="Permalink"></a></h4><p>To illustrate, say we would like to implement the quantum harmonic oscillator in terms of the position operator <span>$x$</span> and the momentum operator <span>$p$</span> rather than the ladder operators. They fulfill the commutation relation</p><p class="math-container">\[[x,p] = i\]</p><p>and we will use it to rewrite occurrences of <span>$xp \Rightarrow px + i$</span>. For simplicity, we will define them on a <a href="../api/#QuantumCumulants.FockSpace"><code>FockSpace</code></a> instead of defining a custom Hilbert space as well.</p><pre><code class="language-julia">using QuantumCumulants

struct Position &lt;: QSym
    hilbert
    name
    aon
    metadata
end
Position(hilbert, name, aon; metadata=QuantumCumulants.source_metadata(:Position, name)) =
    Position(hilbert, name, aon, metadata)

struct Momentum &lt;: QSym
    hilbert
    name
    aon
    metadata
end
Momentum(hilbert, name, aon; metadata=QuantumCumulants.source_metadata(:Momentum, name)) =
    Momentum(hilbert, name, aon, metadata)</code></pre><p>Note that any subtype to <a href="../api/#QuantumCumulants.QSym"><code>QSym</code></a> needs to have the four fields shown above, and the  associated outer constructor. The outer constructor is needed for the interface to  Symbolics.jl. More fields could be added, but the four shown here are always required.  Now, for methods we simply need:</p><pre><code class="language-julia">QuantumCumulants.ismergeable(::Position,::Momentum) = true
Base.:*(x::Position,p::Momentum) = im + p*x
for T in (:Position, :Momentum)
    @eval Base.isequal(a::$T, b::$T) = isequal(a.hilbert, b.hilbert) &amp;&amp; isequal(a.name, b.name) &amp;&amp; isequal(a.aon, b.aon)
end</code></pre><p>The <code>Base.isequal</code> methods do not compare metadata fields. Note that if your subtypes of  <a href="../api/#QuantumCumulants.QSym"><code>QSym</code></a> have type parameters, you must also implement a method of <code>Base.hash</code> such  that <code>isequal(x,y)</code> implies <code>hash(x) == hash(y)</code>.</p><p>We can now use our new operator types in expressions and derive equations of motion for them.</p><pre><code class="language-julia">h = FockSpace(:oscillator)
x = Position(h,:x,1)
p = Momentum(h,:p,1)

@cnumbers ω m
H = p^2/(2m) + 0.5m*ω^2*x^2

eqs = meanfield([x,p],H)</code></pre><p>\begin{align} \frac{d}{dt} \langle x\rangle  =&amp; \frac{4 \langle p\rangle }{4 m} \\
\frac{d}{dt} \langle p\rangle  =&amp; -1.0 m \omega^{2} \langle x\rangle  \end{align}</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../symbolic_sums/">« Symbolic Sums and Indices</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message"><a href="https://github.com/qojulia/QuantumCumulants.jl"><strong>Back to GitHub</strong></a></p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 11 December 2022 19:14">Sunday 11 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
