<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Correlation functions and spectra · QuantumCumulants.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">QuantumCumulants.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../theory/">Theoretical background</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Correlation functions and spectra</a><ul class="internal"><li><a class="tocitem" href="#Correlation-function"><span>Correlation function</span></a></li><li><a class="tocitem" href="#Spectrum"><span>Spectrum</span></a></li><li><a class="tocitem" href="#Examples:"><span>Examples:</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/single-atom-laser-spectrum/">Spectrum of a single-atom laser</a></li><li><a class="tocitem" href="../examples/mollow/">Mollow Triplet</a></li><li><a class="tocitem" href="../examples/many-atom-laser/">Many-atom laser</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Correlation functions and spectra</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Correlation functions and spectra</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/qojulia/QuantumCumulants.jl/blob/master/docs/src/correlation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Correlation-functions-and-spectra"><a class="docs-heading-anchor" href="#Correlation-functions-and-spectra">Correlation functions and spectra</a><a id="Correlation-functions-and-spectra-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-functions-and-spectra" title="Permalink"></a></h1><p>Two quantities that are often of interest in a system are two-time correlation functions and spectral densities. Consider, for example, two operators <span>$a$</span> and <span>$b$</span>. Their two-time correlation function is given by</p><p class="math-container">\[g(t,\tau) = \langle a(t+\tau) b(t)\rangle.\]</p><p>As we can see, we need to take some care here since <span>$g$</span> depends on two different times. The spectral density corresponding to <span>$a$</span> and <span>$b$</span> is given by the Fourier transform,</p><p class="math-container">\[S(\omega) = 2\text{Re}\left\{\int d\tau e^{-i\omega\tau}g(t,\tau)\right\}.\]</p><p>So in any case, we need to treat the two-time correlation function before we can obtain the spectrum.</p><h2 id="Correlation-function"><a class="docs-heading-anchor" href="#Correlation-function">Correlation function</a><a id="Correlation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Correlation-function" title="Permalink"></a></h2><p>In order to compute a correlation function, we first evolve a system of equations up to a time <span>$t$</span>. Then, we can derive another set of equations that describe the correlation function. This new set of equations is then evolved from time <span>$t$</span> up to a time <span>$t+\tau$</span>. The correlation function is then stored in the first entry of the result. The initial state of the set of equations describing the correlation function will be determined by the state of the original system at time <span>$t$</span>.</p><p>Note, that whenever an instance of a <a href="../api/#QuantumCumulants.CorrelationFunction"><code>CorrelationFunction</code></a> is created, a set of equations is derived using a custom version of the <a href="../api/#QuantumCumulants.complete"><code>complete</code></a> function. Depending on the size and order of the considered system, this can take some time. An important distinction that can eventually reduce the computation time by quite a bit is whether or not the original system has been evolved up to steady state, i.e. if the system does not change its state after <span>$t$</span>. This can be controlled with the keyword argument <code>steady_state=true</code> when construction the <a href="../api/#QuantumCumulants.CorrelationFunction"><code>CorrelationFunction</code></a>.</p><p>To clarify the usage, consider the simple case of a cavity with resonance frequency <span>$\omega_\mathrm{c}$</span> that initially has a finite number of photons inside which decay over time at a rate <span>$\kappa$</span>. We want to compute the two-time correlation function of the field (first-order degree of coherence) given by</p><p class="math-container">\[g(t,\tau) = \langle a^\dagger(t+\tau)a(t)\rangle.\]</p><p>Given the Hamiltonian <span>$H = \omega_\mathrm{c}a^\dagger a$</span> and the collapse operator <span>$a$</span>, it is easy to derive the equation</p><p class="math-container">\[\frac{d}{d\tau}a^\dagger(t+\tau) = (i\omega_\mathrm{c} - \frac{\kappa}{2})a^\dagger(t+\tau).\]</p><p>Since <span>$a(t)$</span> is independent of <span>$\tau$</span> we can simply multiply the above equation with <span>$a(t)$</span> from the right and average to obtain</p><p class="math-container">\[\frac{d}{d\tau}\langle a^\dagger(t+\tau) a(t)\rangle = (i\omega_\mathrm{c} - \frac{\kappa}{2})\langle a^\dagger(t+\tau) a(t)\rangle.\]</p><p>Note that this is generally valid, and will lead to a system of equations that is linear in <span>$a(t)$</span>. The above is the equation of motion for the correlation function <span>$g(t,\tau)$</span>. In this very simple case we can solve it analytically and find</p><p class="math-container">\[g(t,\tau) = \langle a^\dagger(t)a(t)\rangle e^{(i\omega_\mathrm{c} - \kappa/2)\tau}.\]</p><p>This is the essential procedure with which correlation functions can be computed within <strong>QuantumCumulants.jl</strong>. In code, the above is just:</p><pre><code class="language-julia">h = FockSpace(:cavity)
a = Destroy(h,:a)
@cnumbers ωc κ
H = ωc*a&#39;*a
me = meanfield(a&#39;*a,H,[a];rates=[κ])

c = CorrelationFunction(a&#39;, a, me)</code></pre><p>When the <a href="../api/#QuantumCumulants.CorrelationFunction"><code>CorrelationFunction</code></a> is constructed, an additional Hilbert space is added internally which represents the system at the time <span>$t$</span>. In our case, this means that another <a href="../api/#QuantumCumulants.FockSpace"><code>FockSpace</code></a> is added. Note that all operators involved in the correlation function are defined on the <a href="../api/#QuantumCumulants.ProductSpace"><code>ProductSpace</code></a> including this additional Hilbert space.</p><p>The equation for <span>$g(t,\tau)$</span> is now stored in the first entry of <code>c.de</code>. To solve the above numerically, we need to convert to an <code>ODESystem</code> and solve numerically.</p><pre><code class="language-julia">using ModelingToolkit, OrdinaryDiffEq

sys = ODESystem(me)
n0 = 20.0 # Initial number of photons in the cavity
u0 = [n0]
p0 = (1,1)
prob = ODEProblem(sys,u0,(0.0,2.0),p0) # End time not in steady state
sol = solve(prob,RK4())</code></pre><p>Numerically computing the correlation function works in the same way. Note, the initial state of the correlation function depends on the final state of the system. However, in general it does not depend on <em>all</em> the final values of the system. The correct values can be picked out automatically using the <a href="../api/#QuantumCumulants.correlation_u0"><code>correlation_u0</code></a> function.</p><pre><code class="language-julia">csys = ODESystem(c)
u0_c = correlation_u0(c, sol.u[end])
prob_c = ODEProblem(csys,u0_c,(0.0,10.0),p0)
sol_c = solve(prob_c,RK4(),save_idxs=1)</code></pre><p>Finally, lets check our numerical solution against the analytic one obtained above:</p><pre><code class="language-julia">g_analytic(τ) = @. sol.u[end] * exp((im*p0[1]-0.5p0[2])*τ)
@test isapprox(sol_c.u, g_analytic(sol_c.t), rtol=1e-4)</code></pre><pre class="documenter-example-output">Test Passed</pre><p>Note, that this was a very simple case. Usually the system of equations describing the correlation function is much more complex and depends on multiple other correlation functions (see for example <a href="../examples/single-atom-laser-spectrum/#Spectrum-of-a-single-atom-laser">Spectrum of a single atom laser</a>).</p><h2 id="Spectrum"><a class="docs-heading-anchor" href="#Spectrum">Spectrum</a><a id="Spectrum-1"></a><a class="docs-heading-anchor-permalink" href="#Spectrum" title="Permalink"></a></h2><p>There are two possible ways two compute the spectrum given a correlation function:</p><ol><li>Solving the differential equation needed to obtain <span>$g(t,\tau)$</span> and taking the Fourier transform.</li><li>Taking the (symbolic) Laplace transform of the system of equations describing a correlation function.</li></ol><p>On the one hand, the first approach works generally, but is computationally more intense. The second approach, on the other hand, yields a simple linear system of equations which is easy to solve, but only works when the correlation function has been computed starting from the steady state. Both methods can be easily used with <strong>QuantumCumulants.jl</strong>.</p><h3 id="Numerical-solution-of-g(t,\\tau)"><a class="docs-heading-anchor" href="#Numerical-solution-of-g(t,\\tau)">Numerical solution of <span>$g(t,\tau)$</span></a><a id="Numerical-solution-of-g(t,\\tau)-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-solution-of-g(t,\\tau)" title="Permalink"></a></h3><p>As mentioned above, this approach works generally, regardless of whether the system is in steady state at time <span>$t$</span>. However, it has some computational drawbacks. Additionally, the spectrum is not always well defined when not in steady state. This approach is the same as the one used in <a href="https://qojulia.org"><strong>QuantumOptics.jl</strong></a>, and we can borrow the implemented FFT function from there:</p><pre><code class="language-julia">τ = collect(range(0.0, sol_c.t[end], length=101)) # need equidistant list of times for FFT
using QuantumOptics.timecorrelations: correlation2spectrum
ω, s = correlation2spectrum(τ, sol_c.(τ))</code></pre><p>The spectrum obtained in this way roughly has a FWHM of <code>κ</code> and is based around the chosen <code>ωc</code>. The fact that the FWHM is not <em>exactly</em> <code>κ</code> illustrates the computation drawback: in order to obtain the correct FWHM we would have to increase the integration time by orders of magnitude. For larger systems, this can be computationally expensive.</p><h3 id="Steady-state:-using-the-Laplace-transform"><a class="docs-heading-anchor" href="#Steady-state:-using-the-Laplace-transform">Steady state: using the Laplace transform</a><a id="Steady-state:-using-the-Laplace-transform-1"></a><a class="docs-heading-anchor-permalink" href="#Steady-state:-using-the-Laplace-transform" title="Permalink"></a></h3><p>A useful property of the two-time correlation function is that, if the system is in steady state at time <span>$t$</span>, then the system of equations is linear, since <span>$b(t)$</span> can occur at most once in each product. We can therefore write any system of equations describing the correlation function as</p><p class="math-container">\[\frac{d}{d\tau} \textbf{y}(\tau) = \textbf{M} \textbf{y}(\tau) + \textbf{c},\]</p><p>where <span>$\textbf{y}(\tau)$</span> is the vector containing the left-hand-side of the correlation function system (<span>$g(t,\tau) \equiv y_1(\tau)$</span>). The matrix <span>$\textbf{M}$</span> contains coefficients consisting of parameters and steady-state values, and is independent of time, and the vector <span>$\textbf{c}$</span> includes other constants.</p><p>We define <span>$\textbf{x}(s) = \mathcal{L}\left(\textbf{y}(\tau)\right)$</span>, i.e. <span>$\textbf{x}(s)$</span> is the Laplace transform of <span>$\textbf{y}(\tau)$</span> with respect to <span>$\tau$</span>. Applying the Laplace transform to the differential equation above, we obtain</p><p class="math-container">\[(s - \textbf{M})\textbf{x}(s) = \textbf{y}(0) + \frac{\textbf{c}}{s}.\]</p><p>The Laplace transform is equivalent to the Fourier transform at the point <span>$s=i \omega$</span>, i.e. the spectrum is given by <span>$S(\omega) = 2\text{Re}\left\{x_1(i\omega)\right\}$</span>. Therefore, we can reduce the task to solving the equation</p><p class="math-container">\[A\textbf{x} = b + c,\]</p><p>where <span>$A = i\omega - \textbf{M}$</span>, <span>$b = \textbf{y}(0)$</span> and <span>$c=\textbf{c}/(i\omega)$</span>. In most cases, solving the above matrix equation is much faster than doing an additional time evolution to obtain the correlation function.</p><p>This approach is implemented with the <a href="../api/#QuantumCumulants.Spectrum"><code>Spectrum</code></a> type, which performs the Laplace transform and computes the matrix <span>$A$</span> and the vectors <span>$b$</span> and <span>$c$</span> symbolically. Additionally, functions that return all those things in numerical form depending on the steady-state values and given parameters are generated via <a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics</a> <code>build_function</code>. Usage is as follows:</p><pre><code class="language-julia">c = CorrelationFunction(a&#39;, a, me; steady_state=true) # need to specify steady state
S = Spectrum(c,(ωc,κ))</code></pre><p>The above performs the Laplace transform on a symbolic level (i.e. it derives the matrix <span>$A$</span>). To actually compute the spectrum, we can do</p><pre><code class="language-julia">s = S(ω,sol.u[end],p0)</code></pre><h2 id="Examples:"><a class="docs-heading-anchor" href="#Examples:">Examples:</a><a id="Examples:-1"></a><a class="docs-heading-anchor-permalink" href="#Examples:" title="Permalink"></a></h2><ul><li><a href="../examples/mollow/#Mollow-Triplet">Mollow Triplet</a></li><li><a href="../examples/single-atom-laser-spectrum/#Spectrum-of-a-single-atom-laser">Spectrum of a single atom laser</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 20 April 2021 08:49">Tuesday 20 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
