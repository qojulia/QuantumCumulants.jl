var documenterSearchIndex = {"docs":
[{"location":"examples/superradiant-laser/#Superradiant-Laser-(outdated)","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"","category":"section"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"note: Note\nThe textttClusterSpace is no longer necessary due to the implementation of symbolic sums and indices. We recommend using symbolic sums and indices now, as in the examples Superradiant Laser or Laser with Filter Cavities. However, since the textttClusterSpace was already used in several publications we keep this example on the documentation.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"Using symmetry properties of a system can reduce the number of needed equations dramatically. A common approximation for laser systems to handle sufficiently big atom numbers is to assume that several atoms in the system behave completely identically. This means all the identical atoms have the same averages.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"In this example we describe a so-called superradiant laser, where we assume all atoms to be identical. This model has been described in D. Meiser et al., Phys. Rev. Lett. 102, 163601 (2009): The Hamiltonian of this system is","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"H = - hbar Delta a^dagger a +  hbar sumlimits_j=1^N  g_j (a^dagger sigma^12_j + a sigma^21_j)","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"where Delta = omega_a - omega_c is the detuning between the cavity (omega_c) and the atomic (omega_a) resonance frequency, the atom cavity coupling of the atom j is denoted by g_j. Additionally there are dissipative processes in the system, namely: Atoms are incoherently pumped with the rate R, they decay individually with the rate Gamma and are affected by individual atomic dephasing with the rate nu. Photons leak out of the system with the rate kappa.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"We start by loading the packages.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\nusing OrdinaryDiffEq, SteadyStateDiffEq, ModelingToolkit\nusing Plots","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"To give QuantumCumulants the information that several atoms behave identically we need to create a textttClusterSpace on the desired Hilbert space. This textttClusterSpace additionally needs the order M of the system and a symbolic parameter for the number of identical elements N.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"M = 2 # order\n@cnumbers N Δ g κ Γ R ν\n\n# Hilbertspace\nhc = FockSpace(:cavity)\nha_ = NLevelSpace(:atom,2)\nha = ClusterSpace(ha_, N, M)\nh = hc ⊗ ha","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"Now we can define the operators on the composite Hilbert space including the textttClusterSpace, the workflow is completely the same as for 'normal' Hilbert spaces.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"# operators\n@qnumbers a::Destroy(h)\nσ(i,j) = Transition(h, :σ, i, j, 2)\nσ(2,2)","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"What is different, however, is that the transition operator defined on the textttClusterSpace is an array of M transitions defined on internally created sub-Hilbert spaces. The reason for this is the following: Although we assume all atoms to be identical, we still need to keep track of the correlations between different atoms. Since langle sigma^21_1 sigma^12_1 rangle = langle sigma^22_1 rangle is obviously not equal to langle sigma^21_1 sigma^12_2 rangle at least a second atom is needed for a second order description. On the other hand, as all atoms are the same, it must hold that langle sigma^21_1 sigma^12_2 rangle = langle sigma^21_alpha sigma^12_beta rangle for all alpha ne beta, therefore two atoms are sufficient. For higher orders and or bosonic operators the arguments are the same.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"The symbolic calculation rules for these operators acting on a textttClusterSpace are implemented such that e.g. sumlimits_j sigma^22_j can be written as sum(sigma(22)) in the code. For the jump operators the syntax is such that individual atomic dissipation is written as J = σ(ij), whereas collective behaviour is expressed as J = sum(σ(ij)). The Hamiltonian and the dissipative processes for individual atomic behaviour are therefore","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"# Hamiltonian\nH = -Δ*a'a + g*(a'*sum(σ(1,2)) + a*sum(σ(2,1)))\n\n# Jump operators & rates\nJ = [a, σ(1,2), σ(2,1), σ(2,2)]\nrates = [κ, Γ, R, ν]\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"First we want to derive the equation for langle a^dagger a rangle and langle sigma_1^22 rangle. textttQuantumCumulants automatically sets the right scaling factors in the equations to account for the number of identical atoms and also replaces redundant averages, e.g. langle sigma_2^22 rangle is replaced by langle sigma_1^22 rangle in the equations, since all atoms behave identically these two averages are the same.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"# Derive equations\nops = [a'*a, σ(2,2)[1]]\neqs = meanfield(ops,H,J;rates=rates,order=M)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"beginalign\nfracddt langle a^dagger  arangle  = -10 kappa langle a^dagger  arangle  -10 i N g langle a^dagger  sigma_1^12rangle  + 10 i N g langle a  sigma_1^21rangle  \nfracddt langle sigma_1^22rangle  = R -10 R langle sigma_1^22rangle  + 1 i g langle a^dagger  sigma_1^12rangle  -1 i g langle a  sigma_1^21rangle  -10 Gamma langle sigma_1^22rangle\nendalign","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"To get a closed set of equations we automatically complete the system. Since this system is phase invariant we know that all averages with a phase are zero, therefore we exclude these terms with a filter function.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"# custom filter function\nφ(x::Average) = φ(x.arguments[1])\nφ(::Destroy) = -1\nφ(::Create) =1\nφ(x::QTerm) = sum(map(φ, x.args_nc))\nφ(x::Transition) = x.i - x.j\nphase_invariant(x) = iszero(φ(x))\n\n# Complete equations\neqs_c = complete(eqs; filter_func=phase_invariant)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"beginalign\nfracddt langle a^dagger  arangle  = -10 kappa langle a^dagger  arangle  -10 i N g langle a^dagger  sigma_1^12rangle  + 10 i N g langle a  sigma_1^21rangle  \nfracddt langle sigma_1^22rangle  = R -10 R langle sigma_1^22rangle  + 1 i g langle a^dagger  sigma_1^12rangle  -1 i g langle a  sigma_1^21rangle  -10 Gamma langle sigma_1^22rangle  \nfracddt langle a^dagger  sigma_1^12rangle  = -05 R langle a^dagger  sigma_1^12rangle  + 1 i g langle sigma_1^22rangle  -1 i g langle a^dagger  arangle  -05 Gamma langle a^dagger  sigma_1^12rangle  -1 i Delta langle a^dagger  sigma_1^12rangle  -05 kappa langle a^dagger  sigma_1^12rangle  -05 nu langle a^dagger  sigma_1^12rangle  + 2 i g langle sigma_1^22rangle  langle a^dagger  arangle  + 1 i g langle sigma_1^21  sigma_2^12rangle  left( -1 + N right) \nfracddt langle sigma_1^21  sigma_2^12rangle  = -10 R langle sigma_1^21  sigma_2^12rangle  + 1 i g langle a^dagger  sigma_1^12rangle  -1 i g langle a  sigma_1^21rangle  -10 Gamma langle sigma_1^21  sigma_2^12rangle  -10 nu langle sigma_1^21  sigma_2^12rangle  -2 i g langle sigma_1^22rangle  langle a^dagger  sigma_1^12rangle  + 2 i g langle sigma_1^22rangle  langle a  sigma_1^21rangle\nendalign","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"To calculate the dynamics of the system we create a system of ordinary differential equations, which can be used by DifferentialEquations.jl.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"@named sys = ODESystem(eqs_c)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"Finally we need to define the numerical parameters and the initial state of the system. We will consider 2 cdot 10^5 Strontium atoms which are repumped with a rate of R = 1textHz on the clock transition (Gamma = 1 textmHz). The atom-cavity coupling rate is g = 1textHz, the cavity has a linewidth of kappa = 5textkHz and is detuned from the atomic resonance by Delta = 25textHz.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"# Initial state\nu0 = zeros(ComplexF64, length(eqs_c))\n# System parameters\nN_ = 2e5\nΓ_ = 1.0 #Γ=1mHz\nΔ_ = 2500Γ_ #Δ=2.5Hz\ng_ = 1000Γ_ #g=1Hz\nκ_ = 5e6*Γ_ #κ=5kHz\nR_ = 1000Γ_ #R=1Hz\nν_ = 1000Γ_ #ν=1Hz\n\nps = [N, Δ, g, κ, Γ, R, ν]\np0 = [N_, Δ_, g_, κ_, Γ_, R_, ν_]\n\nprob = ODEProblem(sys,u0,(0.0, 1.0/50Γ_), ps.=>p0)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"sol = solve(prob,Tsit5(),maxiters=1e7)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"# Plot time evolution\nt = sol.t\nn = real.(sol[a'a])\ns22 = real.(sol[σ(2,2)[1]])\n\n# Plot\np1 = plot(t, n, xlabel=\"tΓ\", ylabel=\"⟨a⁺a⟩\", legend=false)\np2 = plot(t, s22, xlabel=\"tΓ\", ylabel=\"⟨σ22⟩\", legend=false)\nplot(p1, p2, layout=(1,2), size=(700,300))","category":"page"},{"location":"examples/superradiant-laser/#Spectrum","page":"Superradiant Laser (outdated)","title":"Spectrum","text":"","category":"section"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"We calculate the spectrum here with the Laplace transform of the two-time correlation function. This is implemented with the function textttSpectrum.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"corr = CorrelationFunction(a', a, eqs_c; steady_state=true, filter_func=phase_invariant)\nS = Spectrum(corr, ps)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"The set of equations for the correlation function is given by","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"corr.de\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"beginalign\nfracddtau langle a^dagger  a_0rangle  = -1 i Delta langle a^dagger  a_0rangle  -05 kappa langle a^dagger  a_0rangle  + 10 i N g langle sigma_1^21  a_0rangle  \nfracddtau langle sigma_1^21  a_0rangle  = -05 R langle sigma_1^21  a_0rangle  + 1 i g langle a^dagger  a_0rangle  -05 Gamma langle sigma_1^21  a_0rangle  -05 nu langle sigma_1^21  a_0rangle  -2 i g langle sigma_1^22rangle  langle a^dagger  a_0rangle\nendalign","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"To ensure we are in the steady state we use a steady solver to calculate it. To this end we need to define the textttSteadyStateProblem and specify the desired method. We also need to increase the textttmaxiters and the solver accuracy to handle this numerically involved problem.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"prob_ss = SteadyStateProblem(prob)\nsol_ss = solve(prob_ss, DynamicSS(Tsit5(); abstol=1e-8, reltol=1e-8),\n    reltol=1e-14, abstol=1e-14, maxiters=5e7)\nnothing # hide","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"The spectrum is then calculated with","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"ω = [-10:0.01:10;]Γ_\nspec = S(ω,sol_ss.u,p0)\nspec_n = spec ./ maximum(spec)\nδ = abs(ω[(findmax(spec)[2])])","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"plot(ω, spec_n, xlabel=\"ω/Γ\", legend=false, size=(500,300))","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"Beside the narrow linewidth we can also see another key feature of the superradiant laser here, namely the very weak cavity pulling. At a detunig of Delta = 2500Gamma there is only a shift of the laser light from the atomic resonance frequency of delta = 1Gamma.","category":"page"},{"location":"examples/superradiant-laser/","page":"Superradiant Laser (outdated)","title":"Superradiant Laser (outdated)","text":"note: Note\nThe implementation of the scaling rules are still in an early stage of development and they are quite 'experimental'. So make sure to double check the equations when using them in more complicated systems.","category":"page"},{"location":"examples/ramsey_spectroscopy/#Ramsey-Spectroscopy","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"","category":"section"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"A typical problem in quantum optics is the interrogation of an atom with an external driving field. In this brief example we apply the Ramsey interferometry on a single two-level atom. The distinctiveness of this method is the time dependent laser field. In particular, two short pi2-pulses are employed with a free evolution between them. This system is described by the simple Hamiltonian","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"H = - Delta sigma^22 +  Omega(t) (sigma^21 + sigma^12)","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"where Delta = omega_l - omega_a is the detuning between the laser and atomic resonance frequency, and Omega(t) describes the time dependent driving field. Additionally we include atomic decay and dephasing, with the rates Gamma and nu, respectively.","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"We start by loading the packages.","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"using QuantumCumulants\nusing OrdinaryDiffEq, ModelingToolkit\nusing Plots","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"Beside defining the symbolic parameters we additionally need to register a time dependent external function f(t) for our driving laser. To this end we first need to define the independent variable t of our time evolution. Due to the registration, f(t) is treated as a parameter in the symbolic equations, but at the numerical evaluation we can assign every function to it.","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"@cnumbers Δ Ω Γ ν\n@syms t::Real\n@register f(t)","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"After defining the Hilbert space and the operator of the two-level atom we construct the time dependent Hamiltonian as well as the jump operator list with the corresponding rates.","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"# Hilbert space\nh = NLevelSpace(:atom,2)\n\n# operator\nσ(i,j) = Transition(h, :σ, i, j, 2)\n\n# Hamiltonian\nH = -Δ*σ(2,2) + f(t)*Ω/2*(σ(1,2) + σ(2,1))\n\n# Jump operators & rates\nJ = [σ(1,2), σ(2,2)]\nrates = [Γ, ν]\nnothing # hide","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"The two-level atom is completely described with the excited state population and the coherence. Therefore we derive the equations for these two operators.","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"eqs = meanfield([σ(2,2), σ(1,2)],H,J;rates=rates)\nnothing # hide","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"beginalign\nfracddt langle sigma^22rangle  = -10 Gamma langle sigma^22rangle  + frac12 i Omega fleft( t right) langle sigma^12rangle  + frac-12 i Omega fleft( t right) langle sigma^21rangle  \nfracddt langle sigma^12rangle  = frac-12 i Omega fleft( t right) -05 Gamma langle sigma^12rangle  -05 nu langle sigma^12rangle  + 1 i Delta langle sigma^12rangle  + 1 i Omega fleft( t right) langle sigma^22rangle\nendalign","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"To calculate the dynamic of the system we create a system of ordinary differential equations and define the numeric parameters with the time dependent function.","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"@named sys = ODESystem(eqs)\n\n# Parameter\nΓ_ = 1.0\nΩ_ = 500Γ_\nΔ_ = 0Γ_\nν_ = 0.2Γ_\n\ntp = π/2Ω_ # π/2-pulse\ntf = 1/20Γ_ # free evolution without drive\n\nfunction f(t)\n    if t<tp || (t>tp+tf && t<2tp+tf)\n        return 1\n    else\n        0\n    end\nend    \n\nps = [Γ; Ω; Δ; ν]\np0 = [Γ_; Ω_; Δ_; ν_]\n\n# Initial state\nu0 = zeros(ComplexF64, length(eqs))\nnothing # hide","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"Finally, we calculate and plot the time evolution.","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"prob = ODEProblem(sys,u0,(0.0, 2tp+tf), ps.=>p0)\nsol = solve(prob,Tsit5(),maxiters=1e7)\n\n# Plot time evolution\nt = sol.t\ns22 = real.(sol[σ(2,2)])\nplot(t, s22, xlabel=\"tΓ\", ylabel=\"⟨σ22⟩\", legend=false, size=(600,300))","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"Scanning over the detuning for the excited state population leads to the well-known Ramsey fringes.","category":"page"},{"location":"examples/ramsey_spectroscopy/","page":"Ramsey Spectroscopy","title":"Ramsey Spectroscopy","text":"Δ_ls = [-2000:4:2000;]Γ_\ns22_ls = zeros(length(Δ_ls))\n\nfor i=1:length(Δ_ls)\n    prob_i = ODEProblem(sys,u0,(0.0, 2tp+tf), [Γ; Ω; Δ; ν].=>[Γ_; Ω_; Δ_ls[i]; ν_])\n    sol_i = solve(prob_i, RK4(); adaptive=false, dt=1e-5)\n    s22_ls[i] = real.(sol_i[σ(2,2)])[end]\nend\n\nplot(Δ_ls, s22_ls, xlabel=\"Δ/Γ\", ylabel=\"⟨σ22⟩\", legend=false, size=(600,300))","category":"page"},{"location":"examples/single-atom-laser-spectrum/#Spectrum-of-a-single-atom-laser","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"","category":"section"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"In this example, we will compute the spectrum of the single-atom laser, which is also shown in the Tutorial. The Hamitlonian of the system is","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"H = Delta a^dagger a + gleft(a^dagger sigma^ge + asigma^egright)","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"where Delta = omega_mathrmc - omega_mathrma is the detuning between the cavity and the atomic resonance frequency, respectively. The cavity loses photons at a rate kappa, and the atom is subject to spontaneous emission with a rate gamma. Additionally, the atom is incoherently driven with a rate nu, such that it can provide lasing gain to the system. We start, by specifying this model.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\nusing ModelingToolkit, OrdinaryDiffEq\nusing Plots\n\n# Define parameters\n@cnumbers Δ g γ κ ν\n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf ⊗ ha\n\n# Define the fundamental operators\na = Destroy(h,:a)\ns = Transition(h,:σ,:g,:e)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*s + a*s')\n\n# Collapse operators\nJ = [a,s,s']\nrates = [κ,γ,ν]\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"The first equation we want to derive is that for the average photon number langle a^dagger a rangle.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Derive equation for average photon number\neq_n = meanfield(a'*a,H,J;rates=rates,order=2)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"The remaining equations will be computed automatically using the complete function. However, we want to exclude terms such as langle a rangle since these are phase-dependent and therefore 0 in our phase-invariant system. To this end, we provide a custom filter function to complete. This function should return true, if the given average should be included, and false if it should be excluded (just like Julia's native filter function requires). We write a small function phi that computes the phase of an average, such that phi(a) = -1, phi(a^dagger) = 1, and phi(a^dagger a) = phi(a) + phi(a^dagger) = 0. Similarly, we want to have phi(sigma^eg)=1=-phi(sigma^ge), and phi(sigma^ee)=0. An average of an operator x is then said to be phase invariant if phi(x)=0.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Custom filter function -- include only phase-invariant terms\nϕ(x) = 0\nϕ(::Destroy) = -1\nϕ(::Create) = 1\nfunction ϕ(t::Transition)\n    if (t.i==:e && t.j==:g)\n        1\n    elseif (t.i==:g && t.j==:e)\n        -1\n    else\n        0\n    end\nend\nϕ(avg::Average) = ϕ(avg.arguments[1])\nfunction ϕ(t::QuantumCumulants.QMul)\n    p = 0\n    for arg in t.args_nc\n        p += ϕ(arg)\n    end\n    return p\nend\nphase_invariant(x) = iszero(ϕ(x))\n\n# Complete equations\neqs = complete(eq_n;filter_func=phase_invariant)","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"In order to compute the spectrum, we first compute the correlation function g(tau) = langle a^dagger(t_0 + tau) a(t_0)rangle equiv langle a^dagger a_0rangle","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Note that the CorrelationFunction finds the equation for g(tau) and then completes the system of equations by using its own version of the complete function. We can also provide the same custom filter function as before to skip over terms that are not phase-invariant. Similarly, setting the keyword steady_state=true, we tell the function not to derive equations of motion for operators that do not depend on tau, but only on t_0 (if t_0 is in steady state, these values do not change with tau).","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Correlation function\nc = CorrelationFunction(a', a, eqs; steady_state=true, filter_func=phase_invariant)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"langle a^dagger a_0rangle","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"As we can see, there are only two equations necessary to obtain the correlation function:","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"c.de\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"beginalign fracddt langle a^dagger a_0rangle = 10 i g langle sigma^eg a_0rangle + 10 i Delta langle a^dagger a_0rangle -05 kappa langle a^dagger a_0rangle \nfracddt langle sigma^eg a_0rangle = 10 i g langle a^dagger a_0rangle -05 gamma langle sigma^eg a_0rangle -05 nu langle sigma^eg a_0rangle -20 i langle sigma^eerangle g langle a^dagger a_0rangle\nendalign","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"The spectrum can now be computed by solving the above system of equations and then taking the Fourier transform, or by taking the Fourier transform directly, which is done by constructing an instance of the Spectrum type. Here, we will compare both approaches.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"In any case, we need to compute the steady state of the system numerically.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Numerical solution\nps = (Δ, g, γ, κ, ν)\n@named sys = ODESystem(eqs)\nu0 = zeros(ComplexF64, length(eqs))\np0 = (1.0, 1.5, 0.25, 1, 4)\nprob = ODEProblem(sys,u0,(0.0,10.0),ps.=>p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Now, we can compute the time evolution of the correlation function in a similar way. Since the initial state of this system does not necessarily depend on all steady-state values, we can use the correlation_u0 function which automatically generates the correct initial state vector required. Similarly, we use correlation_p0 which generates the list of parameters including all needed steady-state values.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Time evolution of correlation function\n@named csys = ODESystem(c)\nu0_c = correlation_u0(c,sol.u[end])\np0_c = correlation_p0(c,sol.u[end],ps.=>p0)\nprob_c = ODEProblem(csys,u0_c,(0.0,500.0),p0_c)\nsol_c = solve(prob_c,RK4(),save_idxs=1)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Finally, we borrow the FFT function from QuantumOptics.jl and compute the spectrum from the solution. Note that this requires an equidistant list of times, and we therefore interpolate the solution from the differential equation.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Interpolate solution\nτ = range(0.0, sol_c.t[end], length=15001)\ncorr = sol_c.(τ)\n\n# Compute spectrum\nusing QuantumOptics.timecorrelations: correlation2spectrum\nω, s_fft = correlation2spectrum(τ, corr)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Now, in order to compare we also compute the spectrum by constructing it directly from the correlation function and plot the results.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Spectrum\nS = Spectrum(c,ps)\ns_laplace = S(ω,sol.u[end],p0)\nnothing # hide\n\nplot(ω, s_fft, label=\"Spectrum (FFT)\", xlabel=\"ω\")\nplot!(ω, s_laplace, label=\"Spectrum (Laplace)\")\nxlims!(-3,3)","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"As expected, both methods yield exactly the same spectrum. The difference is just in the method used, with the Laplace transform having a computational advantage.","category":"page"},{"location":"correlation/#Correlation-functions-and-spectra","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Two quantities that are often of interest in a system are two-time correlation functions and spectral densities. Consider, for example, two operators a and b. Their two-time correlation function is given by","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"g(ttau) = langle a(t+tau) b(t)rangle","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"As we can see, we need to take some care here since g depends on two different times. The spectral density corresponding to a and b is given by the Fourier transform,","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"S(omega) = 2textReleftint dtau e^-iomegataug(ttau)right","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"So in any case, we need to treat the two-time correlation function before we can obtain the spectrum.","category":"page"},{"location":"correlation/#Correlation-function","page":"Correlation functions and spectra","title":"Correlation function","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"In order to compute a correlation function, we first evolve a system of equations up to a time t. Then, we can derive another set of equations that describe the correlation function. This new set of equations is then evolved from time t up to a time t+tau. The correlation function is then stored in the first entry of the result. The initial state of the set of equations describing the correlation function will be determined by the state of the original system at time t.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Note, that whenever an instance of a CorrelationFunction is created, a set of equations is derived using a custom version of the complete function. Depending on the size and order of the considered system, this can take some time. An important distinction that can eventually reduce the computation time by quite a bit is whether or not the original system has been evolved up to steady state, i.e. if the system does not change its state after t. This can be controlled with the keyword argument steady_state=true when construction the CorrelationFunction.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"To clarify the usage, consider the simple case of a cavity with resonance frequency omega_mathrmc that initially has a finite number of photons inside which decay over time at a rate kappa. We want to compute the two-time correlation function of the field (first-order degree of coherence) given by","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"g(ttau) = langle a^dagger(t+tau)a(t)rangle","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Given the Hamiltonian H = omega_mathrmca^dagger a and the collapse operator a, it is easy to derive the equation","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"fracddtaua^dagger(t+tau) = (iomega_mathrmc - frackappa2)a^dagger(t+tau)","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Since a(t) is independent of tau we can simply multiply the above equation with a(t) from the right and average to obtain","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"fracddtaulangle a^dagger(t+tau) a(t)rangle = (iomega_mathrmc - frackappa2)langle a^dagger(t+tau) a(t)rangle","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Note that this is generally valid, and will lead to a system of equations that is linear in a(t). The above is the equation of motion for the correlation function g(ttau). In this very simple case we can solve it analytically and find","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"g(ttau) = langle a^dagger(t)a(t)rangle e^(iomega_mathrmc - kappa2)tau","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"This is the essential procedure with which correlation functions can be computed within QuantumCumulants.jl. In code, the above is just:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"using QuantumCumulants # hide\nh = FockSpace(:cavity)\na = Destroy(h,:a)\n@cnumbers ωc κ\nH = ωc*a'*a\nme = meanfield(a'*a,H,[a];rates=[κ])\n\nc = CorrelationFunction(a', a, me)\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"When the CorrelationFunction is constructed, an additional Hilbert space is added internally which represents the system at the time t. In our case, this means that another FockSpace is added. Note that all operators involved in the correlation function are defined on the ProductSpace including this additional Hilbert space.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The equation for g(ttau) is now stored in the first entry of c.de. To solve the above numerically, we need to convert to an ODESystem and solve numerically.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"using ModelingToolkit, OrdinaryDiffEq\n\n@named sys = ODESystem(me)\nn0 = 20.0 # Initial number of photons in the cavity\nu0 = [n0]\np0 = (1,1)\nprob = ODEProblem(sys,u0,(0.0,2.0),p0) # End time not in steady state\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Numerically computing the correlation function works in the same way. Note, the initial state of the correlation function depends on the final state of the system. However, in general it does not depend on all the final values of the system. The correct values can be picked out automatically using the correlation_u0 function.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"@named csys = ODESystem(c)\nu0_c = correlation_u0(c, sol.u[end])\nprob_c = ODEProblem(csys,u0_c,(0.0,10.0),p0)\nsol_c = solve(prob_c,RK4(),save_idxs=1)\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Finally, lets check our numerical solution against the analytic one obtained above:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"using Test # hide\ng_analytic(τ) = @. sol.u[end] * exp((im*p0[1]-0.5p0[2])*τ)\n@test isapprox(sol_c.u, g_analytic(sol_c.t), rtol=1e-4)","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Note, that this was a very simple case. Usually the system of equations describing the correlation function is much more complex and depends on multiple other correlation functions (see for example Spectrum of a single atom laser).","category":"page"},{"location":"correlation/#Spectrum","page":"Correlation functions and spectra","title":"Spectrum","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"There are two possible ways two compute the spectrum given a correlation function:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Solving the differential equation needed to obtain g(ttau) and taking the Fourier transform.\nTaking the (symbolic) Laplace transform of the system of equations describing a correlation function.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"On the one hand, the first approach works generally, but is computationally more intense. The second approach, on the other hand, yields a simple linear system of equations which is easy to solve, but only works when the correlation function has been computed starting from the steady state. Both methods can be easily used with QuantumCumulants.jl.","category":"page"},{"location":"correlation/#Numerical-solution-of-g(t,\\tau)","page":"Correlation functions and spectra","title":"Numerical solution of g(ttau)","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"As mentioned above, this approach works generally, regardless of whether the system is in steady state at time t. However, it has some computational drawbacks. Additionally, the spectrum is not always well defined when not in steady state. This approach is the same as the one used in QuantumOptics.jl, and we can borrow the implemented FFT function from there:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"τ = collect(range(0.0, sol_c.t[end], length=101)) # need equidistant list of times for FFT\nusing QuantumOptics.timecorrelations: correlation2spectrum\nω, s = correlation2spectrum(τ, sol_c.(τ))\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The spectrum obtained in this way roughly has a FWHM of κ and is based around the chosen ωc. The fact that the FWHM is not exactly κ illustrates the computation drawback: in order to obtain the correct FWHM we would have to increase the integration time by orders of magnitude. For larger systems, this can be computationally expensive.","category":"page"},{"location":"correlation/#Steady-state:-using-the-Laplace-transform","page":"Correlation functions and spectra","title":"Steady state: using the Laplace transform","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"A useful property of the two-time correlation function is that, if the system is in steady state at time t, then the system of equations is linear, since b(t) can occur at most once in each product. We can therefore write any system of equations describing the correlation function as","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"fracddtau textbfy(tau) = textbfM textbfy(tau) + textbfc","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"where textbfy(tau) is the vector containing the left-hand-side of the correlation function system (g(ttau) equiv y_1(tau)). The matrix textbfM contains coefficients consisting of parameters and steady-state values, and is independent of time, and the vector textbfc includes other constants.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"We define textbfx(s) = mathcalLleft(textbfy(tau)right), i.e. textbfx(s) is the Laplace transform of textbfy(tau) with respect to tau. Applying the Laplace transform to the differential equation above, we obtain","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"(s - textbfM)textbfx(s) = textbfy(0) + fractextbfcs","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The Laplace transform is equivalent to the Fourier transform at the point s=i omega, i.e. the spectrum is given by S(omega) = 2textReleftx_1(iomega)right. Therefore, we can reduce the task to solving the equation","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Atextbfx = b + c","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"where A = iomega - textbfM, b = textbfy(0) and c=textbfc(iomega). In most cases, solving the above matrix equation is much faster than doing an additional time evolution to obtain the correlation function.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"This approach is implemented with the Spectrum type, which performs the Laplace transform and computes the matrix A and the vectors b and c symbolically. Additionally, functions that return all those things in numerical form depending on the steady-state values and given parameters are generated via Symbolics build_function. Usage is as follows:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"c = CorrelationFunction(a', a, me; steady_state=true) # need to specify steady state\nS = Spectrum(c,(ωc,κ))\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The above performs the Laplace transform on a symbolic level (i.e. it derives the matrix A). To actually compute the spectrum, we can do","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"s = S(ω,sol.u[end],p0)\nnothing # hide","category":"page"},{"location":"correlation/#Examples:","page":"Correlation functions and spectra","title":"Examples:","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Mollow Triplet\nSpectrum of a single atom laser","category":"page"},{"location":"symbolic_sums/#Symbolic-Sums-and-Indices","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"Many physical systems contain multiple elements of the same kind, which basically do the same thing just with different rates. For these systems it is convenient to describe the Hamiltonian and the dissipative processes with indexed objects and sums. A well-known example is the Tavis-Cummings Hamiltonian, which describes the interaction of N two-level atoms with a cavity mode according to the Hamiltonian","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"beginequation\nH_mathrmTC = omega_c a^ a + sum_i^N omega_i sigma_i^22 + sum_i^N g_i (a^dagger sigma_i^12 + a sigma_i^21)\nendequation","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"In principle we can write down and derive the equations for all N atoms explicitly, but this can take a long time for large N. The more practical and elegant approach is to derive the equations for averages of indexed operators and insert all possible number combinations afterwards. The implementation of symbolic sums and indices allows for exactly this.","category":"page"},{"location":"symbolic_sums/#Implementation","page":"Symbolic Sums and Indices","title":"Implementation","text":"","category":"section"},{"location":"symbolic_sums/#Index","page":"Symbolic Sums and Indices","title":"Index","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"The main tool to use symbolic summations is the Index object. This object has four different fields, which all need to be specified upon construction. These fields consist of the full HilbertSpace h, a name, which is just a generic symbol, a range, which can either consist of again a symbol or a concrete number, and a specific Hilbert space aon, which defines the space on which operators, that inherit the Index entity, act on. This means that an Index for a NLevelSpace can only be used by Transition operators. In the example below, two indices are defined equivalently, as well as a third one being defined acting on the FockSpace of the defined ProductSpace h.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"using QuantumCumulants\n\n@cnumbers N\n\nha = NLevelSpace(:atoms,2)\nhc = FockSpace(:cavity)\nh = hc ⊗ ha\n\ni = Index(h,:i,N,ha)\ni2 = Index(h,:i,N,2) #equivalent definition\n\nn = Index(h,:n,5,hc)","category":"page"},{"location":"symbolic_sums/#IndexedOperators","page":"Symbolic Sums and Indices","title":"IndexedOperators","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"Operators, such as Destroy or Transition can be associated with an Index of the corresponding Hilbert space by creating a so-called IndexedOperator. This object consists of two fields, namely the operator itself and an Index. Below, there are two IndexedOperator entities created on the two different Hilbert spaces defined previously.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"σ(x,y,z) = IndexedOperator(Transition(h,:σ,x,y),z)\na(z) = IndexedOperator(Destroy(h,:a),z)","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"In the above example, we defined both indexed operators σ and a as callable instances with the attribute-variable z. These can now be used to easily create operators, that act specifically with their associated index.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"a(n)*σ(2,2,i)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"a_n sigma_i^22","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"Similar to operators, one can also create so-called IndexedVariable objects, which consist simply of a name and an index.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"gi = IndexedVariable(:g,i)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"g_i","category":"page"},{"location":"symbolic_sums/#Summations","page":"Symbolic Sums and Indices","title":"Summations","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"As for now, we only created single instances of indexed operators. These operators and variables can now be used to define symbolic summations, which can then again be used in defining a Hamiltonian and deriving equations of motion for specific operator averages. Such a summation needs two arguments to be constructed, the term, over which the summation shall sum over, and an Index, over which the sum runs. As an example, we define below a simple sum over a single indexed operator.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"∑(σ(2,2,i),i)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetioversetNsum σ_i^22","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"As can be seen above, a sum with a single running-index can be created using the ∑ (\\sum) command. Other equivalent functions are Σ (\\Sigma) and the SingleSum() constructor. These constructors can also take a third optional argument specifying a set of indices, which are non equivalent to the summation index.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"j = Index(h,:j,N,2)\n∑(σ(2,2,i),i,[j])\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"underseti j oversetNsum σ_i^22","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"Similar to this one can also create summations over up to two different running-indices:","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"∑(a(n)*σ(2,1,i),i,n)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetioversetNsum undersetnoverset5sum a_n  σ_i^21","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"These two running-indices do not need to act on different Hilbert spaces. In particular, for indices acting on the same Hilbert space, a simplification occurs, as shown below.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"k = Index(h,:k,N,ha)\nl = Index(h,:l,N,ha)\n\n∑(σ(2,1,k)*σ(1,2,l),k,l)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetkneloversetNsum undersetlnekoversetNsum sigma_l^12  sigma_k^21 + undersetkoversetNsum sigma_k^22","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"If two indices, acting on the same Hilbert space, meet inside of a sum, the special case, where the numeric values of both indices are the same, i.e l=k, is calculated immediately. This can also be observed, when a symbolic sum is multiplied with an IndexedOperator that is acting on the same Hilbert space as the summation-index.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"∑(σ(2,2,k),k) * σ(2,1,l)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetkneloversetNsum sigma_k^22  sigma_l^21 + sigma_l^21","category":"page"},{"location":"symbolic_sums/#Short-Example","page":"Symbolic Sums and Indices","title":"Short Example","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"We will briefly go over the entire process of defining a Hamiltonian, the derivation of equations and solving these equations numerically. For this example we will consider N 2-level atoms in a single mode cavity.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"We start by defining all indices and operators and create the Hamiltonian.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"using QuantumCumulants\n\nha = NLevelSpace(:atoms,2)\nhc = FockSpace(:cavity)\nh = hc ⊗ ha\n\n@cnumbers N Δ κ γ ν\n\ni = Index(h,:i,N,ha)\nj = Index(h,:j,N,ha)\n\n@qnumbers b::Destroy(h)\nσ(x,y,z) = IndexedOperator(Transition(h,:σ,x,y),z)\ngi = IndexedVariable(:g,i)\n\nH = Δ*b'*b + ∑(gi*(b*σ(2,1,i) + b'*σ(1,2,i)),i)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"undersetioversetNsum g_i  b  sigma_i^21 + undersetioversetNsum g_i  b^dagger  sigma_i^12 + Delta b^dagger b","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"We continue by defining the starting operators ops, for which the equations are derived, as well as the Jump operators J with their corresponding rates. It is important to note here, that the indexed operators, for which these equations are derived need to have an Index, which is not yet used in the Hamiltonian, jumps or rates. We can then create the first set by simply calling the meanfield function. Note, if an indexed operator J_i is used as jump operator, the following dissipative term is created","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"beginequation\nfrac12 sum_j R_i bigg( 2 J_i^dagger mathcalO J_i - mathcalO J_i^dagger J_i -  J_i^dagger J_i mathcalO bigg)\nendequation","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"The corresponding rate can, but does need to be an indexed variable. However, if it is, then the index of variable needs to match with the operator.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"ops = [b'b, σ(2,2,j)]\nJ = [b, σ(1,2,i), σ(2,1,i)]\nrates = [κ, γ, ν]\n\neqs = meanfield(ops,H,J;rates=rates,order=2)\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"beginalign\nfracddt langle b^dagger  brangle  = 1 i undersetioversetNsum g_i  langle b  sigma_i^21rangle  -1 i undersetioversetNsum g_i  langle b^dagger  sigma_i^12rangle  -10 kappa langle b^dagger  brangle  \nfracddt langle sigma_j^22rangle  = nu + 1 i g_j langle b^dagger  sigma_j^12rangle  -10 gamma langle sigma_j^22rangle  -10 nu langle sigma_j^22rangle  -1 i g_j langle b  sigma_j^21rangle\nendalign","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"We can then complete the set of equations by simply calling the complete function.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"eqs_comp = complete(eqs)\nnothing #hide","category":"page"},{"location":"symbolic_sums/#Evaluate-and-Scale","page":"Symbolic Sums and Indices","title":"Evaluate and Scale","text":"","category":"section"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"The equations still contain symbolic summations and indices. Until now, we did not specify a numerical value for the upper boundaries of the summations, meaning the used N still has no numerical assignment. There are now two different cases to create the set of equations with a specific number of elements. We can either construct all equations for N individual atoms with the function evaluate or we assume that all particles behave identical and create the equations with the function scale. The latter uses the symmetry properties of identical particles, which can substantially reduce the number of equations.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"In this example we use evaluate for N=3 atoms. We can specify the numerical value of N to 3 within the kwarg limits.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"evaled = evaluate(eqs_comp;limits=(N=>3))\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"The last set of equations is now in a form, which can be convert to an ODESystem as defined in ModelingToolkit and be solved numerically with OrdinaryDiffEq. Furthermore we give each atom a different coupling strength g. This can now be done by using the value_map function to create a parameter mapping for the ODEProblem. In this case we give as coupling strength a vector with three different values.","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"# Generate an ODESystem\nusing ModelingToolkit\n@named sys = ODESystem(evaled)\n\n# Solve the system using the OrdinaryDiffEq package\nusing OrdinaryDiffEq\nu0 = zeros(ComplexF64,length(evaled))\np = [Δ, gi, γ, κ, ν]\np0 = [0,[0.75,1.2,1.5],0.25,1,1.5]\np_ = value_map(p,p0;limits=(N=>3))\nprob = ODEProblem(sys,u0,(0.0,10.0),p_)\nsol = solve(prob,RK4())\nnothing #hide","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"Just as with variables in ModelingToolkit, the solution of the respective averages can be accessed with a getindex method. In the following we extract and plot the photon number and the atomic excited state population of each atom by indexing the solution:","category":"page"},{"location":"symbolic_sums/","page":"Symbolic Sums and Indices","title":"Symbolic Sums and Indices","text":"using Plots\nn = real.(sol[b'*b])\npe = [real.(sol[σ(2,2,i)]) for i = 1:3]\npl = plot(sol.t, n, label=\"Photon number\", xlabel=\"t\")\nfor i = 1:3\n    plot!(sol.t, pe[i], label=\"Excited state population of atom $(i)\")\nend\npl # hide","category":"page"},{"location":"examples/mollow/#Mollow-Triplet","page":"Mollow Triplet","title":"Mollow Triplet","text":"","category":"section"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"In the following example, we show how one can compute the resonance spectrum of a single, coherently driven atom. The Hamiltonian describing the system is given by","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"H = -Deltasigma^ee + Omegaleft(sigma^ge + sigma^egright)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"where Delta = omega_ell - omega_a is the detuning between the laser and the atomic resonance frequency and Omega is the Rabi frequency of the laser. The atom is also subject to decay at rate gamma with the damping operator sigma^ge = grangle langle e  projecting it from the excited state erangle  to its ground state grangle.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\nusing ModelingToolkit, OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Obtaining the equations of motion for the system is simple. Note that in this case, we are not actually making any assumptions: in the special case of a single atom (even if it has more than two levels), there exists a simple mapping between the equations of motions for averages and the density operator. In our case, the density operator rho is determined by only two average values, langlesigma^egrangle = rho_eg = rho_ge^*  and langle sigma^eerangle = rho_ee = 1 - rho_gg. In other words, we are solving the master equation component-wise.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"# Hilbert space\nh = NLevelSpace(:atom, (:g,:e))\n\n# Operators\n@cnumbers Δ Ω γ\n@qnumbers σ::Transition(h)\nH = Δ*σ(:e,:e) + Ω*(σ(:g,:e) + σ(:e,:g))\nJ = [σ(:g,:e)]\n\n# Equations\neqs = meanfield([σ(:e,:g),σ(:e,:e)], H, J; rates=[γ])","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"In order to compute the spectrum, we first need to compute the correlation function given by","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"g(tau) = langle sigma^eg(t_0+tau)sigma^ge(t_0)rangle equiv langle sigma^egsigma^ge_0rangle","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"where t_0 is any time after which the original system has reached steady state. Note, that in the second step we simplified the notation by dropping the temporal arguments. The subscript 0 indicates operators given at t_0.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"The correlation function of the system given by eqs can be computed as follows.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"# Correlation Function\nc = CorrelationFunction(σ(:e,:g), σ(:g,:e), eqs; steady_state=true)\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Note that the above actually derives another set of equations, which might take some time. Specifically, it is deriving the equation of motion for g(tau) and automatically completes the system of equation deriving the necessary equations of motion for all average values on which g(tau) depends. Here, the system of equations reads","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"c.de\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"beginalign\nfracddt langle sigma^eg  sigma_0^gerangle  = 10 i langle sigma_0^gerangle  Omega + 10 i Delta langle sigma^eg  sigma_0^gerangle  -20 i Omega langle sigma^ee  sigma_0^gerangle  -05 gamma langle sigma^eg  sigma_0^gerangle  \nfracddt langle sigma^ee  sigma_0^gerangle  = -10 i Omega langle sigma^eg  sigma_0^gerangle  + 10 i Omega langle sigma^ge  sigma_0^gerangle  -10 gamma langle sigma^ee  sigma_0^gerangle  \nfracddt langle sigma^ge  sigma_0^gerangle  = -10 i langle sigma_0^gerangle  Omega -10 i Delta langle sigma^ge  sigma_0^gerangle  + 20 i Omega langle sigma^ee  sigma_0^gerangle  -05 gamma langle sigma^ge  sigma_0^gerangle\nendalign","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"As mentioned above, to compute the time evolution of the system itself, we are effectively solving a master equation. One way to obtain the spectrum would be to solve the system in order to obtain the time evolution of the correlation function, and then take the Fourier transform. However, a computationally more efficient way is to take the Laplace transform of the correlation function directly, which yields a simple linear system of equations. Then we only have to compute a matrix inverse instead of the time evolution to obtain the spectrum.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"In the following, we will use the latter approach:","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"ps = (Δ,Ω,γ)\nS = Spectrum(c,ps)\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"mathcalF(langle σ^eg  σ_0^gerangle )(omega)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Constructing the Spectrum from the correlation function, automatically derives a matrix A and a vector b determining the set of linear equations","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"A(omega)x(omega) = b(omega)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"where the spectrum is then given by the first entry of the solution vector, S(omega)=x_1(omega).","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"To find the spectrum, we first need to compute the time evolution of the system up to steady state.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"@named sys = ODESystem(eqs)\n\np0 = (0.0,2.0,1.0)\nu0 = zeros(ComplexF64, 2)\nprob = ODEProblem(sys,u0,(0.0,20.0),ps .=> p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"plot(sol, vars=((x,y)->(x,real(y)), 0, 2),xlabel=\"γt\", label=\"Excited state population\")","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Now, solving the linear system to obtain the spectrum can simply be done by calling the instance at a range of frequencies, and providing the proper steady-state values and numerical parameters.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"ω = range(-6pi,6pi,length=1001)\ns = S(ω,sol.u[end],p0)\nplot(ω,s,xlabel=\"ω - ωℓ\",label=\"Resonance spectrum\")","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"The resulting spectrum shows a prominent peak at the resonance point (omega=omega_ell=omega_a), but also two more peaks around omega approx pm Omega^2gamma. These two resonances originate from the dressed states. These three peaks are called Mollow Triplet.","category":"page"},{"location":"examples/heterodyne_detection/#Heterodyne-detection-of-emission-from-atomic-ensemble","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"","category":"section"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"This example implements the heterodyne detection of the light emitted by an ensemble of atoms (see https://arxiv.org/abs/2211.13068). We thus describe the stochastic master equation time evolution that governs the measurement backaction on the system. ","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"using QuantumCumulants\nusing SymbolicUtils\nusing Symbolics\nusing ModelingToolkit\nusing StochasticDiffEq\nusing DifferentialEquations\nusing PyPlot\nusing Statistics","category":"page"},{"location":"examples/heterodyne_detection/#System-definition","page":"Heterodyne detection of emission from atomic ensemble","title":"System definition","text":"","category":"section"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"The system we discuss is an ensemble of N equivalent atoms (two level systems with transition operators sigma_12j and frequency omega_a) coupled to a cavity mode hat a, all with the same coupling g and free space decay rate kappa. The cavity has frequency omega_c and decay rate kappa. We are in the frame rotating with the frequency omega_a=omega_c.","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"The system Hamiltonian is then","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"\\begin{equation} H=\\omegac\\hat a^\\dagger\\hat a+\\omegaa\\sumj\\sigma{2,2,j}+\\hat a^\\dagger\\sigma{1,2,j}+g\\hat a\\sigma{2,1,j}. \\end{equation}","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"@cnumbers N ωa γ η χ ωc κ g ξ ωl\n@syms t::Real\n@register pulse(t)\n\nhc = FockSpace(:resonator)\nha = NLevelSpace(:atom,2)\nh = hc ⊗ ha\n\nj = Index(h,:j,N,ha)\nk = Index(h,:k,N,ha)\n\n@qnumbers a::Destroy(h,1)\nσ(α,β,k) = IndexedOperator(Transition(h,:σ,α,β,2), k)\nH = ωc * a' * a + ωa * Σ(σ(2,2,j),j)+g*a'*Σ(σ(1,2,j),j)+g*a*Σ(σ(2,1,j),j);","category":"page"},{"location":"examples/heterodyne_detection/#Decay-terms","page":"Heterodyne detection of emission from atomic ensemble","title":"Decay terms","text":"","category":"section"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"We then include four terms in the Lindblad term of the Master equation. We include spontaneous decay of the cavity mode, where we choose the decay operator to be hat aexp(rmiomega_lt) for convenience (we will see later why this is reasonable and you can convince yourself that it gives the same decay term as hat a). The free dacay of the atoms with gamma is given by the decay operator sigma_12j.","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"We also include an incoherent pump sigma_21j with amplitude eta, which is a pulse that is on between t_0 and t_0+t_1. The last term is a dephasing term with strength chi corresponding to the operator sigma_22j.","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"J = [a*exp(1.0im*ωl*t),σ(1,2,j),σ(2,1,j),σ(2,2,j)]\nrates = [κ,γ,η*pulse(t),2*χ]\n\nfunction pulse(t)\n    if t>t0 && t<t0+t1\n        return 1\n    else\n        return 0\n    end\nend","category":"page"},{"location":"examples/heterodyne_detection/#Stochastic-measurement-terms","page":"Heterodyne detection of emission from atomic ensemble","title":"Stochastic measurement terms","text":"","category":"section"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"We include the measurement terms by defining measurement efficiencies for all decay channels. A channel with efficiency zero is ignored, i.e. not measured. The operator hat aexp(rmiomega_lt) corresponding to heterodyne detection with local oscillator frequency omega_l is then measured with efficiency xi. ","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"Such measurement terms are then included in the equation of motion for system operators is then included as ","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"\\begin{equation} d\\langle\\hat A\\rangle=\\sqrt{\\xi\\kappa/2}\\langle \\hat a^\\dagger \\rm{e}^{-\\rm{i}\\omegalt}\\hat A+\\hat A\\hat a\\rm{e}^{\\rm{i}\\omegalt} -\\hat a\\langle\\hat a \\rm{e}^{\\rm{i}\\omegalt}+\\hat a^\\dagger \\rm{e}^{-\\rm{i}\\omegalt}\\rangle\\rangle \\end{equation}","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"for the operator hat a rme^rmiomega_lt  corresponding to heterodyne detection.","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"efficiencies = [ξ,0,0,0]\nops = [a',a'*a,σ(2,2,k),σ(1,2,k), a*a];\neqs = meanfield(ops,H,J; rates = rates, efficiencies = efficiencies, order = 2)","category":"page"},{"location":"examples/heterodyne_detection/#Finding-the-equations-of-motion","page":"Heterodyne detection of emission from atomic ensemble","title":"Finding the equations of motion","text":"","category":"section"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"The completion and scaling as previously discussed in other examples work exactly the same way for equations including noise terms.","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"eqs_c = indexed_complete(eqs)\nscaled_eqs = scale(eqs_c)","category":"page"},{"location":"examples/heterodyne_detection/#Deterministic-time-evolution","page":"Heterodyne detection of emission from atomic ensemble","title":"Deterministic time evolution","text":"","category":"section"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"Here we define the actual values for the system parameters. We then show that the deterministic time evolution without the noise terms is still accesible by using the constructor ODESystem for the stochastic system of equations and the syntax for the simulation of the time evolution is as usual.","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"ωc_ = 0.0; κ_ = 2.0 * π * 2.26e6; ξ_ = 0.12; N_=5e4; \nωa_ = 0.0; γ_ = 2.0 * π * 375; η_ = 2.0 * π * 20e3; χ_ = 0.1; \ng_ = 6.531*10^3; ωl_ = 2.0 * π * 10^3; t0=0.0;t1=20e-6\np = [N,ωa,γ,η,χ,ωc,κ,g,ξ,ωl]\np0 = [N_,ωa_,γ_,η_,χ_,ωc_,κ_,g_,ξ_,ωl_]\n\n@named sys = ODESystem(scaled_eqs)\nu0 = zeros(ComplexF64,length(scaled_eqs.equations))\nprob = ODEProblem(sys, u0,(0.0,1e-3),p.=>p0)\nsol_det = solve(prob,RK4(),dt=1e-9)\n\nplot(sol_det.t .* 1000, map(x -> real(x[2]), sol_det.u))\nxlim(left = 0.0, right = 0.1)\nylabel(\"Cavity phonon number\")\nxlabel(\"Time (ms)\")","category":"page"},{"location":"examples/heterodyne_detection/#Stochastic-time-evolution","page":"Heterodyne detection of emission from atomic ensemble","title":"Stochastic time evolution","text":"","category":"section"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"The stochastic time evolution is accesible via the constructor SDESystem, whose syntax is exactly the same as for the ODESystem, but with keyword args as defined in https://docs.sciml.ai/DiffEqDocs/stable/tutorials/sde_example/. We then need to provide a noise process for the measurement. If the noise is white the appropriate noise process is a Wiener process. The SDEProblem is then constructed just as the ODEProblem, but with an additional noise argument.","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"We can then make use of the EnsembleProblem which automatically runs multiple instances of the stochastic equations of motion. The number of trajectories can then be set in the solve call. See the documentation cited above for more details of the function calls here.","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"@named sys = SDESystem(scaled_eqs)\nu0 = zeros(ComplexF64,length(scaled_eqs.equations))\nnoise = StochasticDiffEq.RealWienerProcess(0.0, 0.0)\nprob = SDEProblem(sys, u0,(0.0,0.1*1e-3),p.=>p0,noise=noise)\n\neprob = EnsembleProblem(prob)\nsol = solve(eprob,StochasticDiffEq.EM(), dt = 1e-9, save_noise=true,trajectories=256,saveat=0:1e-6:0.1*1e-3)","category":"page"},{"location":"examples/heterodyne_detection/#Plot-the-average-of-the-cavity-number","page":"Heterodyne detection of emission from atomic ensemble","title":"Plot the average of the cavity number","text":"","category":"section"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"Here we plot the average of the cavity number for the stochastic and determinstic equation of motion with the trajectories in grey in the background. We can see that the dynamics of the system is indeed modified by the measurement backaction.","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"us = fill(0.0, length(sol.u), length(sol.u[1].t))\nfor (i, el) in enumerate(sol.u)\n    u = map(x->real(x[2]), el)\n    if length(u) == size(us, 2) us[i,:] .+= u else continue end\n    plot(el.t .* 1000, u, color = \"grey\", alpha = 0.1)\nend\n\nplot(sol.u[1].t .* 1000, mean(us, dims = 1)[1,:], color = \"red\", label = \"stochastic\")\nplot(sol_det.t .* 1000, map(x -> real(x[2]), sol_det.u), color = \"blue\", label = \"deterministic\")\nxlim(left = 0.0, right = 0.1)\nylim(bottom = 0, top = 500)\nylabel(\"Cavity phonon number\")\nxlabel(\"Time (ms)\")\nlegend()","category":"page"},{"location":"examples/heterodyne_detection/#Plot-the-average-of-the-cavity-field-amplitude","page":"Heterodyne detection of emission from atomic ensemble","title":"Plot the average of the cavity field amplitude","text":"","category":"section"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"For the cavity field amplitude we see that the ensemble average becomes zero, but the trajectories have finite cavity field amplitude ","category":"page"},{"location":"examples/heterodyne_detection/","page":"Heterodyne detection of emission from atomic ensemble","title":"Heterodyne detection of emission from atomic ensemble","text":"us = fill(0.0, length(sol.u), length(sol.u[1].t))\nfor (i, el) in enumerate(sol.u)\n    u = map(x->real(x[1]), el)\n    if length(u) == size(us, 2) us[i,:] .+= u else continue end\n    plot(el.t .* 1000, u, color = \"grey\", alpha = 0.05)\nend\n\nplot(sol_det.t .* 1000, map(x -> real(x[1]), sol_det.u), color = \"blue\", label = \"deterministic\")\nplot(sol.u[1].t .* 1000, mean(us, dims = 1)[1,:], color = \"red\", label = \"stochastic\")\nxlim(left = 0.0, right = 0.1)\nylabel(\"Cavity field\")\nxlabel(\"Time (ms)\")\nlegend()","category":"page"},{"location":"examples/unique_squeezing/#Unique-Steady-State-Squeezing","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"","category":"section"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"In this example we show the unique squeezing observed in a driven Dicke model described by N two-level systems coupled to a quantized harmonic oscillator [K. Gietka. et. al., arXiv:2305.14290].  First we present the full dynamics with a second order cumulant expansion. The Hamiltonian describing the system is","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"beginalign\nH = omega a^dagger a + fracOmega2 sum_j  sigma^j_z + fracg2 sum_j  (a^dagger + a) sigma^j_x + eta ( a  e^i omega_d t + a^dagger e^-i omega_d t)\nendalign","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"for N = 1 it describes the driven quantum Rabi model. Additionally the system features a decay channel, losses of the harmonic oscillator with rate kappa.","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"We start by loading the packages.","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"using QuantumCumulants\nusing OrdinaryDiffEq, ModelingToolkit\nusing Plots\nnothing # hide","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"We define the Hilbert space and the symbolic parameters of the system.","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"# Define hilbert space\nhf = FockSpace(:harmonic)\nha = NLevelSpace(Symbol(:spin),2)\nh = hf ⊗ ha\n\n# Paramter\n@cnumbers ω Ω ωd η κ g γ N ξ\n@syms t::Real # time\nnothing # hide","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"On the Hilbert space we create the destroy operator a of the harmonic oscillator and the (indexed) transition operator sigma_i^xy for the i-th two-level system. ","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"@qnumbers a::Destroy(h)\nσ(x,y,i) = IndexedOperator(Transition(h,:σ,x,y),i)\nnothing # hide","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"With the symbolic parameters, operators and indices we define the Hamiltonian and Liouvillian of the system. Note, however, that in the strong coupling regime g sim g_cequiv sqrtomega Omega the driving term and jump operators have to be redefined. For a strongly interacting system, the ground state is very different from the  ground state of a non-interacting system. Therefore, using jump operators of a non-interacting system would lead to extraction of energy from the ground state of a strongly interacting system. The correct operators are the ones that diagonlize the Hamiltonian with adiabatiacally eliminated spins.","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"# Operators diagonalizing the Hamiltonian\nb = a*cosh(ξ) + a'*sinh(ξ) # approximate new eigenmodes of the system \n\n# Indices\ni = Index(h,:i,N,ha)\nj = Index(h,:j,N,ha)\n\n# Hamiltonian\nHf =  ω*a'*a + η*(b'*exp(-1im*ωd*t) + b*exp(1im*ωd*t) )\nHa =  Ω*Σ(σ(2,2,i)-σ(1,1,i),i)/2\nHi =  g*Σ((σ(1,2,i)+σ(2,1,i))*(a + a'),i)/2\nH = Hf + Ha + Hi\n\n# Jump operators & and rates\nJ = [b, σ(1,2,i)]\nrates = [κ, γ]\n\n# symbolic and numeric parameter list\nps = [ω , Ω , ωd , g , η , κ , γ , N , ξ ]\nnothing # hide","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"First we derive the mean-field equations in second order for langle a rangle, langle a^dagger a rangle and langle sigma^22_j rangle, then we complete the system to obtain a closed set of equations.","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"eqs = meanfield([a, a'a, σ(2,2,j)],H,J;rates=rates,order=2)\nnothing # hide","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"beginalign\nfracddt langle arangle  = -05 i left( undersetioversetNsum g  langle sigma_i^12rangle  + undersetioversetNsum g  langle sigma_i^21rangle  right) -1 i omega langle arangle  -1 i eta sinhleft( xi right) e^1 i t omegad -1 i eta e^-1 i t omegad cosh(xi)^* -05 kappa coshleft( xi right) langle arangle  cosh(xi)^* + 05 kappa sinhleft( xi right) langle arangle  sinh(xi)^* \nfracddt langle a^dagger  arangle  = 05 i left( undersetioversetNsum g  langle a  sigma_i^12rangle  + undersetioversetNsum g  langle a  sigma_i^21rangle  right) -05 i left( undersetioversetNsum g  langle a^dagger  sigma_i^12rangle  + undersetioversetNsum g  langle a^dagger  sigma_i^21rangle  right) + kappa sinhleft( xi right) sinh(xi)^* + kappa sinhleft( xi right) sinh(xi)^* langle a^dagger  arangle  -1 i eta sinhleft( xi right) langle a^daggerrangle  e^1 i t omegad + 1 i eta coshleft( xi right) langle arangle  e^1 i t omegad -1 i eta langle a^daggerrangle  e^-1 i t omegad cosh(xi)^* + 1 i eta langle arangle  e^-1 i t omegad sinh(xi)^* -10 kappa coshleft( xi right) cosh(xi)^* langle a^dagger  arangle  \nfracddt langle sigma_j^22rangle  = -10 gamma langle sigma_j^22rangle  -05 i g left( langle a^dagger  sigma_j^21rangle  + langle a  sigma_j^21rangle  right) + 05 i g left( langle a^dagger  sigma_j^12rangle  + langle a  sigma_j^12rangle  right)\nendalign","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"eqs_c = complete(eqs)\nlength(eqs_c)","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"All two-level systems behave identically, due to this permutation symmetry of the system we can scale-up the equations.","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"eqs_sc = scale(eqs_c)\nscale(eqs) # Example scaling on the first three equations\nnothing # hide","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"beginalign\nfracddt langle arangle  = -05 i left( N g langle sigma_1^21rangle  + N g langle sigma_1^12rangle  right) -1 i omega langle arangle  -1 i eta sinhleft( xi right) e^1 i t omegad -1 i eta e^-1 i t omegad cosh(xi)^* -05 kappa coshleft( xi right) langle arangle  cosh(xi)^* + 05 kappa sinhleft( xi right) langle arangle  sinh(xi)^* \nfracddt langle a^dagger  arangle  = -05 i left( N g langle a^dagger  sigma_1^21rangle  + N g langle a^dagger  sigma_1^12rangle  right) + 05 i left( N g langle a  sigma_1^21rangle  + N g langle a  sigma_1^12rangle  right) + kappa sinhleft( xi right) sinh(xi)^* + kappa sinhleft( xi right) sinh(xi)^* langle a^dagger  arangle  -1 i eta sinhleft( xi right) langle a^daggerrangle  e^1 i t omegad + 1 i eta coshleft( xi right) langle arangle  e^1 i t omegad -1 i eta langle a^daggerrangle  e^-1 i t omegad cosh(xi)^* + 1 i eta langle arangle  e^-1 i t omegad sinh(xi)^* -10 kappa coshleft( xi right) cosh(xi)^* langle a^dagger  arangle  \nfracddt langle sigma_1^22rangle  = -05 i g left( langle a^dagger  sigma_1^21rangle  + langle a  sigma_1^21rangle  right) + 05 i g left( langle a^dagger  sigma_1^12rangle  + langle a  sigma_1^12rangle  right) -10 gamma langle sigma_1^22rangle \nendalign","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"To calculate the dynamics of the system we create a system of ordinary differential equations with its initial state and numerical parameters.","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"# symbolic ordinary differential equation system\n@named sys = ODESystem(eqs_sc)\n\n# initial state \nu0 = zeros(ComplexF64, length(eqs_sc));\n\n# Parameters\nω_ = 1.0\nΩ_ = 2e3ω_\ngc_ = sqrt(Ω_*ω_/N) # renormalization of coupling to keep the system intensive\ng_ = 0.9gc_\nη_ = 4ω_\nκ_ = ω_\nγ_ = ω_\nωd_ = sqrt(1-g_^2/gc_^2)*ω_\nξ_ = 1/4*log(1-N*g_^2/(ω_*Ω_))\nnothing # hide","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"We solve the dynamics for four different numbers of two-level systems N = 1 2 10 100.","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"sol_ls = []\nN_ls = [1,2,10,100]\nfor N_ in N_ls\n    p0 = [ω_, Ω_, ωd_, g_, η_, κ_, γ_, N_, ξ_]\n    prob = ODEProblem(sys,u0,(0.0, 4π/ωd_), ps.=>p0)\n    sol = solve(prob,Tsit5(); saveat=π/30ωd_ ,reltol=1e-10,abstol=1e-10)\n    push!(sol_ls,sol)\nend","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"# plot results\nc_ls=[:black, :red, :blue, :cyan]\np1 = plot(xlabel=\"ω t\", ylabel=\"Δ² O\")\np2 = plot(xlabel=\"ω t\", ylabel=\"⟨σz⟩\")\nfor i=1:length(N_ls)\n    sol = sol_ls[i]\n    t_ = sol.t\n    \n    sqx = sol[a'*a'] + sol[a*a] + 2*sol[a'*a] .+ 1 - (sol[a'] + sol[a]).^2\n    sqy = sol[a'*a'] + sol[a*a] - 2*sol[a'*a] .- 1 - (sol[a'] - sol[a]).^2\n    plot!(p1,t_,real.(sqx),label=\"N = $(N_ls[i])\",color=c_ls[i]) \n    plot!(p1,t_,-real.(sqy),ls=:dash,label=nothing,color=c_ls[i])\n\n    s22 = sol[σ(2,2,1)] \n    plot!(p2,t_,real.(2s22 .- 1),color=c_ls[i],label=nothing)\nend\nplot(p1, p2, layout=(1,2), size=(700,250),bottom_margin=5*Plots.mm, left_margin=5*Plots.mm)","category":"page"},{"location":"examples/unique_squeezing/#Effective-model","page":"Unique Steady-State Squeezing","title":"Effective model","text":"","category":"section"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"For a suffeciently low excitation we can adiabatically elminate the dynamics of the two-level system(s). This leads to an effective Hamiltonian ","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"beginalign\nH_mathrma = omega a^dagger a - fracg^24 Omega(a + a^dagger)^2 + eta ( a  e^i omega_d  t + a^dagger e^-i omega_d  t)\nendalign","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"We calculate now the dynamics for this effective model and compare it with the full system. Note that this Hamiltonian is quadratic, which means that a second order description is exact. ","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"# effective Hamiltonian\n@cnumbers gΩ # g^2/4Ω\nH_a = Hf - N*gΩ*(a + a')^2 # N is added for the sake of intensitivity\n\neqs_a = meanfield([a, a'a, a*a],H_a,[b];rates=[κ],order=2)\nnothing # hide","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"beginalign\nfracddt langle arangle  = -1 i omega langle arangle  + 2 i N gOmega left( langle a^daggerrangle  + langle arangle  right) -1 i eta sinhleft( xi right) e^1 i t omegad -1 i eta e^-1 i t omegad cosh(xi)^* -05 kappa coshleft( xi right) langle arangle  cosh(xi)^* + 05 kappa sinhleft( xi right) langle arangle  sinh(xi)^* \nfracddt langle a^dagger  arangle  = kappa sinhleft( xi right) sinh(xi)^* + 2 i N gOmega langle a^dagger  a^daggerrangle  -2 i N gOmega langle a  arangle  + kappa sinhleft( xi right) sinh(xi)^* langle a^dagger  arangle  -1 i eta sinhleft( xi right) langle a^daggerrangle  e^1 i t omegad + 1 i eta coshleft( xi right) langle arangle  e^1 i t omegad -1 i eta langle a^daggerrangle  e^-1 i t omegad cosh(xi)^* + 1 i eta langle arangle  e^-1 i t omegad sinh(xi)^* -10 kappa coshleft( xi right) cosh(xi)^* langle a^dagger  arangle  \nfracddt langle a  arangle  = 2 i N gOmega -2 i omega langle a  arangle  + 4 i N gOmega left( langle a^dagger  arangle  + langle a  arangle  right) -10 kappa sinhleft( xi right) cosh(xi)^* + kappa sinhleft( xi right) sinh(xi)^* langle a  arangle  -10 kappa coshleft( xi right) cosh(xi)^* langle a  arangle  -2 i eta sinhleft( xi right) langle arangle  e^1 i t omegad -2 i eta langle arangle  e^-1 i t omegad cosh(xi)^*\nendalign","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"# symbolic ordinary differential equation system\n@named sys_a = ODESystem(eqs_a)\n\n# initial state \nu0_a = zeros(ComplexF64, length(eqs_a))\n\n# Additional parameter\ngΩ_ = g_^2/(4Ω_)\nN_ = 69 # the final result does not depend on N\n\n# symbolic and numeric parameter list\nps_a = [ω , ωd , η , κ , N , g , Ω , ξ , gΩ ]\np0_a = [ω_, ωd_, η_, κ_, N_, g_, Ω_, ξ_, gΩ_]\n\n# define and solve numeric ordinary differential equation problem\nprob_a = ODEProblem(sys_a,u0_a,(0.0, 4π/ωd_), ps_a.=>p0_a)\nsol_a = solve(prob_a,Tsit5(); saveat=π/30ωd_, reltol=1e-8,abstol=1e-8)\nnothing # hide","category":"page"},{"location":"examples/unique_squeezing/","page":"Unique Steady-State Squeezing","title":"Unique Steady-State Squeezing","text":"# plot results\nsol = sol_ls[4]\nt_ = sol.t\nsqx = sol[a'*a'] + sol[a*a] + 2*sol[a'*a] .+ 1 - (sol[a'] + sol[a]).^2\nsqy = sol[a'*a'] + sol[a*a] - 2*sol[a'*a] .- 1 - (sol[a'] - sol[a]).^2\n\nt_a = sol_a.t\nsqx_a = sol_a[a'*a'] + sol_a[a*a] + 2*sol_a[a'*a] .+ 1 - (sol_a[a'] + sol_a[a]).^2\nsqy_a = sol_a[a'*a'] + sol_a[a*a] - 2*sol_a[a'*a] .- 1 - (sol_a[a'] - sol_a[a]).^2\n\np = plot(xlabel=\"ω t\", ylabel=\"Δ² O\")\nplot!(p,t_,real.(sqx),label=\"X - Full model\") \nplot!(p,t_,-real.(sqy),label=\"P - Full model\",ls=:dash)\nplot!(p,t_a,real.(sqx_a),label=\"X - Effective model\") \nplot!(p,t_a,-real.(sqy_a),label=\"P - Effective model\",ls=:dash)\nplot(p, size=(500,200))","category":"page"},{"location":"examples/cavity_antiresonance_indexed/#Cavity-Antiresonance","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"","category":"section"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"In this example we investigate a system of N closely spaced quantum emitters inside a coherently driven single mode cavity. The model is descriped in D. Plankensteiner, et. al., Phys. Rev. Lett. 119, 093601 (2017). The Hamiltonian of this system is composed of three parts H = H_c + H_a + H_mathrmint, the driven cavity H_c, the dipole-dipole interacting atoms H_a and the atom-cavity interaction H_mathrmint:","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"beginalign\nH_mathrmc = hbar Delta_c a^dagger a + hbar eta (a^dagger + a) \n\nH_a = hbar Delta_a sumlimits_j sigma_j^22 + hbar sumlimits_i neq j Omega_ij sigma_i^21 sigma_j^12\n\nH_mathrmint = hbar sumlimits_j g_j (a^dagger sigma_j^12 + a sigma_j^21)\nendalign","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"Additionally the system features two decay channels, the lossy cavity with photon decay rate kappa and collective atomic emission described by the decay-rate matrix Gamma_ij.","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"We start by loading the packages.","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"using QuantumCumulants\nusing OrdinaryDiffEq, SteadyStateDiffEq, ModelingToolkit\nusing Plots","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"The Hilbert space for this system is given by one cavity mode and N two-level atoms. Here we use symbolic indices, sums and double sums to define the system. The parameters g_j  Gamma_ij and Omega_ij are defined as indexed variables of atom i and j. We will describe the system in first order mean-field.","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"# Hilbert space\nhc = FockSpace(:cavity)\nha = NLevelSpace(Symbol(:atom),2)\nh = hc ⊗ ha\n\n# Parameter\n@cnumbers N Δc η Δa κ\ng(i) = IndexedVariable(:g,i)\nΓ(i,j) = IndexedVariable(:Γ,i,j)\nΩ(i,j) = IndexedVariable(:Ω,i,j;identical=false)\n\n# Indices\ni = Index(h,:i,N,ha)\nj = Index(h,:j,N,ha)","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"The kwarg ’identical=false’ for the double indexed variable specifies that Omega_ij = 0 for i = j. Now we create the operators on the composite Hilbert space using the textttIndexedOperator constructor, which assigns each textttTransition operator an textttIndex.","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"@qnumbers a::Destroy(h)\nσ(x,y,k) = IndexedOperator(Transition(h,:σ,x,y),k)\nnothing # hide","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"We define the Hamiltonian and Liouvillian. For the collective atomic decay we write the corresponding dissipative processes with a double indexed variable R_ij and an indexed jump operator J_j, such that an operator average langle mathcalO rangle follows the equation","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"beginequation\nlangle dotmathcalO rangle = sum_ij R_ij left( langle J_i^dagger mathcalO J_j rangle - frac12 langle J_i^dagger J_j mathcalO rangle - frac12 langle mathcalO J_i^dagger J_j rangle right)\nendequation","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"# Hamiltonian\nHc = Δc*a'a + η*(a' + a)\nHa = Δa*Σ(σ(2,2,i),i) + Σ(Ω(i,j)*σ(2,1,i)*σ(1,2,j),j,i)\nHi = Σ(g(i)*(a'*σ(1,2,i) + a*σ(2,1,i)),i)\nH = Hc + Ha + Hi\n\n# Jump operators & and rates\nJ = [a, σ(1,2,i)]\nrates = [κ, Γ(i,j)]\nnothing # hide","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"We derive the system of equations in first order mean-field.","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"eqs = meanfield(a,H,J;rates=rates,order=1)\ncomplete!(eqs)\nnothing # hide","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"beginalign\nfracddt langle arangle  = -1 i eta -1 i undersetioversetNsum g_i  langle sigma_i^12rangle  -05 kappa langle arangle  -1 i Deltac langle arangle  \nfracddt langle sigma_k^12rangle  = undersetjnekoversetNsum Gamma_kj  langle sigma_j^12rangle   langle sigma_k^22rangle  -05 undersetjoversetNsum Gamma_kj  langle sigma_j^12rangle  -1 i undersetjneikoversetNsum Omega_kj  langle sigma_j^12rangle  + 2 i undersetjneikoversetNsum Omega_kj  langle sigma_j^12rangle   langle sigma_k^22rangle  -1 i g_k langle arangle  -1 i Deltaa langle sigma_k^12rangle  + 2 i g_k langle arangle  langle sigma_k^22rangle  \nfracddt langle sigma_k^22rangle  = -05 undersetinejkoversetNsum Gamma_ik  langle sigma_i^21rangle   langle sigma_k^12rangle  + 1 i undersetinejkoversetNsum Omega_ik  langle sigma_i^21rangle   langle sigma_k^12rangle  -1 i undersetjneikoversetNsum Omega_kj  langle sigma_k^21rangle   langle sigma_j^12rangle  -05 undersetjnekoversetNsum Gamma_kj  langle sigma_k^21rangle   langle sigma_j^12rangle  -10 Gamma_kk langle sigma_k^22rangle  -1 i g_k langle arangle  langle sigma_k^21rangle  + 1 i g_k langle a^daggerrangle  langle sigma_k^12rangle\nendalign","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"To create the equations for a specific number of atoms we use the function textttevaluate.","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"N_ = 2\neqs_ = evaluate(eqs;limits=(N=>N_))\n@named sys = ODESystem(eqs_)\nnothing # hide","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"Finally we need to define the initial state of the system and the numerical parameters. In the end we want to obtain the transmission rate T of our system. For this purpose we calculate the steady state photon number in the cavity langle a rangle^2 for different laser frequencies.","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"u0 = zeros(ComplexF64, length(eqs_))\n# parameter\nΓ_ = 1.0\nd = 2π*0.08 #0.08λ\nθ = π/2\n\nΩij(i,j) = i==j ? 0 : Γ_*(-3/4)*( (1-(cos(θ))^2)*cos(d)/d-(1-3*(cos(θ))^2)*(sin(d)/(d^2)+(cos(d)/(d^3))) )\nΓij(i,j) = i==j ? Γ_ : Γ_*(3/2)*( (1-(cos(θ))^2)*sin(d)/d+(1-3*(cos(θ))^2)*((cos(d)/(d^2))-(sin(d)/(d^3))))\n\ng_ = 2Γ_\nκ_ = 20Γ_\nΔa_ = 0Γ_\nΔc_ = 0Γ_\nη_ = κ_/100\n\ngi_ls = [g(i) for i=1:N_]\nΓij_ls = [Γ(i,j) for i = 1:N_ for j=1:N_]\nΩij_ls = [Ω(i,j) for i = 1:N_ for j=1:N_ if i≠j]\n\n# list of symbolic indexed parameters\ngi_ = [g_*(-1)^i for i=1:N_]\nΓij_ = [Γij(i,j) for i = 1:N_ for j=1:N_]\nΩij_ = [Ωij(i,j) for i = 1:N_ for j=1:N_ if i≠j]\n\nps = [Δc; η; Δa; κ; gi_ls; Γij_ls; Ωij_ls]\np0 = [Δc_; η_; Δa_; κ_; gi_; Γij_; Ωij_]\nnothing # hide","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"Δ_ls = [-10:0.05:10;]Γ_\nn_ls = zeros(length(Δ_ls))\n\n# definitions for fast replacement of numerical parameter\nprob = ODEProblem(sys,u0,(0.0, 20Γ_), ps.=>p0)\nprob_ss = SteadyStateProblem(prob)\np_sys = parameters(sys)\np_idx = [findfirst(isequal(p), ps) for p∈p_sys]\n\nfor i=1:length(Δ_ls)\n    Δc_i = Δ_ls[i]\n    Δa_i = Δc_i + Ωij(1,2) # cavity on resonace with the shifted collective emitter\n    p0_ = [Δc_i; η_; Δa_i; κ_; gi_; Γij_; Ωij_]\n\n    # create new SteadyStateProblem\n    prob_ss_ = remake(prob_ss, p=p0_[p_idx])\n    sol_ss = solve(prob_ss_, DynamicSS(Tsit5(); abstol=1e-8, reltol=1e-8),\n        reltol=1e-14, abstol=1e-14, maxiters=5e7)\n    n_ls[i] = abs2(sol_ss[a])\nend\nnothing #hide","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"The transmission rate T with respect to the pump laser detuning is given by the relative steady state intra-cavity photon number n(Delta)n_mathrmmax. We qualitatively reproduce the antiresonance from D. Plankensteiner, et. al., Phys. Rev. Lett. 119, 093601 (2017) for two atoms.","category":"page"},{"location":"examples/cavity_antiresonance_indexed/","page":"Cavity Antiresonance","title":"Cavity Antiresonance","text":"T = n_ls ./ maximum(n_ls)\nplot(Δ_ls, T, xlabel=\"Δ/Γ\", ylabel=\"T\", legend=false)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-Hilbert-Spaces","page":"API","title":"Hilbert Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HilbertSpace","category":"page"},{"location":"api/#QuantumCumulants.HilbertSpace","page":"API","title":"QuantumCumulants.HilbertSpace","text":"HilbertSpace\n\nAbstract type for representing Hilbert spaces.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"ProductSpace","category":"page"},{"location":"api/#QuantumCumulants.ProductSpace","page":"API","title":"QuantumCumulants.ProductSpace","text":"ProductSpace <: HilbertSpace\n\nStores a composite HilbertSpace consisting of multiple subspaces. Generally created by computing the tensor product ⊗ of subspaces.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"FockSpace","category":"page"},{"location":"api/#QuantumCumulants.FockSpace","page":"API","title":"QuantumCumulants.FockSpace","text":"FockSpace <: HilbertSpace\n\nHilbertSpace defining a Fock space for bosonic operators. See also: Destroy, Create\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"NLevelSpace","category":"page"},{"location":"api/#QuantumCumulants.NLevelSpace","page":"API","title":"QuantumCumulants.NLevelSpace","text":"NLevelSpace <: HilbertSpace\nNLevelSpace(name::Symbol,levels,GS=levels[1])\n\nDefine a HilbertSpace for an object consisting of N discrete energy levels. The given levels must be an integer specifying the number of levels, or an iterable collection of levels. The argument GS specifies which state should be treated as ground state and is rewritten using population conservation during simplification. See also: Transition\n\nExamples:\n\njulia> ha = NLevelSpace(:a,3)\nℋ(a)\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nℋ(a)\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"ClusterSpace","category":"page"},{"location":"api/#QuantumCumulants.ClusterSpace","page":"API","title":"QuantumCumulants.ClusterSpace","text":"ClusterSpace <: HilbertSpace\nClusterSpace(original_space,N,order)\n\nA Hilbert space representing N identical copies of another Hilbert space, with correlations up to a specified order.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"⊗","category":"page"},{"location":"api/#QuantumInterface.:⊗","page":"API","title":"QuantumInterface.:⊗","text":"⊗(spaces::HilbertSpace...)\n\nCreate a ProductSpace consisting of multiple subspaces. Unicode \\otimes<tab> alias of tensor\n\nExamples\n\njulia> hf = FockSpace(:f)\nℋ(f)\n\njulia> ha = NLevelSpace(:a,2)\nℋ(a)\n\njulia> h = hf⊗ha\nℋ(f) ⊗ ℋ(a)\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"tensor","category":"page"},{"location":"api/#QuantumInterface.tensor","page":"API","title":"QuantumInterface.tensor","text":"tensor(spaces::HilbertSpace...)\n\nCreate a ProductSpace consisting of multiple subspaces. See also ⊗.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"SpinSpace","category":"page"},{"location":"api/#QuantumCumulants.SpinSpace","page":"API","title":"QuantumCumulants.SpinSpace","text":"SpinSpace <: HilbertSpace\n\nHilbertSpace defining a Spin space for two-level atom operators. See also: Sigma, Create\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Sigma","category":"page"},{"location":"api/#QuantumCumulants.Sigma","page":"API","title":"QuantumCumulants.Sigma","text":"Spin <: QSym\n\nSpin operator on a SpinSpace representing the sigma-operators σx, σy and σz for two-level spin systems.  The field axis represents x, y and z as 1, 2 and 3, repectively.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Operators","page":"API","title":"q-Numbers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"QSym","category":"page"},{"location":"api/#QuantumCumulants.QSym","page":"API","title":"QuantumCumulants.QSym","text":"QSym <: QNumber\n\nAbstract type representing fundamental operator types.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"QTerm","category":"page"},{"location":"api/#QuantumCumulants.QTerm","page":"API","title":"QuantumCumulants.QTerm","text":"QTerm <: QNumber\n\nAbstract type representing noncommutative expressions.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"@qnumbers","category":"page"},{"location":"api/#QuantumCumulants.@qnumbers","page":"API","title":"QuantumCumulants.@qnumbers","text":"@qnumbers\n\nConvenience macro for the construction of operators.\n\nExamples\n\njulia> h = FockSpace(:fock)\nℋ(fock)\n\njulia> @qnumbers a::Destroy(h)\n(a,)\n\njulia> h = FockSpace(:one) ⊗ FockSpace(:two)\nℋ(one) ⊗ ℋ(two)\n\njulia> @qnumbers b::Destroy(h,2)\n(b,)\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"Destroy","category":"page"},{"location":"api/#QuantumCumulants.Destroy","page":"API","title":"QuantumCumulants.Destroy","text":"Destroy <: QSym\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator annihilation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Create","category":"page"},{"location":"api/#QuantumCumulants.Create","page":"API","title":"QuantumCumulants.Create","text":"Create <: QSym\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator creation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Transition","category":"page"},{"location":"api/#QuantumCumulants.Transition","page":"API","title":"QuantumCumulants.Transition","text":"Transition <: QSym\nTransition(h::NLevelSpace,name::Symbol,i,j)\n\nFundamental operator defining a transition from level j to level i on a NLevelSpace. The notation corresponds to Dirac notation, i.e. the above is equivalent to |i⟩⟨j|.\n\nExamples\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nℋ(a)\n\njulia> σ = Transition(ha,:σ,:g,:e)\nσge\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Meanfield","page":"API","title":"Mean field","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"meanfield","category":"page"},{"location":"api/#QuantumCumulants.meanfield","page":"API","title":"QuantumCumulants.meanfield","text":"meanfield(ops::Vector,H::QNumber)\nmeanfield(op::QNumber,H::QNumber)\n\nmeanfield(ops::Vector,H::QNumber,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\nmeanfield(op::QNumber,H::QNumber,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\n\nCompute the set of equations for the operators in ops under the Hamiltonian H and with loss operators contained in J. The resulting equation is equivalent to the Quantum-Langevin equation where noise is neglected.\n\nArguments\n\n*ops::Vector: The operators of which the equations are to be computed. *H::QNumber: The Hamiltonian describing the reversible dynamics of the     system. *J::Vector{<:QNumber}: A vector containing the collapse operators of     the system. A term of the form     sum_i J_i^dagger O J_i - frac12left(J_i^dagger J_i O + OJ_i^dagger J_iright)     is added to the Heisenberg equation.\n\nOptional argumentes\n\n*Jdagger::Vector=adjoint.(J): Vector containing the hermitian conjugates of     the collapse operators. *rates=ones(length(J)): Decay rates corresponding to the collapse operators in J. *multithread=false: Specify whether the derivation of equations for all operators in ops     should be multithreaded using Threads.@threads. *simplify=true: Specify whether the derived equations should be simplified. *order=nothing: Specify to which order a cumulant_expansion is performed.     If nothing, this step is skipped. *mix_choice=maximum: If the provided order is a Vector, mix_choice determines     which order to prefer on terms that act on multiple Hilbert spaces. *iv=SymbolicUtils.Sym{Real}(:t): The independent variable (time parameter) of the system.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"commutator","category":"page"},{"location":"api/#QuantumCumulants.commutator","page":"API","title":"QuantumCumulants.commutator","text":"commutator(a,b)\n\nComputes the commutator a*b - b*a.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"acts_on","category":"page"},{"location":"api/#QuantumCumulants.acts_on","page":"API","title":"QuantumCumulants.acts_on","text":"acts_on(op)\n\nShows on which Hilbert space op acts. For QSym types, this returns an Integer, whereas for a Term it returns a Vector{Int} whose entries specify all subspaces on which the expression acts.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"MeanfieldEquations","category":"page"},{"location":"api/#QuantumCumulants.MeanfieldEquations","page":"API","title":"QuantumCumulants.MeanfieldEquations","text":"MeanfieldEquations <: AbstractMeanfieldEquations\n\nType defining a system of differential equations, where lhs is a vector of derivatives and rhs is a vector of expressions. In addition, it keeps track of the Hamiltonian, the collapse operators and the corresponding decay rates of the system.\n\nFields\n\n*equations: Vector of the differential equations of averages. *operator_equations: Vector of the operator differential equations. *states: Vector containing the averages on the left-hand-side of the equations. *operators: Vector containing the operators on the left-hand-side of the equations. *hamiltonian: Operator defining the system Hamiltonian. *jumps: Vector of operators specifying the decay processes. *jumps: Vector of operators specifying the adjoint of the decay processes. *rates: Decay rates corresponding to the jumps. *iv: The independent variable (time parameter) of the system. *varmap: Vector of pairs that map the averages to time-dependent variables.     That format is necessary for ModelingToolkit functionality. *order: The order at which the cumulant_expansion has been performed.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Symbolic-numbers","page":"API","title":"Symbolic Numbers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CNumber","category":"page"},{"location":"api/#QuantumCumulants.CNumber","page":"API","title":"QuantumCumulants.CNumber","text":"CNumber <: Number\n\nAbstract type for all symbolic numbers, i.e. Parameter, average.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Parameter","category":"page"},{"location":"api/#QuantumCumulants.Parameter","page":"API","title":"QuantumCumulants.Parameter","text":"Parameter <: CNumber\n\nType used as symbolic type in a SymbolicUtils.Sym variable to represent a parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"cnumbers","category":"page"},{"location":"api/#QuantumCumulants.cnumbers","page":"API","title":"QuantumCumulants.cnumbers","text":"cnumbers(symbols::Symbol...)\ncnumbers(s::String)\n\nCreate symbolic cnumbers.\n\nExpamples\n\njulia> ps = cnumbers(:a, :b)\n(a, b)\n\njulia> cnumbers(\"a b\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"cnumber","category":"page"},{"location":"api/#QuantumCumulants.cnumber","page":"API","title":"QuantumCumulants.cnumber","text":"cnumber(symbols::Symbol)\ncnumber(s::String)\n\nCreate symbolic cnumber.\n\nExpamples\n\njulia> ps = cnumber(:a)\na\n\njulia> cnumber(\"a\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"@cnumbers","category":"page"},{"location":"api/#QuantumCumulants.@cnumbers","page":"API","title":"QuantumCumulants.@cnumbers","text":"@cnumbers(ps...)\n\nConvenience macro to quickly define symbolic cnumbers.\n\nExamples\n\njulia> @cnumbers ω κ\n(ω, κ)\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"RNumber","category":"page"},{"location":"api/#QuantumCumulants.RNumber","page":"API","title":"QuantumCumulants.RNumber","text":"RNumber <: Real\n\nAbstract type for real symbolic numbers RealParameter.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"RealParameter","category":"page"},{"location":"api/#QuantumCumulants.RealParameter","page":"API","title":"QuantumCumulants.RealParameter","text":"RealParameter <: RNumber\n\nType used as symbolic type in a SymbolicUtils.Sym variable to represent a real parameter.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"rnumbers","category":"page"},{"location":"api/#QuantumCumulants.rnumbers","page":"API","title":"QuantumCumulants.rnumbers","text":"rnumbers(symbols::Symbol...)\nrnumbers(s::String)\n\nCreate symbolic rnumbers.\n\nExpamples\n\njulia> ps = rnumbers(:a, :b)\n(a, b)\n\njulia> rnumbers(\"a b\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"rnumber","category":"page"},{"location":"api/#QuantumCumulants.rnumber","page":"API","title":"QuantumCumulants.rnumber","text":"rnumber(symbols::Symbol)\nrnumber(s::String)\n\nCreate symbolic rnumber.\n\nExpamples\n\njulia> ps = rnumber(:a)\na\n\njulia> rnumber(\"a\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"@rnumbers","category":"page"},{"location":"api/#QuantumCumulants.@rnumbers","page":"API","title":"QuantumCumulants.@rnumbers","text":"@rnumbers(ps...)\n\nConvenience macro to quickly define symbolic rnumbers.\n\nExamples\n\njulia> @rnumbers ω κ\n(ω, κ)\n\n\n\n\n\n","category":"macro"},{"location":"api/#API:-Average","page":"API","title":"Average","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"average","category":"page"},{"location":"api/#QuantumCumulants.average","page":"API","title":"QuantumCumulants.average","text":"average(::QNumber)\naverage(::QNumber,order)\n\nCompute the average of an operator. If order is given, the cumulant_expansion up to that order is computed immediately.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"cumulant_expansion","category":"page"},{"location":"api/#QuantumCumulants.cumulant_expansion","page":"API","title":"QuantumCumulants.cumulant_expansion","text":"cumulant_expansion(avg, order::Int)\n\nFor an average of an operator, expand it in terms of moments up to order neglecting their joint cumulant.\n\nSee also: https://en.wikipedia.org/wiki/Cumulant#Joint_cumulants\n\nExamples\n\njulia> avg = average(a*b)\n⟨a*b⟩\n\njulia> cumulant_expansion(avg,1)\n(⟨a⟩*⟨b⟩)\n\njulia> avg = average(a*b*c)\n⟨a*b*c⟩\n\njulia> cumulant_expansion(avg,2)\n((⟨a*b⟩*⟨c⟩)+(⟨a*c⟩*⟨b⟩)+(⟨a⟩*⟨b*c⟩)+(-2*⟨a⟩*⟨b⟩*⟨c⟩))\n\nOptional arguments\n\n*simplify=true: Specify whether the result should be simplified. *kwargs...: Further keyword arguments being passed to simplification.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"cumulant","category":"page"},{"location":"api/#QuantumCumulants.cumulant","page":"API","title":"QuantumCumulants.cumulant","text":"cumulant(x,n=get_order(x);simplify=true,kwargs...)\n\nCompute the nth cumulant of x (either an operator or an average). The output is simplified when simplify=true. Further keyword arguments are passed on to simplification.\n\nExamples\n\njulia> cumulant(a)\n⟨a⟩\n\njulia> cumulant(a*b)\n(⟨a*b⟩+(-1*⟨a⟩*⟨b⟩))\n\njulia> cumulant(a*b,1)\n⟨a*b⟩\n\njulia> cumulant(a*b,3)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_order","category":"page"},{"location":"api/#QuantumCumulants.get_order","page":"API","title":"QuantumCumulants.get_order","text":"get_order(arg)\n\nCompute the order of a given argument. This is the order used to decide whether something should be expanded using a cumulant_expansion method.\n\nExamples\n\njulia> get_order(a)\n1\n\njulia> get_order(a*b)\n2\n\njulia> get_order(1)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-correlation","page":"API","title":"Correlation functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CorrelationFunction","category":"page"},{"location":"api/#QuantumCumulants.CorrelationFunction","page":"API","title":"QuantumCumulants.CorrelationFunction","text":"struct CorrelationFunction\n\nType representing the two-time first-order correlation function of two operators.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Spectrum","category":"page"},{"location":"api/#QuantumCumulants.Spectrum","page":"API","title":"QuantumCumulants.Spectrum","text":"struct Spectrum\n\nType representing the spectrum, i.e. the Fourier transform of a CorrelationFunction in steady state.\n\nTo actually compute the spectrum at a frequency ω, construct the type on top of a correlation function and call it with Spectrum(c)(ω,usteady,p0).\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"correlation_u0","category":"page"},{"location":"api/#QuantumCumulants.correlation_u0","page":"API","title":"QuantumCumulants.correlation_u0","text":"correlation_u0(c::CorrelationFunction, u_end)\n\nFind the vector containing the correct initial values when numerical solving the time evolution for the correlation function.\n\nSee also: CorrelationFunction correlation_p0\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"correlation_p0","category":"page"},{"location":"api/#QuantumCumulants.correlation_p0","page":"API","title":"QuantumCumulants.correlation_p0","text":"correlation_p0(c::CorrelationFunction, u_end, ps=Pair[])\n\nFind all occurring steady-state values and add them to a list of parameters to pass this to the ODEProblem.\n\nSee also: CorrelationFunction correlation_u0\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Utils","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"find_missing","category":"page"},{"location":"api/#QuantumCumulants.find_missing","page":"API","title":"QuantumCumulants.find_missing","text":"find_missing(me::MeanfieldEquations, vs_adj=nothing, get_adjoints=true)\n\nFind all averages on the right-hand-side of in me.equations that are not listed me.states. For a complete system this list is empty.\n\nOptional arguments\n\n*vs_adj: List of the complex conjugates of me.states. If set to nothing     the list is generated internally. *get_adjoints=true: Specify whether a complex conjugate of an average should be     explicitly listed as missing.\n\nsee also: complete, complete!\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"find_operators","category":"page"},{"location":"api/#QuantumCumulants.find_operators","page":"API","title":"QuantumCumulants.find_operators","text":"find_operators(::HilbertSpace, order; names=nothing)\n\nFind all operators that fully define a system up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"complete","category":"page"},{"location":"api/#ModelingToolkit.complete","page":"API","title":"ModelingToolkit.complete","text":"complete(de::MeanfieldEquations)\n\nFrom a set of differential equation of averages, find all averages that are missing and derive the corresponding equations of motion. Uses find_missing and meanfield to do so.\n\nOptional arguments\n\n*order=de.order: The order at which the cumulant_expansion is performed     on the newly derived equations. If nothing, the order is inferred from the     existing equations. *filter_func=nothing: Custom function that specifies whether some averages should     be ignored when completing a system. This works by calling filter!(filter_func, missed)     where missed is the vector resulting from find_missing. Occurrences     of averages for which filter_func returns false are substituted to 0. *extra_indices=Vector: Used for indexed equations. Can be used to specify additional     indices, that are needed for calculation. *kwargs...: Further keyword arguments are passed on to meanfield and     simplification.\n\nsee also: find_missing, meanfield\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"complete!","category":"page"},{"location":"api/#ModelingToolkit.complete!","page":"API","title":"ModelingToolkit.complete!","text":"complete!(de::MeanfieldEquations)\n\nIn-place version of complete\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"unique_ops","category":"page"},{"location":"api/#QuantumCumulants.unique_ops","page":"API","title":"QuantumCumulants.unique_ops","text":"unique_ops(ops)\n\nFor a given list of operators, return only unique ones taking into account their adjoints.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"unique_ops!","category":"page"},{"location":"api/#QuantumCumulants.unique_ops!","page":"API","title":"QuantumCumulants.unique_ops!","text":"unique_ops!(ops)\n\nIn-place version of unique_ops.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"fundamental_operators","category":"page"},{"location":"api/#QuantumCumulants.fundamental_operators","page":"API","title":"QuantumCumulants.fundamental_operators","text":"fundamental_operators(::HilbertSpace)\n\nReturn all fundamental operators for a given Hilbertspace. For example, a FockSpace only has one fundamental operator, Destroy.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"transition_superscript","category":"page"},{"location":"api/#QuantumCumulants.transition_superscript","page":"API","title":"QuantumCumulants.transition_superscript","text":"transition_superscript(::Bool)\n\nSpecify whether the indices in a Transition operator should be printed as superscript. Default is true. If set to false, the indices corresponding to the levels are printed as subscript.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"to_numeric","category":"page"},{"location":"api/#QuantumCumulants.to_numeric","page":"API","title":"QuantumCumulants.to_numeric","text":"to_numeric(q::QNumber, b::QuantumOpticsBase.Basis; level_map = nothing)\nto_numeric(q::QNumber, state; level_map = nothing)\n\nConvert a symbolic operator q to its equivalent numeric (matrix) form on the basis b. The optional argument level_map can be set to a dictionary that specifies how to map levels of a Transition to the ones given in an NLevelBasis. Note: If the levels of a transition are symbolic, setting level_map is required.\n\nSee also: numeric_average, initial_values\n\nExamples\n\njulia> to_numeric(Destroy(FockSpace(:fock), :a), FockBasis(10)) Operator(dim=11x11)   basis: Fock(cutoff=10)[...]\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"numeric_average","category":"page"},{"location":"api/#QuantumCumulants.numeric_average","page":"API","title":"QuantumCumulants.numeric_average","text":"numeric_average(avg::Average, state; level_map = nothing)\nnumeric_average(q::QNumber, state; level_map = nothing)\n\nFrom a symbolic average avg or operator q, compute the corresponding numerical average value with the given quantum state state. This state can either be of type QuantumOpticsBase.StateVector or QuantumOpticsBase.Operator.\n\nSee also: initial_values, to_numeric\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"initial_values","category":"page"},{"location":"api/#QuantumCumulants.initial_values","page":"API","title":"QuantumCumulants.initial_values","text":"initial_values(eqs::MeanfieldEquations, state; level_map=nothing)\n\nFor a set of symbolic equations eqs compute the initial state average values corresponding to the numeric quantum state state of the system. The quantum state can either be of type QuantumOpticsBase.StateVector or QuantumOpticsBase.Operator.\n\nSee also: to_numeric, numeric_average\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_solution","category":"page"},{"location":"api/#QuantumCumulants.get_solution","page":"API","title":"QuantumCumulants.get_solution","text":"get_solution(sol, op::QTerm)\nget_solution(sol, op::QNumber)\n\nReturns the result for the average of the operator expression op in the solution sol of an ODE- or SteadyStateProblem, similar to sol[op]. It can also be used for linear combinations of operators, which is not possible with sol[op].\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Sums","page":"API","title":"Symbolic Summations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Index","category":"page"},{"location":"api/#QuantumCumulants.Index","page":"API","title":"QuantumCumulants.Index","text":"Index(hilb::HilbertSpace,name::Symbol,range::Union{Int64,Sym},aon::Int)\n\nDefines an index, using a Symbol as a name, and a HilbertSpace for computation and commutator-relations. Indices with all same fields will be considered equal. See also: IndexedOperator and IndexedVariable\n\nFields:\n\nhilb: The whole HilbertSpace, the index will be defined on.\nname: A Symbol, which defines the name of the index, and how product-terms of IndexedOperator are ordered (alphabetical)\nrange: The upper bound limit of the index. This can be a SymbolicUitls.Symbolic or any Number.\naon: Number specifying the specific HilbertSpace, where the Index acts on.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"IndexedOperator","category":"page"},{"location":"api/#QuantumCumulants.IndexedOperator","page":"API","title":"QuantumCumulants.IndexedOperator","text":"IndexedOperator <: QSym\nIndexedOperator(op::Union{Transition,Create,Destroy},ind::Index)\n\nOperator, associated with an index.\n\nFields:\n\nop: Operator, either a Transition, a Destroy or a Create can be defined.\nind: The index, the operator will be associated with.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"IndexedVariable","category":"page"},{"location":"api/#QuantumCumulants.IndexedVariable","page":"API","title":"QuantumCumulants.IndexedVariable","text":"IndexedVariable <: CNumber\nIndexedVariable(name::Symbol,ind::Index)\nIndexedVariable(name::Symbol,ind1::Index,ind2:Index)\n\nA indexed symbolic variable. The variable can (once equations are calculated) be easily exchanged for numerical values. Calling a IndexedVariable using two different Index objects one can create DoubleIndexedVariable objects. See also: value_map\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DoubleIndexedVariable","category":"page"},{"location":"api/#QuantumCumulants.DoubleIndexedVariable","page":"API","title":"QuantumCumulants.DoubleIndexedVariable","text":"DoubleIndexedVariable <: CNumber\nDoubleIndexedVariable(name::Symbol,ind1::Index,ind2::Index;identical::Bool)\n\nA double-indexed symbolic variable. The variable can (once equations are calculated) be easily exchanged for numerical values. See also: value_map\n\nFields:\n\nname: A Symbol, defining the name of the variable\nind1: The first Index of the variable\nind2: The second Index of the variable\nidentical: A Bool, defining if the variable can have non-zero main-diagonal terms, e.g: Γᵢᵢ ≠ 0 would be specified with true.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"SingleSum","category":"page"},{"location":"api/#QuantumCumulants.SingleSum","page":"API","title":"QuantumCumulants.SingleSum","text":"SingleSum <: QTerm\n\nDefines a symbolic summation over a term, using one Index entity.\n\nFields:\n\nterm: A multiplication of q-number terms. When the multiplication contains any IndexedOperator with the same index as the summation-index, a symbolic sum will be created.\nsum_index: The index, for which the summation will go over.\nnonequalindices: (optional) A vector of indices, for which the summation-index can not be equal with.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DoubleSum","category":"page"},{"location":"api/#QuantumCumulants.DoubleSum","page":"API","title":"QuantumCumulants.DoubleSum","text":"DoubleSum <: QTerm\n\nDefines a symbolic summation over another SingleSum, using one Index entity. This corresponds to a double-summation over a multiplication of terms.\n\nFields:\n\ninnerSum: A SingleSum entity.\nsum_index: The index, for which the (outer) summation will go over.\nNEI: (optional) A vector of indices, for which the (outer) summation-index can not be equal with.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"change_index","category":"page"},{"location":"api/#QuantumCumulants.change_index","page":"API","title":"QuantumCumulants.change_index","text":"change_index(term,from::Index,to::Index)\n\nExchanges all occuring indices inside the given term, that are equal to the from to the to index.\n\nExamples\n\nchange_index(σⱼ²¹,j,i) = σᵢ²¹\n\nchange_index(σⱼ²¹ * σᵢ¹²,j,i) = σᵢ²²\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"insert_index","category":"page"},{"location":"api/#QuantumCumulants.insert_index","page":"API","title":"QuantumCumulants.insert_index","text":"insert_index(term,ind::Index,value::Int)\n\nFunction, that inserts an integer value for a index in a specified term. This function creates Numbered- Variables/Operators/Sums upon calls.\n\nExamples\n\ninsert_index(σⱼ²¹,j,1) = σ₁²¹\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"SpecialIndexedTerm","category":"page"},{"location":"api/#QuantumCumulants.SpecialIndexedTerm","page":"API","title":"QuantumCumulants.SpecialIndexedTerm","text":"SpecialIndexedTerm <: QTerm\n\nA multiplication of IndexedOperator entities, with special constraint on the index-values. For example σᵢ²² * σⱼ²² with the constraint i ≠ j\n\nFields:\n\nterm: A multiplication of q-number terms.\nindexMapping: A Vector of Index tuples, specifying the contraints for the term. Each Tuple is considered to one constraint. e.g: (i,j) -> i ≠ j\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"reorder","category":"page"},{"location":"api/#QuantumCumulants.reorder","page":"API","title":"QuantumCumulants.reorder","text":"reorder(param,indexMapping)\n\nReorders a given term (param) regarding to a given indexMapping, which specifies, which Index entities can not be equal inside the given term. reorder() creates a SpecialIndexedTerm as a result.\n\nExamples\n\nreorder(σⱼ²¹ * σᵢ²¹,[(i,j)]) = σᵢ²¹ * σⱼ²¹\n\nreorder(σⱼ²¹ * σᵢ²¹ * σⱼ¹²,[(i,j)]) = σᵢ²¹ * σⱼ²²\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"IndexedAverageSum","category":"page"},{"location":"api/#QuantumCumulants.IndexedAverageSum","page":"API","title":"QuantumCumulants.IndexedAverageSum","text":"IndexedAverageSum <: CNumber\n\nDefines a symbolic summation over an average, or a multiplication of several averages, using one Index entity.\n\nFields:\n\nterm: A multiplication of average terms.\nsum_index: The index, for which the summation will go over.\nnonequalindices: (optional) A vector of indices, for which the summation-index can not be equal with.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"IndexedAverageDoubleSum","category":"page"},{"location":"api/#QuantumCumulants.IndexedAverageDoubleSum","page":"API","title":"QuantumCumulants.IndexedAverageDoubleSum","text":"IndexedAverageDoubleSum <: CNumber\n\nDefines a symbolic summation over an IndexedAverageSum, using a Index entity. This schematically represent a double-sum over a multiplication of averages.\n\nFields:\n\ninnerSum: An IndexedAverageSum entity.\nsum_index: The index, for which the (outer) summation will go over.\nnonequalindices: (optional) A vector of indices, for which the (outer) summation-index can not be equal with.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"NumberedOperator","category":"page"},{"location":"api/#QuantumCumulants.NumberedOperator","page":"API","title":"QuantumCumulants.NumberedOperator","text":"NumberedOperator <: QSym\n\nDefines an operator, associated with a Number. Commutator-relations are calculated using these numbers, as a sort of a specific index-value.\n\nFields:\n\nop: An Operator, either a Transition, a Destroy or a Create can be defined.\nnumb: An Integer Number.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"evaluate","category":"page"},{"location":"api/#QuantumCumulants.evaluate","page":"API","title":"QuantumCumulants.evaluate","text":"evaluate(eqs::IndexedMeanfieldEquations;limits)\nevaluate(corr::CorrelationFunction;limits)\nevaluate(x;limits)\n\nFunction, that evaluates a given MeanfieldEquations entity and returns again equations, where indices have been inserted and sums evaluated. Can also be called on individual terms and a CorrelationFunction entity, to evaluate any summations inside these terms.\n\nArguments\n\n*me::MeanfieldEquations: A MeanfieldEquations entity, which shall be evaluated.\n\nOptional argumentes\n\n*limits::Dict{BasicSymbolic,Int64}=Dict{Symbol,Int64}(): A seperate dictionary, to     specify any symbolic limits used when Index entities were defined. This needs     to be specified, when the equations contain summations, for which the upper bound is given     by a Symbolic. *h: A HilbertSpace, Vector of Hilbertspaces or Numbers, specifying the specific Hilbertspaces,     that shall be evaluated. Does not evaluate any other Hilbertspace, other than the given ones.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"scale","category":"page"},{"location":"api/#QuantumCumulants.scale","page":"API","title":"QuantumCumulants.scale","text":"scale(me::IndexedMeanfieldEquations;h)\nscale(me::CorrelationFunction;h)\n\nFunction, that evaluates a given MeanfieldEquations or CorrelationFunction entity and returns again equations, where indices have been inserted and sums evaluated, regarding the same relations, as done when calculating with oparators using a ClusterSpace. For this it is considered that all entities in the given (sub)system are acting on the system equivalently. \n\nArguments\n\n*me::IndexedMeanfieldEquations: A MeanfieldEquations entity, which shall be scaled.\n\nOptional argumentes\n\n*h: A HilbertSpace, Vector of Hilbertspaces or Numbers, specifying the specific Hilbertspaces,     that shall be scaled. Does not scale any other Hilbertspace, other than the given ones.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"value_map","category":"page"},{"location":"api/#QuantumCumulants.value_map","page":"API","title":"QuantumCumulants.value_map","text":"value_map(ps::Vector,p0::Vector)\n\nA Function to create parameter values for indexed Variables more convenient.\n\nArguments\n\n*ps::Vector: A vector of parameters, that have no value assigned to them. *p0::Vector: A vector for numeric values, that should get assigned to the corresponding     entry in the ps vector. For Single-Indexed Variables the entry in the vector can also be again     a Vector, that has an amount of entries as the index of the variables has range. For Double-Indexed     Variables, this can also be a Matrix of a dimension, that corresponds to the ranges of the indices     of the given variable.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"indexed_complete","category":"page"},{"location":"api/#QuantumCumulants.indexed_complete","page":"API","title":"QuantumCumulants.indexed_complete","text":"indexed_complete(de::IndexedMeanfieldNoiseEquations)\n\nFrom a set of differential equation of averages, find all averages that are missing and derive the corresponding equations of motion. Uses find_missing and indexed_meanfield to do so. Implementation for IndexedMeanfieldNoiseEquations.\n\nOptional arguments\n\n*order=de.order: The order at which the cumulant_expansion is performed     on the newly derived equations. If nothing, the order is inferred from the     existing equations. *filter_func=nothing: Custom function that specifies whether some averages should     be ignored when completing a system. This works by calling filter!(filter_func, missed)     where missed is the vector resulting from find_missing. Occurrences     of averages for which filter_func returns false are substituted to 0. *extra_indices: A Vector of symbols, representing extra Index entities, which are     needed and created in the process of finding missing terms. *kwargs...: Further keyword arguments are passed on to indexed_meanfield and     simplification.\n\nsee also: find_missing, indexed_meanfield, meanfield, find_missing_sums\n\n\n\n\n\nindexed_complete(de::MeanfieldEquations)\n\nFrom a set of differential equation of averages, find all averages that are missing and derive the corresponding equations of motion. Uses find_missing and indexed_meanfield to do so.\n\nOptional arguments\n\n*order=de.order: The order at which the cumulant_expansion is performed     on the newly derived equations. If nothing, the order is inferred from the     existing equations. *filter_func=nothing: Custom function that specifies whether some averages should     be ignored when completing a system. This works by calling filter!(filter_func, missed)     where missed is the vector resulting from find_missing. Occurrences     of averages for which filter_func returns false are substituted to 0. *extra_indices: A Vector of symbols, representing extra Index entities, which are     needed and created in the process of finding missing terms. *kwargs...: Further keyword arguments are passed on to indexed_meanfield and     simplification.\n\nsee also: find_missing, indexed_meanfield, meanfield, find_missing_sums\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"split_sums","category":"page"},{"location":"api/#QuantumCumulants.split_sums","page":"API","title":"QuantumCumulants.split_sums","text":"split_sums(term::SymbolicUtils.Symbolic,amount::Union{<:SymbolicUtils.Sym,<:Int64})\nsplit_sums(me::MeanfieldEquations,amount)\n\nFunction, that splits sums inside a given term. The sums are split into a number of equal sums, specified in the amount argument, where in only one of the sums the dependencies for the indices (non equal indices) is considered.\n\nArguments\n\n*me::MeanfieldEquations: A MeanfieldEquations entity, which shall be evaluated, can also be any symbolic expression. *amount::Union{<:SymbolicUtils.Sym,<:Int64}: A Number or Symbolic determining, in how many terms a sum is split\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"find_missing_sums","category":"page"},{"location":"api/#QuantumCumulants.find_missing_sums","page":"API","title":"QuantumCumulants.find_missing_sums","text":"find_missing_sums(missed,de::MeanfieldEquations)\n\nFrom a initial set of differential equation of averages, find all averages that are missing and inside a Symbolic sum. If a missing average contains one of the summation indices used in the equations, the Index will be exchanged according to the keyword argument extra_indices. Uses find_missing.\n\nArguments\n\n*missed: A initial Vector of averages, representing the missed averages before calling     this method. *de: The set of equations, in which the missing averages are searched in.\n\nOptional arguments\n\n*extra_indices: A Vector of symbols, representing extra Index entities, which are     needed and created in the process of finding missing terms. This argument is required, if the order     of the Meanfield-Equations exceeds 1 and the number of given symbols must match the corresponding order. *checking: A Bool defining if the algorithm checks for adjoint values and duplicates, before adding a found     average into the missed vector. *scaling: A Bool defining the way how averages are added to the missed vector. If true only averages, whose     operators (without indices) are not already inside the missed vector will be added.\n\nsee also: find_missing, indexed_meanfield, meanfield, find_missing_sums\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"IndexedCorrelationFunction","category":"page"},{"location":"api/#QuantumCumulants.IndexedCorrelationFunction","page":"API","title":"QuantumCumulants.IndexedCorrelationFunction","text":"IndexedCorrelationFunction(op1,op2,de0;steady_state=false,add_subscript=0,mix_choice=maximum)\n\nThe first-order two-time correlation function of two operators.\n\nThe first-order two-time correlation function of op1 and op2 evolving under the system de0. The keyword steady_state determines whether the original system de0 was evolved up to steady state. The arguments add_subscript defines the subscript added to the name of op2 representing the constant time.\n\nNote that the correlation function is stored in the first index of the underlying system of equations.\n\nThis is the indexed-version of the CorrelationFunction and allows IndexedOperator entities as argument-values. This function will automatically be called by CorrelationFunction, when the original system de0 contains any types of Index entities.\n\nSee also: CorrelationFunction\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"indexed_complete!","category":"page"},{"location":"api/#QuantumCumulants.indexed_complete!","page":"API","title":"QuantumCumulants.indexed_complete!","text":"indexed_complete!(de::MeanfieldEquations)\n\nIn-place version of indexed_complete\n\n\n\n\n\nindexed_complete!(de::MeanfieldEquations)\n\nIn-place version of indexed_complete\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"evalME","category":"page"},{"location":"api/#QuantumCumulants.evalME","page":"API","title":"QuantumCumulants.evalME","text":"evalME(me::MeanfieldEquations;limits::Dict{SymbolicUtils.BasicSymbolic,Int64}=Dict{SymbolicUtils.BasicSymbolic,Int64}())\n\nFunction, that evaluates a given MeanfieldEquations entity and returns again equations, where indices have been inserted and sums evaluated.\n\nArguments\n\n*me::MeanfieldEquations: A MeanfieldEquations entity, which shall be evaluated.\n\nOptional argumentes\n\n*limits=Dict{SymbolicUtils.BasicSymbolic,Int64}(): A seperate dictionary, to     specify any symbolic limits used when Index entities were defined. This needs     to be specified, when the equations contain summations, for which the upper bound is given     by a Symbolic.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"scaleME","category":"page"},{"location":"api/#QuantumCumulants.scaleME","page":"API","title":"QuantumCumulants.scaleME","text":"scaleME(me::IndexedMeanfieldNoiseEquations)\n\nFunction, that evaluates a given IndexedMeanfieldNoiseEquations entity and returns again equations, where indices have been inserted and sums evaluated, regarding the same relations, as done when calculating with oparators using a ClusterSpace.\n\nArguments\n\n*me::IndexedMeanfieldNoiseEquations: A IndexedMeanfieldNoiseEquations entity, which shall be evaluated.\n\n\n\n\n\nscaleME(me::IndexedMeanfieldEquations)\n\nFunction, that evaluates a given MeanfieldEquations entity and returns again equations, where indices have been inserted and sums evaluated, regarding the same relations, as done when calculating with oparators using a ClusterSpace.\n\nArguments\n\n*me::MeanfieldEquations: A MeanfieldEquations entity, which shall be evaluated.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"indexed_meanfield","category":"page"},{"location":"api/#QuantumCumulants.indexed_meanfield","page":"API","title":"QuantumCumulants.indexed_meanfield","text":"indexed_meanfield(ops::Vector,H::QNumber,J::Vector;\n    Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\n\nCompute the set of equations for the indexed-operators IndexedOperator in ops under the Hamiltonian H and with loss operators contained in J. The resulting equation is equivalent to the Quantum-Langevin equation where noise is neglected. This is a modified version of the meanfield function, that can now also take IndexedOperator entities for both the ops argument aswell as for the J arguments. See also: meanfield.\n\nArguments\n\n*ops::Vector: The operators of which the equations are to be computed. *H::QNumber: The Hamiltonian describing the reversible dynamics of the     system. *J::Vector{<:QNumber}: A vector containing the collapse operators of     the system. A term of the form     sum_i J_i^dagger O J_i - frac12left(J_i^dagger J_i O + OJ_i^dagger J_iright)     is added to the Heisenberg equation.\n\nOptional argumentes\n\n*Jdagger::Vector=adjoint.(J): Vector containing the hermitian conjugates of     the collapse operators. *rates=ones(length(J)): Decay rates corresponding to the collapse operators in J. *multithread=false: Specify whether the derivation of equations for all operators in ops     should be multithreaded using Threads.@threads. *simplify=true: Specify whether the derived equations should be simplified. *order=nothing: Specify to which order a cumulant_expansion is performed.     If nothing, this step is skipped. *mix_choice=maximum: If the provided order is a Vector, mix_choice determines     which order to prefer on terms that act on multiple Hilbert spaces. *iv=SymbolicUtils.Sym{Real}(:t): The independent variable (time parameter) of the system.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"subst_reds","category":"page"},{"location":"api/#QuantumCumulants.subst_reds","page":"API","title":"QuantumCumulants.subst_reds","text":"subst_reds(de::AbstractMeanfieldEquations)\n\nFunction that substitutes possible redundant conjugate averages inside the given Equations with their corresponding average given as the conjugate of one of the left-hand-side (of the equations) averages.\n\nOptional Arguments\n\n*scaling: A Bool defining the way how averages are added to the missed vector. If true only averages, whose     operators (without indices) are not already inside the missed vector will be added.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Measurement-Backaction","page":"API","title":"Measurement Backaction","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MeanfieldNoiseEquations","category":"page"},{"location":"api/#QuantumCumulants.MeanfieldNoiseEquations","page":"API","title":"QuantumCumulants.MeanfieldNoiseEquations","text":"MeanfieldNoiseEquations\n\nMean field equations including a separate set of equations describing the noise generated by measurement backactions.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"IndexedMeanfieldNoiseEquations","category":"page"},{"location":"api/#QuantumCumulants.IndexedMeanfieldNoiseEquations","page":"API","title":"QuantumCumulants.IndexedMeanfieldNoiseEquations","text":"IndexedMeanfieldNoiseEquations\n\nLike a MeanfieldNoiseEquations, but with symbolic indices.\n\n\n\n\n\n","category":"type"},{"location":"examples/optomechanical-cooling/#Optomechanical-Cooling","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"","category":"section"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"In this example, we show how to implement a cooling scheme based on radiation pressure coupling of light to a mechanical oscillator, such as a membrane. The oscillator is placed inside an optical cavity. The cavity is driven by a laser and the resulting radiation pressure of the cavity field effectively couples the photons in the cavity mode to the vibrational phonons of the mechanical oscillator mode. This model is based on the one studied in C. Genes, et. al., Phys. Rev. A 77, 033804 (2008), and the Hamiltonian reads","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"H = -hbarDelta a^dagger a + hbaromega_m b^dagger b + hbar Ga^dagger a left(b + b^daggerright) + hbar E left(a + a^daggerright)","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"where Delta = omega_ell - omega_c is the detuning between the driving laser (omega_ell) and the cavity (omega_c). The amplitude of the laser is denoted by E, the resonance frequency of the mechanical oscillator by omega_m, and the radiation pressure coupling is given by G. Additionally, photons leak out of the cavity at a rate kappa. We start by loading the needed packages and specifying the model.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"using QuantumCumulants\nusing OrdinaryDiffEq, ModelingToolkit\nusing Plots\n\n# Hilbertspace\nhc = FockSpace(:cavity)\nhm = FockSpace(:motion)\nh = hc ⊗ hm\n\n# Operators\n@qnumbers a::Destroy(h,1) b::Destroy(h,2)\n\n# Parameters\n@cnumbers Δ ωm E G κ\n\n# Hamiltonian\nH = -Δ*a'*a + ωm*b'*b + G*a'*a*(b + b') + E*(a + a')\n\n# Jump operators & rates\nJ = [a]\nrates = [κ]\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"We are specifically interested in the average number of photons langle a^dagger a rangle and phonons langle b^dagger b rangle. Thus we first derive the equations for these two averages. We restrict our description to a second order cumulant expansion.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"# Derive equations\nops = [a'*a, b'*b]\neqs = meanfield(ops,H,J;rates=rates,order=2)\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"beginalign\nfracddt langle a^dagger  arangle  = -1 i E langle a^daggerrangle  + 1 i E langle arangle  -10 kappa langle a^dagger  arangle  \nfracddt langle b^dagger  brangle  = -1 i G left( langle a^daggerrangle  langle a  b^daggerrangle  + langle b^daggerrangle  langle a^dagger  arangle  + langle arangle  langle a^dagger  b^daggerrangle  -2 langle a^daggerrangle  langle b^daggerrangle  langle arangle  right) + 1 i G left( langle a^daggerrangle  langle a  brangle  + langle arangle  langle a^dagger  brangle  + langle brangle  langle a^dagger  arangle  -2 langle a^daggerrangle  langle arangle  langle brangle  right)\nendalign","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"To get a closed set of equations we automatically complete the system.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"# Complete equations\neqs_completed = complete(eqs)\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"beginalign\nfracddt langle a^dagger  arangle  = -1 i E langle a^daggerrangle  + 1 i E langle arangle  -10 kappa langle a^dagger  arangle  \nfracddt langle b^dagger  brangle  = -1 i G left( langle a^daggerrangle  langle a  b^daggerrangle  + langle b^daggerrangle  langle a^dagger  arangle  + langle arangle  langle a^dagger  b^daggerrangle  -2 langle a^daggerrangle  langle b^daggerrangle  langle arangle  right) + 1 i G left( langle a^daggerrangle  langle a  brangle  + langle arangle  langle a^dagger  brangle  + langle brangle  langle a^dagger  arangle  -2 langle a^daggerrangle  langle arangle  langle brangle  right) \nfracddt langle a^daggerrangle  = 1 i E + G left( 1 i langle a^dagger  b^daggerrangle  + 1 i langle a^dagger  brangle  right) -1 i Delta langle a^daggerrangle  -05 kappa langle a^daggerrangle  \nfracddt langle a  b^daggerrangle  = G left( -2 i langle b^daggerrangle  langle a  b^daggerrangle  -1 i langle b^daggerrangle  langle a  brangle  -1 i langle arangle  langle b^dagger  b^daggerrangle  -1 i langle arangle  langle b^dagger  brangle  + 2 i langle arangle  langle b^daggerrangle ^2 -1 i langle brangle  langle a  b^daggerrangle  + 2 i langle b^daggerrangle  langle arangle  langle brangle  right) -1 i E langle b^daggerrangle  + 1 i G left( langle a^daggerrangle  langle a  arangle  -2 langle a^daggerrangle  langle arangle ^2 + 2 langle arangle  langle a^dagger  arangle  right) + 1 i Delta langle a  b^daggerrangle  -05 kappa langle a  b^daggerrangle  + 1 i omegam langle a  b^daggerrangle  \nfracddt langle b^daggerrangle  = 1 i G langle a^dagger  arangle  + 1 i omegam langle b^daggerrangle  \nfracddt langle a^dagger  b^daggerrangle  = G left( 1 i langle a^daggerrangle  + 2 i langle a^daggerrangle  langle a^dagger  arangle  + 1 i langle a^daggerrangle  langle b^dagger  b^daggerrangle  + 1 i langle a^daggerrangle  langle b^dagger  brangle  -2 i langle a^daggerrangle  langle b^daggerrangle ^2 + 2 i langle b^daggerrangle  langle a^dagger  b^daggerrangle  + 1 i langle b^daggerrangle  langle a^dagger  brangle  + 1 i langle arangle  langle a^dagger  a^daggerrangle  -2 i langle arangle  langle a^daggerrangle ^2 + 1 i langle brangle  langle a^dagger  b^daggerrangle  -2 i langle a^daggerrangle  langle b^daggerrangle  langle brangle  right) + 1 i E langle b^daggerrangle  -1 i Delta langle a^dagger  b^daggerrangle  -05 kappa langle a^dagger  b^daggerrangle  + 1 i omegam langle a^dagger  b^daggerrangle  \nfracddt langle b^dagger  b^daggerrangle  = 2 i G left( langle a^daggerrangle  langle a  b^daggerrangle  + langle b^daggerrangle  langle a^dagger  arangle  + langle arangle  langle a^dagger  b^daggerrangle  -2 langle a^daggerrangle  langle b^daggerrangle  langle arangle  right) + 2 i omegam langle b^dagger  b^daggerrangle  \nfracddt langle a  arangle  = G left( -2 i langle b^daggerrangle  langle a  arangle  + 4 i langle b^daggerrangle  langle arangle ^2 -4 i langle arangle  langle a  b^daggerrangle  -4 i langle arangle  langle a  brangle  -2 i langle brangle  langle a  arangle  + 4 i langle brangle  langle arangle ^2 right) -2 i E langle arangle  + 2 i Delta langle a  arangle  -10 kappa langle a  arangle\nendalign","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"To calculate the dynamics we create a system of ordinary differential equations, which can be used by DifferentialEquations.jl.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"@named sys = ODESystem(eqs_completed)\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"Finally we need to define the numerical parameters and the initial state of the system. We will consider the membrane at room temperature. Its vibrational mode is in a thermal state with an average number of phonons that can be estimated from k_B T = n_mathrmvibhbar omega_m. If the resonator has a resonance frequency of omega_m = 10mathrmMHz, then the number of phonons at room temperature (Tapprox 300K) is approximately n_mathrmvib approx 4times 10^6.","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"# Initial state\nu0 = zeros(ComplexF64, length(eqs_completed))\nu0[2] = 4e6 # Initial number of phonons\n# System parameters\np0 = (Δ=>-10, ωm=>1, E=>200, G=>0.0125, κ=>20)\nprob = ODEProblem(sys,u0,(0.0,60000),p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"examples/optomechanical-cooling/","page":"Optomechanical Cooling","title":"Optomechanical Cooling","text":"# Plot results\nt = real.(sol.t)\nphonons = real.(sol[b'b])\nT = 7.5e-5*phonons\nphotons = real.(sol[a'a])\n\np1 = plot(t, T, ylabel=\"T in K\", legend=false)\np2 = plot(t, photons, xlabel=\"t⋅ωm\", ylabel=\"⟨a⁺a⟩\", legend=false)\nplot(p1, p2, layout=(2,1), size=(650,400))","category":"page"},{"location":"theory/#theory","page":"Theoretical background","title":"Theoretical background","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"In this section, we will describe the fundamental theoretical concepts used within QuantumCumulants.jl.","category":"page"},{"location":"theory/#The-Quantum-Langevin-equation","page":"Theoretical background","title":"The Quantum Langevin equation","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"In an open quantum system, the equation of motion of an operator mathcalO is given by the Quantum Langevin equation. Let a system be described by the Hamiltonian H, and subject to a number of decay channels with the rates gamma_n and corresponding damping operators c_n. The equation for mathcalO is then given by","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"dotmathcalO = fracihbarHmathcalO + sum_n fracgamma_n2left(2c_n^dagger mathcalOc_n - c_n^dagger c_n mathcalO - mathcalOc_n^dagger c_nright) + textnoise","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Note that we did not specify the noise term, since under the assumption of white noise it does not contribute to averages. We can therefore neglect it in the following. The above equation is an operator equation, i.e. solving it directly has the same numerical complexity as solving a stochastic master equation. However, averaging over the above we obtain a c-number equation, which, in principle, is easy to solve. This is the basic idea in QuantumCumulants.jl: derive equations of motions of operators, and then convert them to easily solvable c-number differential equations. However, as we will see, there is another crucial step required, namely the cumulant expansion.","category":"page"},{"location":"theory/#A-brief-example","page":"Theoretical background","title":"A brief example","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"To illustrate this, let us consider a simple example, the Jaynes-Cummings model. This model describes a two-level atom that is coupled to an optical resonator. The Hamiltonian reads","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"H_mathrmJC = hbarDelta a^dagger a + hbar gleft(a^dagger sigma^ge + asigma^egright)","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"where Delta = omega_mathrmc - omega_mathrma is the detuning between the cavity resonance frequency omega_mathrmc and the atomic transition frequency omega_mathrma. The frequency g describes the strength of the dipole-coupling between the atom and the cavity. The operators a and a^dagger are the photonic annihilation and creation operators of the cavity mode. The atom has a ground state grangle and an excited state erangle, and its dynamics are described by the projection operators sigma^ij = iranglelangle j, where ij inge. For simplicity, we will here assume that the system is closed, i.e. it is not subject to decay, such that the operator dynamics are described by the Heisenberg equation (i.e. only the first part of the Quantum Langevin equation).","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Now, say we want to compute the field dynamics, i.e. we want to derive the equation for dota. Using the fundamental relations","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"aa^dagger = 1 quad sigma^ijsigma^kl = delta_jksigma^il","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"we derive","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\ndota = iDelta a - ig sigma^ge\n\ndotsigma^ge = 2ig a sigma^ee - ig a\n\ndotsigma^ee = igleft(a^daggersigma^ge - asigma^egright)\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Since dota couples to sigma^ge, and dotsigma^ge to sigma^ee, we needed to derive a total of three equations to arrive at a complete set. In order to make them easy to handle, we average over the above system of equations to obtain c-number equations. We find","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\nlangledotarangle = iDelta langle arangle - ig langlesigma^gerangle\n\nlangledotsigma^gerangle = 2ig langle asigma^eerangle - ig langle a rangle\n\nlangle dotsigma^eerangle = -2gtextImleftlangle a^daggersigma^gerangleright\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"The above system can, however, not be solved since we encounter terms such as langle asigma^eerangle, meaning the set of equations is incomplete, since in general langle asigma^eerangle neq langle aranglelanglesigma^eerangle. A naive approach would be to derive the equations for all missing average values. Unfortunately, these equations will couple to averages of ever longer operator products. A complete set of equations can therefore not be derived, since it would consist of infinitely many equations.","category":"page"},{"location":"theory/#Cumulant-expansion","page":"Theoretical background","title":"Cumulant expansion","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"To obtain a closed set of c-number equations, we truncate the in principle infinite set of equations at a certain order. By order, we essentially mean the length of an operator product, e.g. langle a rangle is of order 1, langle a^dagger a rangle and langle a^dagger sigma^gerangle are of the order 2. The order of a system determines its size and the accuracy of the underlying approximation. It is therefore an essential concept in QuantumCumulants.jl.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"The way in which we truncate a system of equations is called the generalized cumulant expansion (see also R. Kubo, Generalized Cumulant Expansion Method). The joint cumulant, which we denote by langlecdotrangle_c of a product of operators X_1 X_2  X_n of order n is given by","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"langle X_1 X_2  X_n rangle_c = sum_p in P(mathcalI) left(p - 1right) (-1)^p-1 prod_B in p langle prod_iin B X_irangle","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"In the above, mathcalI=12n, P(mathcalI) is the set of all partitions of mathcalI, p denotes the length of the partition p, and B runs over the blocks of each partition. For example, in the case of n=3 we find","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\nlangle X_1X_2X_3 rangle_c = langle X_1X_2X_3rangle  -langle X_1X_2ranglelangle X_3rangle - langle X_1X_3ranglelangle X_2rangle\n\n- langle X_1ranglelangle X_2X_3rangle + 2langle X_1ranglelangle X_2ranglelangle X_3rangle\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Note that the joint cumulant of order n is proportional to averages of order leq n. Furthermore, the average of order n occurs precisely once on the right-hand-side.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"The joint cumulant can be thought of as a general measure for the correlation between operators. According to Theorem I from R. Kubo, Generalized Cumulant Expansion Method, the joint cumulant is zero iff any of the operators is statistically independent of the others. The key assumption we are making is to essentially invert this statement: instead of computing the joint cumulant of a given order to see if it is zero, we assume that it is. Since the average value of the same order occurs only once in the definition of the joint cumulant, we may invert the relation to express the average in terms of lower-order terms; i.e., if we assume langle X_1 X_2  X_nrangle_c = 0, we can write","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"langle X_1X_2X_n rangle = sum_p in P(mathcalI)backslash mathcalI left(p - 1right) (-1)^p prod_B in p langle prod_iin B X_irangle","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"where now P(mathcalI)backslashmathcalI is the set of all partitions of mathcalI that does not contain mathcalI itself. In the example of n=3, we have","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"langle X_1X_2X_3rangle   = langle X_1X_2ranglelangle X_3rangle + langle X_1X_3ranglelangle X_2rangle + langle X_1ranglelangle X_2X_3rangle - 2langle X_1ranglelangle X_2ranglelangle X_3rangle","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"In other words, by neglecting the cumulant of order n we can express all averages of order n in terms of averages of order n-1 and below. By applying this expansion recursively, we can reduce the order of any term to one as low as we choose.","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Returning to the example of the Jaynes-Cummings Hamiltonian, we could use the cumulant expansion to express all the terms of order 2 in first order only. This is also called the mean-field approach which neglects all quantum correlations of a system. For the Jaynes-Cummings model, we would then have","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\nlangledotarangle = iDelta langle arangle - ig langlesigma^gerangle\n\nlangledotsigma^gerangle = 2ig langle aranglelanglesigma^eerangle - ig langle a rangle\n\nlangle dotsigma^eerangle = -2gtextImleftlangle a^daggerranglelanglesigma^gerangleright\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Now this system of equations forms a closed set, and can readily be implemented and solved numerically. Of course, solving the Jaynes-Cummings model in mean field is not very interesting. We could make it more interesting by doing a second-order cumulant expansion. However, this would involve deriving the equations for all the second-order averages, which is quite tedious. So instead, let's just be lazy and use QuantumCumulants.jl to do it,","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\n\n# Symbolic parameters\n@cnumbers Δ g\n\n# Hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf⊗ha\n\n# Operators\n@qnumbers a::Destroy(h) σ::Transition(h)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*σ(:g,:e) + a*σ(:e,:g))\n\n# List of first and second-order operators\nops = find_operators(h,2)\n\n# Derive equations\nmeanfield(ops,H;order=2) # expand to second order\nnothing # hide","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"beginalign*\nfracddt langle arangle = -10 i langle arangle Delta -10 i langle sigma^gerangle g\n\nfracddt langle sigma^gerangle = -10 i langle arangle g + 20 i g langle a sigma^eerangle\n\nfracddt langle sigma^eerangle = 10 i g langle a^dagger sigma^gerangle -10 i g langle a sigma^egrangle\n\nfracddt langle a sigma^gerangle = 20 i left( langle sigma^eerangle langle a arangle + 2 langle arangle langle a sigma^eerangle -2 langle sigma^eerangle langle arangle ^2 right) g -10 i g langle a arangle -10 i Delta langle a sigma^gerangle\n\nfracddt langle a sigma^eerangle = -10 i left( langle sigma^egrangle langle a arangle + 2 langle arangle langle a sigma^egrangle -2 langle sigma^egrangle langle arangle ^2 right) g + 10 i left( langle a^daggerrangle langle a sigma^gerangle + langle arangle langle a^dagger sigma^gerangle + langle sigma^gerangle langle a^dagger arangle -2 langle a^daggerrangle langle arangle langle sigma^gerangle right) g -10 i Delta langle a sigma^eerangle\n\nfracddt langle a^dagger arangle = -10 i g langle a^dagger sigma^gerangle + 10 i g langle a sigma^egrangle\n\nfracddt langle a sigma^egrangle = -10 i langle sigma^eerangle g -20 i left( langle a^daggerrangle langle a sigma^eerangle + langle arangle langle a^dagger sigma^eerangle + langle sigma^eerangle langle a^dagger arangle -2 langle a^daggerrangle langle arangle langle sigma^eerangle right) g + 10 i g langle a^dagger arangle -10 i Delta langle a sigma^egrangle\n\nfracddt langle a arangle = -20 i g langle a sigma^gerangle -20 i Delta langle a arangle\nendalign*","category":"page"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"Note, that QuantumCumulants.jl automatizes the derivation of equations and the cumulant expansion. Furthermore, the final step of numerical implementation is handled by converting to the ModelingToolkit.jl framework.","category":"page"},{"location":"theory/#References","page":"Theoretical background","title":"References","text":"","category":"section"},{"location":"theory/","page":"Theoretical background","title":"Theoretical background","text":"R. Kubo. \"Generalized cumulant expansion method.\" Journal of the Physical Society of Japan 17.7 (1962): 1100-1120. URL: https://www.jstage.jst.go.jp/article/jpsj1946/17/7/1771100/_article/-char/ja/","category":"page"},{"location":"examples/superradiant_laser_indexed/#Superradiant-Laser","page":"Superradiant Laser","title":"Superradiant Laser","text":"","category":"section"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"Using symmetry properties of a system can reduce the number of needed equations dramatically. A common approximation for laser systems to handle sufficiently big atom numbers is to assume that several atoms in the system behave completely identically. This means all the identical atoms have the same averages.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"In this example we describe a so-called superradiant laser, where we assume all atoms to be identical. This model has been described in D. Meiser et al., Phys. Rev. Lett. 102, 163601 (2009): The Hamiltonian of this system is","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"beginequation\nH = - hbar Delta a^dagger a +  hbar sumlimits_j=1^N  g_j (a^dagger sigma^12_j + a sigma^21_j) \nendequation","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"where Delta = omega_a - omega_c is the detuning between the cavity (omega_c) and the atomic (omega_a) resonance frequency, the atom cavity coupling of the j-th atom is denoted by g_j. Additionally there are dissipative processes in the system: Atoms are incoherently pumped with the rate R, they decay individually with the rate Gamma and are affected by individual atomic dephasing with the rate nu. Furthermore, photons leak out of the system with the rate kappa.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"We start by loading the packages.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"using QuantumCumulants\nusing OrdinaryDiffEq, SteadyStateDiffEq, ModelingToolkit\nusing Plots","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"Due to the implementation of symbolic indices and sums we only need to define the Hilbert space for one atom, even though we will simulate a system for several thousand. Creating an operator with an textttIndex is done with the constructor textttIndexedOperator.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# Hilbertspace\nhc = FockSpace(:cavity)\nha = NLevelSpace(:atom,2)\nh = hc ⊗ ha\n\n# operators\n@qnumbers a::Destroy(h)\nσ(α,β,i) = IndexedOperator(Transition(h, :σ, α, β),i)\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"Now we define the indices and the parameters of the system. An textttIndex needs the system Hilbert space, a symbol, an upper bound and the specific Hilbert space of the indexed operator. textttIndexedVariable creates indexed variables. Actually we wouldn't need indexed variable in this example, this is just for demonstration purposes.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"@cnumbers N Δ κ Γ R ν\ng(i) = IndexedVariable(:g, i)\n\ni = Index(h,:i,N,ha)\nj = Index(h,:j,N,ha)","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"We define the Hamiltonian using symbolic sums and define the individual dissipative processes. For an indexed jump operator the (symbolic) sum is build in the Liouvillian.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# Hamiltonian\nH = -Δ*a'a + Σ(g(i)*( a'*σ(1,2,i) + a*σ(2,1,i) ),i)\n\n# Jump operators with corresponding rates\nJ = [a, σ(1,2,i), σ(2,1,i), σ(2,2,i)]\nrates = [κ, Γ, R, ν]\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"First we want to derive the equation for langle a^dagger a rangle and langle sigma_j^22 rangle. Note that you can only use indices on the LHS which haven't been used for the Hamiltonian and the jumps.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# Derive equations\nops = [a'*a, σ(2,2,j)]\neqs = meanfield(ops,H,J;rates=rates,order=2)\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"beginalign\nfracddt langle a^dagger  arangle  = 1 i undersetioversetNsum g_i  langle a  sigma_i^21rangle  -1 i undersetioversetNsum g_i  langle a^dagger  sigma_i^12rangle  -10 kappa langle a^dagger  arangle  \nfracddt langle sigma_j^22rangle  = R -10 R langle sigma_j^22rangle  + 1 i g_j langle a^dagger  sigma_j^12rangle  -1 i g_j langle a  sigma_j^21rangle  -10 Gamma langle sigma_j^22rangle\nendalign","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"To get a closed set of equations we automatically complete the system. Since this system is phase invariant we know that all averages with a phase are zero, therefore we exclude these terms with a filter function. To be able to dispatch on all kind of sums containing averages we defined the Union textttAvgSums.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# custom filter function\nφ(x::Average) = φ(x.arguments[1])\nφ(::Destroy) = -1\nφ(::Create) =1\nφ(x::QTerm) = sum(map(φ, x.args_nc))\nφ(x::Transition) = x.i - x.j\nφ(x::IndexedOperator) = x.op.i - x.op.j\nφ(x::SingleSum) = φ(x.term)\nφ(x::AvgSums) = φ(arguments(x))\nphase_invariant(x) = iszero(φ(x))\n\n# Complete equations\neqs_c = complete(eqs; filter_func=phase_invariant)\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"beginalign\nfracddt langle a^dagger  arangle  = 1 i undersetioversetNsum g_i  langle a  sigma_i^21rangle  -1 i undersetioversetNsum g_i  langle a^dagger  sigma_i^12rangle  -10 kappa langle a^dagger  arangle  \nfracddt langle sigma_j^22rangle  = R -10 R langle sigma_j^22rangle  + 1 i g_j langle a^dagger  sigma_j^12rangle  -1 i g_j langle a  sigma_j^21rangle  -10 Gamma langle sigma_j^22rangle  \nfracddt langle a^dagger  sigma_j^12rangle  = 1 i undersetinejoversetNsum g_i  langle sigma_i^21  sigma_j^12rangle  + 1 i g_j langle sigma_j^22rangle  -1 i g_j langle a^dagger  arangle  -05 R langle a^dagger  sigma_j^12rangle  -05 Gamma langle a^dagger  sigma_j^12rangle  -05 kappa langle a^dagger  sigma_j^12rangle  -05 nu langle a^dagger  sigma_j^12rangle  -1 i Delta langle a^dagger  sigma_j^12rangle  + 2 i g_j langle sigma_j^22rangle  langle a^dagger  arangle  \nfracddt langle sigma_j^12  sigma_k^21rangle  = left( -10 R -10 Gamma right) langle sigma_j^12  sigma_k^21rangle  -1 i g_j langle a  sigma_k^21rangle  + 1 i g_k langle a^dagger  sigma_j^12rangle  -10 nu langle sigma_j^12  sigma_k^21rangle  + 2 i g_j langle sigma_j^22rangle  langle a  sigma_k^21rangle  -2 i g_k langle sigma_k^22rangle  langle a^dagger  sigma_j^12rangle\nendalign","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"As mentioned before, we assume that all atoms behave identically. This means that e.g. the excited state population is equal for all atoms, hence we only need to calculate it for the first langle sigma^22_1 rangle = langle sigma^22_j rangle. Furthermore, it is clear that a sum over N identical objects can be replaced by N times the object. The function textttscale() uses these rules to simplify the equations.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"eqs_sc = scale(eqs_c)\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"beginalign\nfracddt langle a^dagger  arangle  = -10 kappa langle a^dagger  arangle  -1 i N g_1 langle a^dagger  sigma_1^12rangle  + 1 i N g_1 langle a  sigma_1^21rangle  \nfracddt langle sigma_1^22rangle  = R -10 R langle sigma_1^22rangle  -10 Gamma langle sigma_1^22rangle  + 1 i g_1 langle a^dagger  sigma_1^12rangle  -1 i g_1 langle a  sigma_1^21rangle  \nfracddt langle a^dagger  sigma_1^12rangle  = -05 R langle a^dagger  sigma_1^12rangle  -05 Gamma langle a^dagger  sigma_1^12rangle  -05 kappa langle a^dagger  sigma_1^12rangle  -05 nu langle a^dagger  sigma_1^12rangle  + 1 i g_1 langle sigma_1^22rangle  -1 i g_1 langle a^dagger  arangle  -1 i Delta langle a^dagger  sigma_1^12rangle  + 1 i g_1 left( -1 + N right) langle sigma_1^12  sigma_2^21rangle  + 2 i g_1 langle sigma_1^22rangle  langle a^dagger  arangle  \nfracddt langle sigma_1^12  sigma_2^21rangle  = left( -10 R -10 Gamma right) langle sigma_1^12  sigma_2^21rangle  + 1 i g_1 langle a^dagger  sigma_1^12rangle  -1 i g_1 langle a  sigma_1^21rangle  -10 nu langle sigma_1^12  sigma_2^21rangle  -2 i g_1 langle sigma_1^22rangle  langle a^dagger  sigma_1^12rangle  + 2 i g_1 langle sigma_1^22rangle  langle a  sigma_1^21rangle\nendalign","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"To calculate the dynamics of the system we create a system of ordinary differential equations, which can be used by DifferentialEquations.jl.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"@named sys = ODESystem(eqs_sc)\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"Finally we need to define the numerical parameters and the initial value of the system. We will consider 2 cdot 10^5 Strontium atoms which are repumped with a rate of R = 1textHz on the clock transition (Gamma = 1 textmHz). The atom-cavity coupling rate is g = 1textHz, the cavity has a linewidth of kappa = 5textkHz and is detuned from the atomic resonance by Delta = 25textHz.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# Initial state\nu0 = zeros(ComplexF64, length(eqs_sc))\n# System parameters\nN_ = 2e5\nΓ_ = 1.0 #Γ=1mHz\nΔ_ = 2500Γ_ #Δ=2.5Hz\ng_ = 1000Γ_ #g=1Hz\nκ_ = 5e6*Γ_ #κ=5kHz\nR_ = 1000Γ_ #R=1Hz\nν_ = 1000Γ_ #ν=1Hz\n\nps = [N, Δ, g(1), κ, Γ, R, ν]\np0 = [N_, Δ_, g_, κ_, Γ_, R_, ν_]\n\nprob = ODEProblem(sys,u0,(0.0, 1.0/50Γ_), ps.=>p0)\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"# Solve the numeric problem\nsol = solve(prob,Tsit5(),maxiters=1e7)\n\n# Plot time evolution\nt = sol.t\nn = real.(sol[a'a])\ns22 = real.(sol[σ(2,2,1)])\n# Plot\np1 = plot(t, n, xlabel=\"tΓ\", ylabel=\"⟨a⁺a⟩\", legend=false)\np2 = plot(t, s22, xlabel=\"tΓ\", ylabel=\"⟨σ22⟩\", legend=false)\nplot(p1, p2, layout=(1,2), size=(700,300))","category":"page"},{"location":"examples/superradiant_laser_indexed/#Spectrum","page":"Superradiant Laser","title":"Spectrum","text":"","category":"section"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"We calculate the spectrum here with the Laplace transform of the two-time correlation function. This is implemented with the function textttSpectrum.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"corr = CorrelationFunction(a', a, eqs_c; steady_state=true, filter_func=phase_invariant)\ncorr_sc = scale(corr)\nS = Spectrum(corr_sc, ps)\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"The set of equations for the correlation function is given by","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"corr_sc.de\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"beginalign\nfracddtau langle a^dagger  a_0rangle  = -05 kappa langle a^dagger  a_0rangle  -1 i Delta langle a^dagger  a_0rangle  + 1 i N g_1 langle sigma_1^21  a_0rangle  \nfracddtau langle sigma_1^21  a_0rangle  = -05 R langle sigma_1^21  a_0rangle  + 1 i g_1 langle a^dagger  a_0rangle  -05 Gamma langle sigma_1^21  a_0rangle  -05 nu langle sigma_1^21  a_0rangle  -2 i g_1 langle sigma_1^22rangle  langle a^dagger  a_0rangle\nendalign","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"To ensure we are in the steady state we use a steady solver to calculate it. To this end we need to define the textttSteadyStateProblem and specify the desired method. We also need to increase the textttmaxiters and the solver accuracy to handle this numerically involved problem.","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"prob_ss = SteadyStateProblem(prob)\nsol_ss = solve(prob_ss, DynamicSS(Tsit5(); abstol=1e-8, reltol=1e-8),\n        reltol=1e-14, abstol=1e-14, maxiters=5e7)\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"The spectrum is then calculated with","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"ω = [-10:0.01:10;]Γ_\nspec = S(ω,sol_ss.u,p0)\nspec_n = spec ./ maximum(spec)\nδ = abs(ω[(findmax(spec)[2])])\nnothing # hide","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"plot(ω, spec_n, xlabel=\"ω/Γ\", legend=false, size=(500,300))","category":"page"},{"location":"examples/superradiant_laser_indexed/","page":"Superradiant Laser","title":"Superradiant Laser","text":"Beside the narrow linewidth we can also see another key feature of the superradiant laser here, namely the very weak cavity pulling. At a detunig of Delta = 2500Gamma there is only a shift of the laser light from the atomic resonance frequency of delta = 1Gamma.","category":"page"},{"location":"examples/filter-cavity_indexed/#Laser-with-Filter-Cavities","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"","category":"section"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"An intuitive and straightforward approach to calculate the spectrum of a laser is to filter the emitted light. We can do this by coupling filter cavities with different detunings to the main cavity and observe the photon number in these 'filters', see for example K. Debnath et al., Phys Rev A 98, 063837 (2018).","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"The main goal of this example is to combine two indexed Hilbert spaces, where one will be scaled and the other evaluated. The model is basically the same as for the superradiant laser example, but with the additional terms due to the filter cavities. The Hamiltonian of this system is","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"beginequation\nH = - Delta a^dagger a + g sumlimits_j=1^N (a^dagger sigma^12_j + a sigma^21_j) - sumlimits_i=1^M delta_i b_i^dagger b_i +  g_f sumlimits_i=1^M (a^dagger b_i + a b_i^dagger)\nendequation","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"where delta_i is the detuning of the i-th filter cavity and g_f the coupling to the normal cavity. Furthermore, their decay rate is kappa_f.","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"We start by loading the packages.","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"using QuantumCumulants\nusing OrdinaryDiffEq, SteadyStateDiffEq, ModelingToolkit\nusing Plots","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"We create the parameters of the system including the textttIndexedVariable delta_i. For the atoms and filter cavities we only need one Hilbert space each. We define the indices for each Hilbert space and use them to create textttIndexedOperators.","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"# Paramters\n@cnumbers κ g gf κf R Γ Δ ν N M\nδ(i) = IndexedVariable(:δ, i)\n\n# Hilbertspace\nhc = FockSpace(:cavity)\nhf = FockSpace(:filter)\nha = NLevelSpace(:atom, 2)\nh = hc ⊗ hf ⊗ ha\n\n# Indices and Operators\ni = Index(h,:i,M,hf)\nj = Index(h,:j,N,ha)\n\n@qnumbers a::Destroy(h,1)\nb(k) = IndexedOperator(Destroy(h,:b,2), k)\nσ(α,β,k) = IndexedOperator(Transition(h,:σ,α,β,3), k)","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"We define the Hamiltonian using symbolic sums and define the individual dissipative processes. For an indexed jump operator the (symbolic) sum is build in the Liouvillian, in this case corresponding to individual decay processes.","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"# Hamiltonian\nH = Δ*Σ(σ(2,2,j),j) + Σ(δ(i)*b(i)'b(i),i) +\n    gf*(Σ(a'*b(i) + a*b(i)',i)) + g*(Σ(a'*σ(1,2,j) + a*σ(2,1,j),j))\n\n# Jumps & rates\nJ = [a, b(i), σ(1,2,j), σ(2,1,j), σ(2,2,j)]\nrates = [κ, κf, Γ, R, ν]\nnothing # hide","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"We derive the equation for langle a^dagger a rangle and complete the system automatically in second order.","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"eqs = meanfield(a'a,H,J;rates=rates,order=2)\nnothing # hide","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"beginalign\nfracddt langle a^dagger  arangle  = 1 i undersetioversetMsum gf  langle a  b_i^daggerrangle  -1 i undersetioversetMsum gf  langle a^dagger  b_irangle  + 1 i undersetjoversetNsum g  langle a  sigma_j^21rangle  -1 i undersetjoversetNsum g  langle a^dagger  sigma_j^12rangle  -10 kappa langle a^dagger  arangle\nendalign","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"eqs_c = complete(eqs);\nnothing # hide","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"Now we assume that all atoms behave identically, but we want to obtain the equations for 20 different filter cavities. To this end we textttscale the Hilbert space of the atoms and textttevaluate the filter cavities. Specifying the Hilbert space is done with the kwarg texttth, which can either be the specific Hilbert space or its acts-on number. Evaluating the filter cavities requires a numeric upper bound for the used textttIndex, we provide this with a dictionary on the kwarg textttlimits.","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"M_ = 20\neqs_sc = scale(eqs_c;h=[ha]) #h=[3]\neqs_eval = evaluate(eqs_sc; limits=Dict(M=>M_)) #h=[hf]\nprintln(\"Number of eqs.: $(length(eqs_eval))\")","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"To calculate the dynamics of the system we create a system of ordinary differential equations, which can be used by DifferentialEquations.jl. Finally we need to define the numerical parameters and the initial state of the system.","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"@named sys = ODESystem(eqs_eval)\nnothing # hide","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"# Initial state\nu0 = zeros(ComplexF64, length(eqs_eval))\n\n# System parameters\nN_ = 200\nΓ_ = 1.0\nΔ_ = 0Γ_\ng_ = 1Γ_\nκ_ = 100Γ_\nR_ = 10Γ_\nν_ = 1Γ_\n\ngf_ = 0.1Γ_\nκf_ = 0.1Γ_\nδ_ls = [0:1/M_:1-1/M_;]*10Γ_\n\nps = [Γ, κ, g, κf, gf, R, [δ(i) for i=1:M_]..., Δ, ν, N]\np0 = [Γ_, κ_, g_, κf_, gf_, R_, δ_ls..., Δ_, ν_, N_]\n\nprob = ODEProblem(sys,u0,(0.0, 10.0/κf_), ps.=>p0)\nnothing # hide","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"# Solve the numeric problem\nsol = solve(prob, Tsit5(); abstol=1e-10, reltol=1e-10, maxiters=1e7)\n\nt = sol.t\nn = abs.(sol[a'a])\nn_b(i) =  abs.(sol[b(i)'b(i)])\nn_f = [abs(sol[b(i)'b(i)][end]) for i=1:M_] ./ (abs(sol[b(1)'b(1)][end]))\nnothing # hide","category":"page"},{"location":"examples/filter-cavity_indexed/","page":"Laser with Filter Cavities","title":"Laser with Filter Cavities","text":"# Plot results\np1 = plot(t, n_b(1), alpha=0.5, ylabel=\"⟨bᵢ⁺bᵢ⟩\", legend=false)\nfor i=2:M_\n    plot!(t, n_b(i), alpha=0.5, legend=false)\nend\n#p1 = plot!(twinx(), t, n, xlabel=\"tΓ\", ylabel=\"⟨a⁺a⟩\", legend=false)\n\np2 = plot([-reverse(δ_ls);δ_ls], [reverse(n_f);n_f], xlabel=\"δ/Γ\", ylabel=\"intensity\", legend=false)\nplot(p1, p2, layout=(1,2), size=(700,300))","category":"page"},{"location":"examples/many-atom-laser/#Many-atom-laser","page":"Many-atom laser","title":"Many-atom laser","text":"","category":"section"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"This example describes a second order laser system consisting of N three-level atoms coupled to a single mode cavity. An auxiliary state 3rangle, which quickly decays into the upper lasing state 2rangle, is coherently pumped to achieve population inversion on the lasing transition 1rangle leftrightarrow 2rangle. The Hamiltonian of this system is given by","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"H = -Delta_c a^dagger a  - sum_i=1^N left Delta_3^i sigma_i^33  + g_i (a^dagger sigma_i^12 + asigma_i^21) + Omega_i (sigma_i^31 + sigma_i^13) right","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Including dissipative processes as, e.g. the atomic decay or photon losses through the cavity mirrors, makes it an open quantum system. In the Schrödinger picture we would compute the dynamics of such open quantum systems with a density matrix rho according to a master equation (see e.g. https://docs.qojulia.org/),","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"fracddt rho = - fracihbar left H rho right + mathcalLrho","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"with mathcalLrho = fracgamma2 (2 J rho J^dagger - J^dagger J rho - rho J^dagger J) the Liouvillian superoperator in standard Lindblad form for a dissipative process with jump operator J and rate R.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"With QuantumCumulants.jl we describe the system dynamics with averages, which are deduced from the operator equations of motion in the Heisenberg picture. In the Heisenberg picture open systems are described by the quantum Langevin equation. Assuming white noise, we can omit the stochastic terms of the quantum Langevin equation when computing averages. Thus we get the following equation for the time evolution of a system operator average langle O rangle (if O is not explicitly time dependent):","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"fracddt langle O rangle = fracihbar left H O right + barmathcalLO","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"The superoperator barmathcalLO is similar to the Lindblad term in the Schrödinger picture, except that J and J^dagger are swapped in the first term, i.e. barmathcalLO = fracgamma2 (2 J^dagger O J - J^dagger J O - O J^dagger J), for a dissipative process with jump operator J and rate R.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"For our system we have four different dissipative processes with the jump operators a, sigma^12_i, sigma^13_i and sigma^23_i, and the corresponding decay rates kappa, Gamma^i_12, Gamma^i_13 and Gamma^i_23, respectively.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"We start by loading the needed packages.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"using QuantumCumulants\nusing ModelingToolkit, OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Then we define the symbolic parameters of the system, the Hilbertspace and the necessary operators. We define an atomic transition operator function sigma(ijk) for the transition from j rangle to i rangle of atom k. Since we only have one FockSpace we do not need to specify the Hilbertspace on which the Destroy operator acts. For the different atomic transitions, however, we need to specify this, since there is more than one NLevelSpace. This information is stored in the .aon field of each operator.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# Parameters\nN = 2 #number of atoms\nκ, g, Γ23, Γ13, Γ12, Ω, Δc, Δ3 = cnumbers(\"κ g Γ_{23} Γ_{13} Γ_{12} Ω Δ_c Δ_3\")\n\n# Hilbertspace\nhf = FockSpace(:cavity)\nha = ⊗([NLevelSpace(Symbol(:atom,i),3) for i=1:N]...)\nh = hf ⊗ ha\n\n# Operators\na = Destroy(h,:a)\nσ(i,j,k) = Transition(h,Symbol(\"σ_{$k}\"),i,j,k+1)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Now we create the Hamiltonian and the jumps with the corresponding rates of our laser system. We assume here that all atoms are identical.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# Hamiltonian\nH = -Δc*a'a + sum(g*(a'*σ(1,2,i) + a*σ(2,1,i)) for i=1:N) + sum(Ω*(σ(3,1,i) + σ(1,3,i)) for i=1:N) - sum(Δ3*σ(3,3,i) for i=1:N)\n\n# Jumps\nJ = [a;[σ(1,2,i) for i=1:N];[σ(1,3,i) for i=1:N];[σ(2,3,i) for i=1:N]]\n\n# Rates\nrates = [κ;[Γ12 for i=1:N];[Γ13 for i=1:N];[Γ23 for i=1:N]]\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Later we will complete the system automatically, which has the disadvantage that the equations are not ordered. Therefore we define a list of interesting operators, which we want to use later. Note that at least one operator(-product) is needed. We derive the equations for these operators, average them, and automatically complete the system of equations.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# list of operators\nops = [a'a, σ(2,2,1), σ(3,3,1)]\n\neqs = meanfield(ops,H,J; rates=rates)\neqs_expanded = cumulant_expansion(eqs,2) #second order average\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"beginalign\nfracddt langle a^dagger  arangle  = -10 i g left( langle a^dagger  sigma_1^12rangle  + langle a^dagger  sigma_2^12rangle  right) + 10 i g left( langle a  sigma_1^21rangle  + langle a  sigma_2^21rangle  right) -10 kappa langle a^dagger  arangle  \nfracddt langle sigma_1^22rangle  = langle sigma_1^33rangle  Gamma_23 -10 langle sigma_1^22rangle  Gamma_12 + 10 i g langle a^dagger  sigma_1^12rangle  -10 i g langle a  sigma_1^21rangle  \nfracddt langle sigma_1^33rangle  = -10 i langle sigma_1^31rangle  Omega + 10 i langle sigma_1^13rangle  Omega -10 langle sigma_1^33rangle  left( Gamma_13 + Gamma_23 right)\nendalign","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"me_comp = complete(eqs_expanded) #automatically complete the system\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"To calculate the time evolution we create a Julia function which can be used by DifferentialEquations.jl to solve the set of ordinary differential equations.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# Build an ODESystem out of the MeanfieldEquations\n@named sys = ODESystem(me_comp)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Finally we compute the time evolution after defining an initial state and numerical values for the parameters.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# initial state\nu0 = zeros(ComplexF64, length(me_comp))\n\nΓ12n = 1.0\nΓ23n = 20Γ12n\nΓ13n = 2Γ12n\nΩn = 5Γ13n\ngn = 2Γ12n\nΔcn = 0.0\nΔ3n = 0.0\nκn = 0.5Γ12n\n\n# list of parameters\nps = (g, Γ23, Γ13, Γ12, Ω, Δc, Δ3, κ)\np0 = ps .=> (gn, Γ23n, Γ13n, Γ12n, Ωn, Δcn, Δ3n, κn)\ntend = 10.0/κn\n\nprob = ODEProblem(sys,u0,(0.0,tend),p0)\nsol = solve(prob, Tsit5(), reltol=1e-8, abstol=1e-8)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"We plot the average photon number and the population inversion of the lasing transition.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"n_t = real.(sol[average(a'*a)])\nσ22m11_t = real.(2*sol[σ(2,2,1)] .+ sol[σ(3,3,1)] .-1 ) #σ11 + σ22 + σ33 = 𝟙\n\n# Plot\np1 = plot(sol.t, n_t, xlabel=\"tΓ₁₂\", ylabel=\"⟨a⁺a⟩\", legend = false)\np2 = plot(sol.t, σ22m11_t, xlabel=\"tΓ₁₂\", ylabel=\"⟨σ22⟩ - ⟨σ11⟩\", legend = false)\nplot(p1, p2, layout=(1,2), size=(800,300))","category":"page"},{"location":"examples/excitation-transport-chain/#Noisy-excitation-transport","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"","category":"section"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"In this example, we will look at the energy transport in a one-dimensional chain of atoms, where only the first atom is driven. The excitation can then move from one atom to another via position-dependent dipolar interactions between nearest neighbors.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"The Hamiltonian of this system reads","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"H = -Delta sum_j sigma_j^ee + Omegaleft(sigma_1^eg + sigma_1^geright) + sum_j=1^N-1J(x_ix_j)left(sigma_j^egsigma_j+1^ge + sigma_j^gesigma_j+1^egright)","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"The first term describes the energy of the excited atomic state in the rotating frame of the driving laser with the detuning Delta. The second term describes the driving of the first atom with a laser with a Rabi frequency Omega. Finally, the interactions between nearest neighbors are included with the position-dependent interaction","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"J(x_ix_j) = fracJ_0x_i - x_j^3","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"where J_0 is the strength of the interaction at unit distance. The positions of the atoms x_i are in units of the transition wavelength. Furthermore, each atom is subject to spontaneous emission at a rate gamma with the collapse operator sigma_j^ge.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"We will start by simulating the system as described above. Specifically, we compute the efficiency of the excitation transport by looking at the excited state population of the atom at the end of the chain opposite to the driven atom. Finally, we show how one can generalize the system to include random fluctuations in the atomic position. We can then investigate the effect of the positional noise on the efficiency of the energy transport.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"As always, we start by loading the packages we use and some basic definitions.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"using QuantumCumulants\nusing ModelingToolkit, OrdinaryDiffEq\nusing Plots\n\n\n# Hilbert space for N atoms\nN = 10\nh = ⊗([NLevelSpace(Symbol(:atom, i), (:g,:e)) for i=1:N]...)\n\n# Operators\nσ(i,j,k) = Transition(h,Symbol(:σ_,k),i,j,k)\n\n# Define the symbolic parameters and the interaction\n@cnumbers Ω γ w Δ J0\nx = cnumbers(join([\"x_$i\" for i=1:N], \" \"))\nJ(xᵢ,xⱼ) = J0 / abs(xᵢ - xⱼ)^3\n\n# Specify the Hamiltonian and the collapse operators\nH = -Δ*sum(σ(:e,:e,k) for k=1:N) + Ω*(σ(:e,:g,1) + σ(:g,:e,1)) +\n    sum(J(x[k],x[k+1])*(σ(:e,:g,k)*σ(:g,:e,k+1) + σ(:g,:e,k)*σ(:e,:g,k+1)) for k=1:N-1)\n\nc_ops = [σ(:g,:e,k) for k=1:N]\nnothing # hide","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"The above definitions are all we need to derive the set of equations. Here, we will include terms up to second order. Note, that in order to include noise, we will not need to make any adaptions on a symbolic level. Rather, we only need to derive the equations once and substitute the noisy positions accordingly when performing the numerical solutions.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"# Derive the equations to second order\neqs = meanfield(σ(:g,:e,1),H,c_ops;rates=[γ for i=1:N],order=2)\ncomplete!(eqs)  # complete the set\n\n# Generate the ODESystem\n@named sys = ODESystem(eqs)\nnothing # hide","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"Once we have our set of equations and converted it to an ODESystem we are ready to solve for the dynamics. First, let's have a look at the excitation transport for perfectly positioned atoms. We assume an equidistant chain, were neighboring atoms are separated by a distance d.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"# Define parameters without noise\nd = 0.75\nx0 = [d*(k-1) for k=1:N]\np = [γ => 1.0; Δ => 0.0; Ω => 2.0; J0 => 1.25; x .=> x0;]\n\n# Create ODEProblem\nu0 = zeros(ComplexF64, length(eqs))  # initial state -- all atoms in the ground state\nprob = ODEProblem(sys,u0,(0.0,15.0),p)\n\n# Solve\nsol = solve(prob,RK4())\n\n# Plot\ngraph = plot(sol.t, real.(sol[σ(:e,:e,1)]), label=\"Driven atom\",\n            xlabel=\"γt\", ylabel=\"Excited state population\")\nplot!(graph, sol.t, real.(sol[σ(:e,:e,N)]), label=\"End of chain\", leg=1)","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"As you can see, the excitation transport is reasonably efficient, resulting in an excited state population at the end of the chain well above 10%.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"Now, we will introduce some noise in the atomic positions. In order to do so, we make use of the convenient ensemble simulation feature from the OrdinaryDiffEq library. For each trajectory, we recreate the original ODEProblem with a new set of atomic positions. We assume that each atom is located around the same point as before in the equidistant chain. However, we account for imperfect positioning in that the actual position of each atom is randomly modified. The strength of these position fluctuations is given by a parameter s, and the random fluctuations are sampled from a Gaussian distribution.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"Each trajectory we simulate can be thought of as one realization of an experiment, where the atoms are trapped with imperfect accuracy.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"In the following, we define the function that sets up the new ODEProblem for a realization and solve a specified number of trajectories.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"s = d/30  # strength of fluctuations\nfunction prob_func(prob,i,repeat)\n    # Define the new set of parameters\n    x_ = x0 .+ s.*randn(N)\n    p_ = [γ => 1.0; Δ => 0.0; Ω => 2.0; J0 => 1.25; x .=> x_;]\n\n    # Convert to numeric values only\n    pnum = ModelingToolkit.varmap_to_vars(p_,parameters(sys))\n\n    # Return new ODEProblem\n    return remake(prob, p=pnum)\nend\n\ntrajectories = 50\neprob = EnsembleProblem(prob,prob_func=prob_func)\nsim = solve(eprob,RK4(),trajectories=trajectories)\nnothing # hide","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"Finally, we average over the results and compare them against the results from before, where there was no noise in the atomic positioning.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"# Average resulting excitations\ntspan = range(0.0, sol.t[end], length=101)\npops_avg = zeros(length(tspan), N)\nfor i=1:N, j=1:trajectories\n    sol_ = sim.u[j].(tspan)  # interpolate solution\n    p_idx = findfirst(isequal(average(σ(:e,:e,i))), states(eqs))\n    pop = [u[p_idx] for u ∈ sol_]\n    @. pops_avg[:,i] += pop / trajectories\nend\n\nplot!(graph, tspan, pops_avg[:,1], color=:steelblue, ls=:dash, label=nothing)\nplot!(graph, tspan, pops_avg[:,N], color=:orange, ls=:dash, label=nothing)","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"In the above graph, the solid lines are the ones from before, where we did not include any position fluctuations. The dashed lines with the corresponding colors show the results when averaging over many noisy realizations.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"As we can see, more of the excited state population remains in the driven atom at the beginning of the chain. The efficiency of the transport is somewhat reduced and only approximately 10% excited state population are reached in the atom at the other end.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"We can also plot the results for each trajectory on top of the average. Let's look at each trajectory of the excited state population of the atom at the end of the chain.","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"graph2 = plot(xlabel=\"γt\", ylabel=\"Excitation at end of chain\")\nfor i=1:trajectories\n    plot!(graph2, sim.u[i].t, real.(sim.u[i][σ(:e,:e,N)]), color=:steelblue, label=nothing)\nend\nplot!(graph2, tspan, pops_avg[:,N], lw=4, label=\"Average over trajectories\", color=:orange)","category":"page"},{"location":"examples/excitation-transport-chain/","page":"Noisy excitation transport","title":"Noisy excitation transport","text":"As you can see, in some realizations the transport is almost not hindered at all. On average, however, the transport efficiency is reduced quite a bit.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumCumulants.jl offers a practical approach to the application of the generalized cumulant expansion method in Quantum Optics: operators are often represented by matrices on a Hilbert space, where a suitable basis has been chosen. These matrices can quickly become so large that they can no longer be stored. On a more abstract level, however, operators form a noncommutative alebgra that follows fundamental commutation relations. This is where QuantumCumulants.jl comes in. The basic working principle boils down to the following steps:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The model (Hamiltonian) is specified.\nEquations of motion for average values are derived. This is done by using the fundamental commutation relations of operators. The resulting equations are stored as symbolic equations using the Symbolics.jl framework, which is also used for any additional simplification and rewriting.\nThen follows the key step: the equations of motion the averages are truncated at a specified order neglecting higher-order quantum correlations using the generalized cumulant expansion method. This results in a closed set of c-number ordinary differential equations.\nFinally, the symbolic system of equations can be turned into an ODESystem of the ModelingToolkit.jl framework which bridges the gap from symbolics to numerics. This makes it straightforward to obtain a solution of the time dynamics of a system within the  DifferentialEquations.jl ecosystem.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuantumCumulants.jl is a registered Julia package and can be installed using the package manager:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"|pkg> add QuantumCumulants","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For a full list of functions, check out the API.","category":"page"},{"location":"implementation/#Implementation","page":"Implementation","title":"Implementation","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Let's take a closer look at each step involved from defining a system to arriving at a numerical solution of the underlying time dynamics.","category":"page"},{"location":"implementation/#Hilbert-spaces","page":"Implementation","title":"Hilbert spaces","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The first step in treating a system with QuantumCumulants.jl is to specify the Hilbert space on which the system is defined. There are two types of Hilbert spaces implemented, namely FockSpace and NLevelSpace. The first describes systems whose operators follow the fundamental bosonic commutation relations (such as the quantum harmonic oscillator), whereas the latter describes systems consisting of a finite number of energy levels with an arbitrary energy difference in between (such as atoms).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"A FockSpace simply needs a name in order to be defined:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nhf = FockSpace(:fock1)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"NLevelSpace requires a name as well as labels for the energy levels. For example","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_atom = NLevelSpace(:atom, (:g,:e))\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"defines an NLevelSpace with the name :atom and the two levels labeled by :g and :e, respectively. Note that the levels can be labeled by (almost) anything. For example, NLevelSpace(:two_level, (1,2)) would define a Hilbert space describing a system with the two discrete energy levels labeled by 1 and 2. Specifically for numbers, there is also the short-hand method to write NLevelSpace(:five_level, 5) which creates a system with levels 1:5. Note that by default the first level in the list of all levels is designated as the ground state. This can be changed by specifying the ground state explicitly as a third argument to NLevelSpace, e.g. NLevelSpace(:four_level, 4, 2) would designate the state 2 as the ground state. The ground state projector will be eliminated during simplification (see below).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Composite systems are generally described by a ProductSpace, i.e. a Hilbert space that consists of multiple subspaces. Each subspace is either a FockSpace or an NLevelSpace. They can be created using the tensor function or the unicode symbol ⊗ [\\otimes]. For example","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_prod1 = tensor(hf, h_atom)\nh_prod2 = tensor(h_prod1, NLevelSpace(:three_level, 3))\nh_prod3 = tensor(hf, h_atom, NLevelSpace(:three_level, 3)) # == h_prod2\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"creates two product spaces. The first, h_prod1, consists of the previously defined FockSpace(:fock1) and NLevelSpace(:atom, (:g,:e)). The second one, h_prod2, adds in another NLevelSpace(:three_level, 3). In principle arbitrarily many systems can be combined this way.","category":"page"},{"location":"implementation/#Operators-(a.k.a.-*q*-numbers)","page":"Implementation","title":"Operators (a.k.a. q-numbers)","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Once the Hilbert space of the system has been defined, we can proceed by defining operators, or q-numbers, on them. They are the fundamental building blocks of symbolic expressions in QuantumCumulants.jl. Again, there are essentially two kinds of operators implemented: the quantum harmonic destruction operator Destroy which acts on a FockSpace, as well as a Transition operator which describes a transition between any two levels on an NLevelSpace. These operators can only be defined on the corresponding Hilbert spaces. Note that there is no intrinsic reason that prevents us from implementing more types of operators (see below), there was simply no need to do that so far.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Here are a few examples:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nhf = FockSpace(:fock)\na = Destroy(hf, :a)\n\nh_atom = NLevelSpace(:atom,(:g,:e))\nσge = Transition(h_atom, :σ, :g, :e)\nσ = Transition(h_atom, :σ)\n@assert isequal(σge, σ(:g,:e)) # true\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"As you can see, the destruction operator Destroy is created on a FockSpace and given a name. The transition operator, however, additionally requires you to specify the levels between which it describes the transition. Defining a transition without levels specified creates a callable instance which needs to be called with valid level labels before one can actually use it in any algebraic expressions. Note that in Bra-Ket notation, the transition operator Transition(h, i, j) is simply irangle langle j. Also, the bosonic creation operator is simply given by the adjoint of Destroy.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"These fundamental operators are all of subtypes of QSym, and constitute the basic symbolic building blocks for the noncommutative algebra used in QuantumCumulants.jl. They can be combined using standard algebraic functions.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"ex_fock = 0.1*a'*a\nex_trans = im*(σ(:g,:e) - σ(:e,:g))\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that only operators that are defined on the same Hilbert space can be algebraically combined. The resulting expressions are stored as QTerm types.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"In composite systems, we also need to specify on which subsystem the respective operator acts. This information is important as operators acting on different subsystems commute with one another, but operators acting on the same one do not. When multiplying together operators in a composite systems, they are automatically ordered according to the order of Hilbert spaces. It's specified by an additional argument when creating operators.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2)\na = Destroy(h_prod,:a,1)\nb = Destroy(h_prod,:b,2)\na*b # a*b\nb*a # a*b\na'*b*a # a'*a*b\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"If a subspace occurs only once in a ProductSpace, the choice on which an operator acts is unique and can therefore be omitted on construction.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h_prod = FockSpace(:fock1) ⊗ FockSpace(:fock2) ⊗ NLevelSpace(:atom,(:g,:e))\nσ = Transition(h_prod, :σ) # no need to specify acts_on\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For convenience, there is also a macro that can be used to construct operators:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h = FockSpace(:fock) ⊗ NLevelSpace(:two_level, 2)\n@qnumbers a::Destroy(h) σ::Transition(h)\nex = a'*σ(1,2) + a*σ(2,1)\nnothing # hide","category":"page"},{"location":"implementation/#Symbolic-parameters-(a.k.a.-*c*-numbers)","page":"Implementation","title":"Symbolic parameters (a.k.a. c-numbers)","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Commutative numbers (c-numbers) are represented by SymbolicUtils.Sym from the SymbolicUtils.jl package and a custom subtype to Number called CNumber. They are generally assumed to be complex numbers and can be defined with the cnumbers function or the corresponding macro @cnumbers. You can use them together with q-numbers to build symbolic expressions describing the Hamiltonian, e.g.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nh = FockSpace(:fock)\n@cnumbers ω η\n@qnumbers a::Destroy(h)\nH = ω*a'*a + η*(a + a')\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Real numbers (r-numbers) are similar to c-numbers, except that they are their own complex conjugate. They can be defined with the rnumbers function or the corresponding macro @rnumbers. ","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\n@rnumbers ω η\nω' # ω \nexp(1im*η)*(exp(1im*η))' # 1\nnothing # hide","category":"page"},{"location":"implementation/#Operator-expressions-and-commutation-relations","page":"Implementation","title":"Operator expressions and commutation relations","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The equations of motion of q-numbers are determined by evaluating commutators. This can be done by using fundamental commutation relations, which are immediately applied whenever operators are combined in an algebraic expression.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For the quantum harmonic oscillator destruction operator a, we have the canonical commutator","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"aa^dagger = 1","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Within the framework, we choose normal ordering, which surmounts to the rewriting rule","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"a a^dagger Rightarrow a^dagger a +1","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"For transition operators sigma^ij denoting a transition from level j to level i, on the other hand, we have a rule for products,","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"sigma^ijsigma^kl Rightarrow delta_jksigma^il","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"which is implemented as rewriting rule just so. Additionally, we use the fact that in a system with levels 1n","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"sum_j=1^n sigma^jj = 1","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"in order to eliminate the projector on the ground state. This reduces the amount of equations required for each NLevelSpace by 1. Note that, as mentioned before, the ground state is by default chosen to be the first (but this can be changed). Hence, the default rewriting rule to eliminate the ground-state projector is","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"sigma^11 Rightarrow 1 - sum_j=2^n sigma^jj","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Any expression involving operators is stored as a QTerm type. The expression trees are structured such that the application of commutation relations can be done efficiently. There are two concrete subtypes of QTerm, namely QMul representing a multiplication and QAdd representing an addition. Methods of multiplication and addition are implemented such that QSym < QMul < QAdd, i.e. a multiplication can only consist of numbers and fundamental operators (it cannot contain another multiplication or addition) and QAdd is always at the highest level possibly containing numbers, QSyms and QMuls (but no other QAdds). This makes it easy and efficient to recurse through the expression tree and find pairs of operators that should be rewritten according to some commutation relation.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that only simplification using commutation relations is implemented directly in QuantumCumulants.jl. For any other simplification routines, operators are averaged (without applying a cumulant expansion) which makes them numbers. Those numbers are stored as expressions in SymbolicUtils.jl and simplified according to standard simplification rules. Afterwards, they can be converted back into QTerm expressions.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Here's a short example:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nh = FockSpace(:fock)\n@qnumbers a::Destroy(h)\na*a' # returns a'*a + 1\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"In order to derive equations of motion, you need to specify a Hamiltonian and the operator (or a list of operators) of which you want to derive the Heisenberg equations and pass them to meanfield, which stores both the operator as well as the average equations. In the end, we only want to work with averages.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\n@cnumbers ω η\nH = ω*a'*a + η*(a + a') # Driven cavity Hamiltonian\nme = meanfield([a, a'*a], H)","category":"page"},{"location":"implementation/#Cumulant-expansion","page":"Implementation","title":"Cumulant expansion","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Averaging (using average) and the cumulant_expansion are essential to convert the system of q-number equations to c-number equations. Averaging alone converts any operator product to a c-number, yet you will not arrive at a closed set of equations without truncating at a specific order. An average is stored as a symbolic expression. Specifically, the average of an operator op is internally represented by SymbolicUtils.Term{AvgSym}(sym_average, [op]).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The order of an average is given by the number of constituents in the product. For example","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using QuantumCumulants # hide\nh = FockSpace(:fock)\n@qnumbers a::Destroy(h)\n\navg1 = average(a)\nget_order(avg1) # 1\n\navg2 = average(a'*a)\nget_order(avg2) # 2\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The cumulant expansion can then be used to express any average by averages up to a specified order (see also the theory section):","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"cumulant_expansion(avg2, 1)\naverage(a'*a, 1) # short-hand for cumulant_expansion(average(a'*a), 1)\nnothing #hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"When deriving the equations of motion using the meanfield function, the cumulant_expansion is immediately applied if you specify an order, e.g meafield(ops,H;order=2). Before you can actually solve the system of equations, you need to ensure that it is complete, i.e. there are no averages missing. This can be checked with find_missing. Alternatively, you can automatically complete a system of equations using the complete function which will internally use find_missing to look for missing averages and derive equations for those.","category":"page"},{"location":"implementation/#Numerical-solution","page":"Implementation","title":"Numerical solution","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Finally, in order to actually solve a system of equations, we need to convert a set of equations to an ODESystem, which represents a symbolic set of ordinary differential equations. ODESystems are part of the ModelingToolkit.jl framework, which allows for generating fast numerical functions that can be directly used in the OrdinaryDiffEq.jl package. On top of that, ModelingToolkit.jl also offers a variety of additional functionality, such as the symbolic computation of Jacobians for better stability and performance.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"To obtain an ODESystem from MeanfieldEquations, you simply need to call the constructor:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using ModelingToolkit\n@named sys = ODESystem(me)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Finally, to obtain a numerical solution we can construct an ODEProblem and solve it.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using OrdinaryDiffEq\np0 = (ω => 1.0, η => 0.1)\nu0 = zeros(ComplexF64, length(me))\nprob = ODEProblem(sys,u0,(0.0,1.0),p0)\nsol = solve(prob, RK4())\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Now, the state of the system at each time-step is stored in sol.u. To access one specific solution, you can simply type e.g. sol[average(a)] to obtain the time evolution of the expectation value langle a rangle.","category":"page"},{"location":"implementation/#interface","page":"Implementation","title":"The q-number interface","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"While there are currently only two different Hilbert spaces and two different types of fundamental operators implemented, their implementations are somewhat generic. This means that one can implement custom operator types along with some commutation relations for rewriting. The requirements for that are:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Custom operator types need to be subtypes of QSym.\nBase.:*(::Operator1, ::Operator2): A multiplication method that rewrites according to a commutation relation has to be implemented.\nQuantumCumulants.ismergeable(::Operator1, ::Operator2) = true is required so pairs of Operator1 and Operator2 are detected in longer expressions and rewritten according to their commutation relation.\nOptional: custom Hilbert space type matching the new operators.","category":"page"},{"location":"implementation/#Example:-Harmonic-oscillator-quadratures","page":"Implementation","title":"Example: Harmonic oscillator quadratures","text":"","category":"section"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"To illustrate, say we would like to implement the quantum harmonic oscillator in terms of the position operator x and the momentum operator p rather than the ladder operators. They fulfill the commutation relation","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"xp = i","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"and we will use it to rewrite occurrences of xp Rightarrow px + i. For simplicity, we will define them on a FockSpace instead of defining a custom Hilbert space as well.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\n\nstruct Position <: QSym\n    hilbert\n    name\n    aon\n    metadata\nend\nPosition(hilbert, name, aon; metadata=QuantumCumulants.source_metadata(:Position, name)) =\n    Position(hilbert, name, aon, metadata)\n\nstruct Momentum <: QSym\n    hilbert\n    name\n    aon\n    metadata\nend\nMomentum(hilbert, name, aon; metadata=QuantumCumulants.source_metadata(:Momentum, name)) =\n    Momentum(hilbert, name, aon, metadata)\nnothing # hide","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"Note that any subtype to QSym needs to have the four fields shown above, and the  associated outer constructor. The outer constructor is needed for the interface to  Symbolics.jl. More fields could be added, but the four shown here are always required.  Now, for methods we simply need:","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"QuantumCumulants.ismergeable(::Position,::Momentum) = true\nBase.:*(x::Position,p::Momentum) = im + p*x\nfor T in (:Position, :Momentum)\n    @eval Base.isequal(a::$T, b::$T) = isequal(a.hilbert, b.hilbert) && isequal(a.name, b.name) && isequal(a.aon, b.aon)\nend","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"The Base.isequal methods do not compare metadata fields. Note that if your subtypes of  QSym have type parameters, you must also implement a method of Base.hash such  that isequal(x,y) implies hash(x) == hash(y).","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"We can now use our new operator types in expressions and derive equations of motion for them.","category":"page"},{"location":"implementation/","page":"Implementation","title":"Implementation","text":"h = FockSpace(:oscillator)\nx = Position(h,:x,1)\np = Momentum(h,:p,1)\n\n@cnumbers ω m\nH = p^2/(2m) + 0.5m*ω^2*x^2\n\neqs = meanfield([x,p],H)","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The basic usage is probably best illustrated with a brief example. In the following, we solve a simple model for a single-atom laser.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We start by loading the package, defining some symbolic parameters and the photonic annihilation operator a as well as the atomic transition operator σ, which denotes a transition from level j to level i as σ(i,j). This allows us to quickly write down the Hamiltonian and the collapse operators of the system with their corresponding decay rates.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing QuantumCumulants\n\n# Define parameters\n@cnumbers Δ g γ κ ν\n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf ⊗ ha\n\n# Define the fundamental operators\n@qnumbers a::Destroy(h) σ::Transition(h)\n\n# Hamiltonian\nH = Δ*a'*a + g*(a'*σ(:g,:e) + a*σ(:e,:g))\n\n# Collapse operators\nJ = [a,σ(:g,:e),σ(:e,:g)]\nrates = [κ,γ,ν]\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, we define a list of operators of which we want to compute the mean-field equations. We will only consider products of two operators. This is because later we will compute the dynamics of the system up to second order.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Derive a set of equations\nops = [a'*a,σ(:e,:e),a'*σ(:g,:e)]\neqs = meanfield(ops,H,J;rates=rates)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To obtain a closed set of equations, we expand higher-order products to second order.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Expand the above equations to second order\neqs_expanded = cumulant_expansion(eqs,2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first-order contributions are always zero and can therefore be neglected. You can try adding a and σ(:g,:e) to the list of operators ops in order to see that yourself. Or, even more conveniently, you can use complete(eqs_expanded), which will automatically find all missing averages and compute the corresponding equations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, though, we will proceed by finding the missing averages, and neglecting them as zero using the substitute and simplify function from Symbolics.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Find the missing averages\nmissed = find_missing(eqs_expanded)\n\n# Substitute them as zero\nsubs = Dict(missed .=> 0)\nusing Symbolics\neqs_nophase = simplify(substitute(eqs_expanded, subs))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we can convert the MeanfieldEquations to an ODESystem as defined in ModelingToolkit which can be solved numerically with OrdinaryDiffEq.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate an ODESystem\nusing ModelingToolkit\n@named sys = ODESystem(eqs_nophase)\n\n# Solve the system using the OrdinaryDiffEq package\nusing OrdinaryDiffEq\nu0 = zeros(ComplexF64,length(ops))\np = (Δ, g, γ, κ, ν)\np0 = p .=> (0, 1.5, 0.25, 1, 4)\nprob = ODEProblem(sys,u0,(0.0,10.0),p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Just as with variables in ModelingToolkit, the solution of the respective averages can be accessed with a getindex method. In the following we extract and plot the photon number and the atomic excited state population by indexing the solution:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nn = real.(sol[a'*a])\npe = real.(sol[σ(:e,:e)])\nplot(sol.t, n, label=\"Photon number\", xlabel=\"t\")\nplot!(sol.t, pe, label=\"Excited state population\")\nsavefig(\"tutorial.svg\") # hide\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Photon number and excited state population)","category":"page"}]
}
